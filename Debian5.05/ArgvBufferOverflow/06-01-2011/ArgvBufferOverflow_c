./apr_1.2.12/threadproc/win32/proc.c:            cmdline = apr_pstrcat(pool, shellcmd, " /C ", argv0, cmdline, NULL);
./apr_1.2.12/threadproc/win32/proc.c:            cmdline = apr_pstrcat(pool, shellcmd, " /C \"", argv0, cmdline, "\"", NULL);
./apr_1.2.12/threadproc/win32/proc.c:                cmdline = apr_pstrcat(pool, shellcmd, " /C ", argv0, cmdline, NULL);
./apr_1.2.12/threadproc/win32/proc.c:                    cmdline = apr_pstrcat(pool, shellcmd, " /C \"\"", argv0, "\"", cmdline, "\"", NULL);
./apr_1.2.12/threadproc/win32/proc.c:                    cmdline = apr_pstrcat(pool, shellcmd, " /C \"", argv0, cmdline, "\"", NULL);
./apr_1.2.12/threadproc/win32/proc.c:            cmdline = apr_pstrcat(pool, argv0, cmdline, NULL);
./bogofilter_1.1.7/src/bogoQDBMupgrade.c:	    strcpy(new_name, argv[1]);
./busybox_1.10.2/console-tools/openvt.c:	sprintf(vtname, VC_FORMAT, (int)xatou_range(argv[1], 1, 63));
./busybox_1.10.2/editors/sed.c:			G.outname = xasprintf("%sXXXXXX", argv[i]);
./busybox_1.10.2/libbb/getopt32.c:			argv[1] = xasprintf("-%s", argv[1]);
./busybox_1.10.2/loginutils/adduser.c:		pw.pw_dir = xasprintf("/home/%s", argv[0]);
./busybox_1.10.2/modutils/insmod.c:		optlen += sprintf(options + optlen, (strchr(*argv,' ') ? "\"%s\" " : "%s "), *argv);
./busybox_1.10.2/networking/vconfig.c:		strcpy(ifr.device1, argv[1]);
./busybox_1.10.2/procps/watch.c:		cmd = xasprintf("%s %s", cmd, *argv); // leaks cmd
./busybox_1.10.2/shell/ash.c:				sprintf(argv[i], " -%u", pid);
./busybox_1.10.2/shell/hush.c:					strcpy(pos, global_argv[i]);
./busybox_1.10.2/shell/hush.c:					strcpy(pos, global_argv[i]);
./busybox_1.10.2/sysklogd/logger.c:			sprintf(message + pos, " %s", *argv),
./desmume_0.8/src/cli/main.c:          strcpy(szRomPath, dirname(argv[1]));
./dx_4.4.4/src/exec/dpexec/remote.c:    strcpy(cmdpvs, fargv[0]);
./dx_4.4.4/src/exec/dpexec/remote.c:        strcat(cmdpvs, fargv[i]);
./dx_4.4.4/src/exec/dpexec/remote.c:        strcpy(nargv[r_argc], myhost);
./dx_4.4.4/src/exec/dpexec/remote.c:        sprintf(nargv[r_argc+1], "%4d", dxport);
./dx_4.4.4/src/exec/dpexec/remote.c:        strcpy(nargv[r_argc], "-connect");
./dx_4.4.4/src/exec/dpexec/remote.c:        strcpy(nargv[r_argc+1], myhost);
./dx_4.4.4/src/exec/dpexec/remote.c:        sprintf(nargv[r_argc+1]+strlen(myhost), ":%4d", dxport);
./dx_4.4.4/src/misc/dx.c:	strcpy(parm[n], argv[i]);
./dx_4.4.4/src/uipp/dxl/conn.c:    sprintf(errstr,"Could not connect using '%s'\n",fargv[0]);
./e2ps_4.34/e2ps.c:	strcpy(gsNowTime, argv[i]);
./e2ps_4.34/e2ps.c:	strcpy(gsHeadStr, argv[i]);
./e2ps_4.34/e2ps.c:	strcpy(gsPageStr, argv[i]);
./e2ps_4.34/e2ps.c:	sprintf(sStr, "引数に間違いがあります。==> %s", argv[i]);
./e2ps_4.34/e2ps.c:	sprintf(sStr, "Wrong argment==> %s", argv[i]);
./eterm_0.9.5/src/command.c:                strcpy(&p[1], argv0);
./flasm_1.62/flasm.c:			strcat(flapath, argv[1]);
./flasm_1.62/flasm.c:		strcat(flapath, argv[1]);
./flasm_1.62/flasm.c:		strcpy(inputName, argv[2]);
./flasm_1.62/flasm.c:			strcat(inputName, argv[i]);
./flasm_1.62/flasm.c:		strcpy(inputName, argv[1]);
./flasm_1.62/flasm.c:			strcat(inputName, argv[i]);
./fortunes-es_1.30/util/strfile.c:	    (void) strcpy(Outfile, *argv);
./freecell-solver_2.8.10/cmd_line.c:                sprintf(errstr, "Unknown game \"%s\"!\n\n", argv[arg]);
./freecell-solver_2.8.10/cmd_line.c:                sprintf(errstr, "Unknown scans' synergy type \"%s\"!\n", argv[arg]);
./freecell-solver_2.8.10/cmd_line.c:                    sprintf(err_str, "Unable to load the \"%s\" configuration!\n", argv[arg]);
./fvwm_2.5.26/modules/FvwmConsole/FvwmConsole.c:	strcpy(client, argv[0]);
./fvwm_2.5.26/modules/FvwmCpp/FvwmCpp.c:	  strcat(cpp_options, argv[++i]);
./fvwm_2.5.26/modules/FvwmCpp/FvwmCpp.c:	strcpy(cpp_outfile,argv[++i]);
./fvwm_2.5.26/modules/FvwmCpp/FvwmCpp.c:	strcat(cpp_options, argv[i]);
./fvwm_2.5.26/modules/FvwmIconBox/FvwmIconBox.c:    strcpy(MyName, argv[6]);
./fvwm_2.5.26/modules/FvwmM4/FvwmM4.c:	  strcat(m4_options, argv[++i]);
./fvwm_2.5.26/modules/FvwmM4/FvwmM4.c:	  strcpy(m4_outfile,argv[++i]);
./fvwm_2.5.26/modules/FvwmM4/FvwmM4.c:	  strcat(m4_options, argv[i]);
./fvwm_2.5.26/modules/FvwmWharf/FvwmWharf.c:	  sprintf(margv[1],"%x",PlayerChannel[0]);
./fvwm_2.5.26/modules/FvwmWharf/FvwmWharf.c:	      sprintf(margv[i+3],"%s/%s",SoundPath,Sounds[i]);
./fvwm_2.5.26/modules/FvwmWinList/FvwmWinList.c:    strcat(Module, argv[opt_num]);
./gridengine_6.2/source/3rdparty/qmake/function.c:      strcpy(p, *argvp);
./gridengine_6.2/source/3rdparty/qmake/function.c:  strcpy(p, *argvp);
./gridengine_6.2/source/3rdparty/qmake/remote-sge.c:   strcpy(program_name, (*p_argv)[0]);
./gridengine_6.2/source/3rdparty/qmake/remote-sge.c:               strcat(envvar, sge_v_argv[i]);
./gridengine_6.2/source/3rdparty/snprintf/test.c:      len2 = sprintf(str2,                  argv[1], j, 3);
./gridengine_6.2/source/3rdparty/snprintf/test.c:      len2 = sprintf(str2,                  argv[1], argv[2], 3);
./gridengine_6.2/source/clients/qmon/qmon_main.c:   strcpy(progname, argv[0]);
./gridengine_6.2/source/clients/qrsh/qrsh_starter.c:   strcpy(buffer, argv[0]);
./gridengine_6.2/source/clients/qrsh/qrsh_starter.c:      strcat(buffer, argv[i]);
./gridengine_6.2/source/daemons/common/startprog.c:   strcpy(prog_path, argv0);
./gridengine_6.2/source/daemons/shepherd/builtin_starter.c:      strcpy(argv0, "-");
./gridengine_6.2/source/daemons/shepherd/builtin_starter.c:      strcat(argv0, shell_basename);
./gridengine_6.2/source/daemons/shepherd/builtin_starter.c:      strcpy(argv0, shell_basename);
./gridengine_6.2/source/libs/jgdi/jgdi_test.c:      sprintf(jvm_argv[jvm_argv_index],"-Djava.class.path=%s", classpath_from_env);
./gridengine_6.2/source/libs/jgdi/jgdi_test.c:            sprintf(jvm_argv[jvm_argv_index],"-Djava.class.path=%s", argv[i]);
./gridengine_6.2/source/libs/jgdi/jgdi_test.c:            sprintf(jvm_argv[classpath_index],"%s:%s", tmp, argv[i]);
./gridengine_6.2/source/utilbin/infotext.c:      vsprintf(tbuf1, (char*) sge_dstring_get_string(&buffer2), &argv[first_arg] );
./ipband_0.8.1/popen.c:	   strcpy(argv[i], ptr);
./lphdisk_0.9.1/lphdisk.c:  if (optind < argc) strcpy(drive, argv[optind++]);
./med-fichier_2.3.1/tools/medimport/medimport.c:  strcpy(nom,argv[1]);
./med-fichier_2.3.1/tools/medimport/medimport.c:  strcat(commande,argv[1]);
./mimetex_1.50/gfuntype.c:	case 'n': strcpy(fontname,argv[argnum]); break;
./mini-httpd_1.19/htpasswd.c:    strcpy(user,argv[2]);
./mini-httpd_1.19/htpasswd.c:    sprintf(command,"cp %s %s",temp_template,argv[1]);
./mrd6_0.9.6/tools/c/mrd6sh.c:	strcpy(buf, argv[1]);
./mrd6_0.9.6/tools/c/mrd6sh.c:		sprintf(buf + ptr, " %s", argv[i]);
./nagios-nrpe_2.12/contrib/nrpe_check_control.c:  strcpy(state,argv[1]);
./nagios-nrpe_2.12/contrib/nrpe_check_control.c:  strcpy(state_type,argv[2]);
./nagios-nrpe_2.12/contrib/nrpe_check_control.c:  strcpy(host_name,argv[4]);
./openafs_1.4.7.dfsg1/src/afsweb/apache_afs_weblog.c:    strcpy(error_fname, argv[2]);
./openafs_1.4.7.dfsg1/src/aklog/aklog_main.c:		strcpy(cell, argv[i]);
./openafs_1.4.7.dfsg1/src/aklog/aklog_main.c:		strcpy(path, argv[i]);
./openafs_1.4.7.dfsg1/src/aklog/aklog_main.c:		strcpy(path, argv[i]);
./openafs_1.4.7.dfsg1/src/aklog/aklog_main.c:		strcpy(cell, argv[i]);
./openafs_1.4.7.dfsg1/src/aklog/aklog_main.c:		    strcpy(realm, argv[i]);
./openafs_1.4.7.dfsg1/src/auth/copyauth.c:    strcpy(whoami, argv[0]);
./openafs_1.4.7.dfsg1/src/auth/copyauth.c:    strcpy(tserver.cell, argv[1]);
./openafs_1.4.7.dfsg1/src/cmd/cmd.c:    strcpy(*argv, INITSTR);
./openafs_1.4.7.dfsg1/src/config/util_cr.c:    strcpy(parm, argv);
./openafs_1.4.7.dfsg1/src/config/util_cr.c:	strcpy(v5, argv[2]);
./openafs_1.4.7.dfsg1/src/config/util_cr.c:    strcpy(fname, argv[2]);
./openafs_1.4.7.dfsg1/src/config/util_cr.c:	strcpy(fname, argv[2]);
./openafs_1.4.7.dfsg1/src/log/test/testlog.c:		strcpy(cellID, argv[currArg + 1]);
./openafs_1.4.7.dfsg1/src/log/test/testlog.c:	    strcpy(passwd, argv[currArg]);
./openafs_1.4.7.dfsg1/src/login/login.c:	strcpy(rhost, *argv++);
./openafs_1.4.7.dfsg1/src/login/login.c:	strcpy(ousername, *argv);
./openafs_1.4.7.dfsg1/src/rx/rx_trace.c:	    strcpy(rxi_tracename, *(++argv));
./openafs_1.4.7.dfsg1/src/rx/test/testserver.c:	    strcpy(rxi_tracename, *(++argv)), argc--;
./openafs_1.4.7.dfsg1/src/sgistuff/rcmd.c:    vsprintf(buf, argv[0], &argv[1]);
./openafs_1.4.7.dfsg1/src/update/client.c:	    strcpy(hostname, argv[a]);
./openafs_1.4.7.dfsg1/src/update/client.c:	    strcpy(filename, argv[a]);
./openafs_1.4.7.dfsg1/src/uss/uss.c:    strcpy(uss_whoami, argv[0]);
./openafs_1.4.7.dfsg1/src/vlserver/vlserver.c:	    strcpy(rxi_tracename, argv[++index]);
./openafs_1.4.7.dfsg1/src/vlserver/vlserver.c:	strcat(commandLine, argv[i]);
./openafs_1.4.7.dfsg1/src/vol/test/listVicepx.c:	    strcpy(partition, argv[++i]);
./openafs_1.4.7.dfsg1/src/vol/test/listVicepx.c:	    strcpy(volume, argv[++i]);
./openafs_1.4.7.dfsg1/src/vol/test/updateDirInode.c:	    strcpy(partition, argv[++i]);
./openafs_1.4.7.dfsg1/src/vol/test/updateDirInode.c:	    strcpy(volume, argv[++i]);
./openafs_1.4.7.dfsg1/src/vol/vol-salvage.c:	    strcat(commandLine, argv[i]);
./openafs_1.4.7.dfsg1/src/volser/volmain.c:	strcat(commandLine, argv[i]);
./sbuild_0.57.7/src/buildd-mail-wrapper.c:  strcpy( newname, argv[0] );
./sc_7.16/sc.c:	(void) strcpy(curfile, argv[optind]);
./sdcc_2.8.0.dfsg/as/xa51/xa_main.c:  strcpy(infilename, argv[i]);
./sdcc_2.8.0.dfsg/debugger/mcs51/sdcdb.c:                    strcat(strcat(strcpy(p,&argv[i][12]),":"),ssdirl);
./sdcc_2.8.0.dfsg/support/librarian/sdcclib.c:                        strcpy(LibName, argv[j]);
./sdcc_2.8.0.dfsg/support/librarian/sdcclib.c:                        strcpy(ListName, argv[j]);
./sdcc_2.8.0.dfsg/support/librarian/sdcclib.c:                        strcpy(RelName[0], argv[j]);
./sdcc_2.8.0.dfsg/support/librarian/sdcclib.c:                    strcpy(RelName[NumRelFiles-1], argv[j]);
./sdcc_2.8.0.dfsg/support/scripts/mh2h.c:    strcpy(inc_dir, argv[1]);
./sdcc_2.8.0.dfsg/support/scripts/mh2h.c:    strcpy(bin_dir, argv[2]);
./sdcc_2.8.0.dfsg/support/Util/findme.c:	sprintf(buf, "%s/%s", start, argv0);
./sdr_3.0/src/polluted.c:      strcpy(argv[8], "des");
./sdr_3.0/src/ui_fns.c:  sprintf(interp->result, "%d", generate_port(argv[1]));
./sdr_3.0/src/www_fns.c:	  strcpy(uri, argv[2]);
./sivp_0.4.3/macros/Sci_Lib.c:  strcpy(fname,argv[1]);
./sivp_0.4.3/macros/Sci_Name.c:  strcpy(fname,argv[1]);
./splat_1.2.1/utils/citydecoder.c:		sprintf(attributefilename,"%s_d00a.dat",argv[z]);
./splat_1.2.1/utils/citydecoder.c:		sprintf(coordinatefilename,"%s_d00.dat",argv[z]);
./ssldump_0.9b3/base/pcap-snoop.c:      strcpy(ret+len,argv[i]);
./ssldump_0.9b3/ssl/main.c:    sprintf(name,"%s.c",argv[1]);
./ssldump_0.9b3/ssl/main.c:    sprintf(name,"%s.h",argv[1]);
./statserial_1.1/statserial.c:    strcpy(device, argv[optind]); /* one argument */
./trueprint_5.3/src/main.c:      sprintf(log_cmd, "%s \" <%s>\"", log_cmd, argv[i]);
./vim_7.1.314/src/workshop.c:	strcat(runpath, argv0);
./vim_7.1.314/src/workshop.c:		strcat(runpath, argv0);
./webcit_7.37-dfsg/setup.c:			strcpy(aaa, argv[a]);
./x11-utils_7.3+2+nmu1/xmessage/xmessage.c:	    strcpy(cp, argv[i]);
./xkbsel_0.13/programs/xkbsel.c:		strcpy(map_arg, argv[optind]);
./yafc_1.1.1.dfsg.1/src/commands.c:			asprintf(&tmp, "%s%s%s", new_args->argv[i], ins ? ins : "", ep);
./yafc_1.1.1.dfsg.1/src/help.c:     sprintf(tmp, "%s --help", argv[1]);
./yafc_1.1.1.dfsg.1/src/libmhe/args.c:		strcat(e, argv[i]);
./z8530-utils2_3.0-1/sccparam.c:	strcpy(ifr.ifr_name, argv[1]);
./z8530-utils2_3.0-1/sccstat.c:		strcpy(dev, argv[cnt]);
./abcmidi_20070318/yapstree.c:      strcpy(matchstring, argv[refmatch]);
./abcmidi_20070318/yapstree.c:    /*strcpy(outputname, argv[filearg]); security risk buffer overflow */
./abcmidi_20070318/yapstree.c:    /* strcpy(outputname, argv[1]); security risk: buffer overflow */
./abook_0.5.6/getopt.c:		sprintf(var, "_%d_GNU_nonoption_argv_flags_", getpid());
./aboot_1.0~pre20040408/tools/e2writeboot.c:    strcpy(fsname, argv[1]);
./ack_1.39/kmain.c:			strcpy( cp.fname, *argv );
./acm_5.0/src/main.c:			sprintf(&switches[strlen(switches)], "|-geometry|%s", argv[i]);
./acm_5.0/src/main.c:			sprintf(&switches[strlen(switches)], "|-plane|%s", argv[i]);
./acm_5.0/src/main.c:			sprintf(&switches[strlen(switches)], "|-team|%s", argv[i]);
./acm_5.0/src/main.c:			sprintf(&switches[strlen(switches)], "|-altitude|%s", argv[i]);
./acm_5.0/src/main.c:			sprintf(&switches[strlen(switches)], "|-altitude|%s", argv[i]);
./acm_5.0/src/main.c:			sprintf(&switches[strlen(switches)], "|-altitude|%s", argv[i]);
./acm_5.0/src/main.c:			sprintf(&switches[strlen(switches)], "|-heading|%s", argv[i]);
./acm_5.0/src/main.c:			sprintf(&switches[strlen(switches)], "|-airspeed-kts|%s", argv[i]);
./adanaxisgpl_1.2.5.dfsg.1/src/MushRuby/io.c:    rb_io_write(out, rb_f_sprintf(argc, argv));
./adanaxisgpl_1.2.5.dfsg.1/src/MushRuby/io.c:    rb_io_write(out, rb_f_sprintf(argc, argv));
./adanaxisgpl_1.2.5.dfsg.1/src/MushRuby/process.c:	    new_argv[1] = strcpy(ALLOCA_N(char, strlen(argv[0]) + 1), argv[0]);
./adanaxisgpl_1.2.5.dfsg.1/src/MushRuby/process.c:	new_argv[1] = strcpy(ALLOCA_N(char, strlen(argv[0]) + 1), argv[0]);
./adanaxisgpl_1.2.5.dfsg.1/src/MushRuby/sprintf.c:rb_f_sprintf(argc, argv)
./adanaxisgpl_1.2.5.dfsg.1/src/MushRuby/string.c:	return rb_f_sprintf(RARRAY(arg)->len+1, argv);
./adanaxisgpl_1.2.5.dfsg.1/src/MushRuby/string.c:    return rb_f_sprintf(2, argv);
./agrep_4.17/agrep.c:					strcpy(D_pattern+1, argv[0]);
./agrep_4.17/agrep.c:					strcpy(COMP_DIR, argv[0]);
./agrep_4.17/agrep.c:						strcat(Pattern, (argv)[0]);
./agrep_4.17/agrep.c:					else strcat(Pattern, argv[0]);
./agrep_4.17/agrep.c:					strcat(Pattern, argv[0]);
./agrep_4.17/agrep.c:				strcpy(PAT_FILE_NAME, argv[0]);
./agrep_4.17/agrep.c:					strcpy(multibuf, argv[0]);
./agrep_4.17/agrep.c:		strcpy(Pattern, *argv); 
./agrep_4.17/agrep.c:				strcpy(Textfiles[Numfiles++], *argv++);
./agrep_4.17/recursive.c:		strcpy(name_buf, argv[i]);
./agrep_4.17/recursive.c:			strcpy(buf, *++argv);
./aish_1.13/aish.c:	for(; --argc && (p_strcpy( ptr, *++argv ),1) ;)
./aish_1.13/aish.c:						p_strcpy( hp.skipname, *++argv );
./aish_1.13/aish.c:						p_strcpy( hp.outname,*++argv);
./aish_1.13/aishmv.c:	for(; --argc && (p_strcpy( ptr, *++argv ),1) ;)
./aish_1.13/aishmv.c:						p_strcpy( sname, *++argv );
./aish_1.13/aishmv.c:						p_strcpy( tmpnm, *++argv );
./allegro4.2_4.2.2/docs/src/makedoc/makedoc.c:	 strcpy(txtname, argv[++i]);
./allegro4.2_4.2.2/docs/src/makedoc/makedoc.c:	 strcpy(chmname, argv[++i]);	 
./allegro4.2_4.2.2/docs/src/makedoc/makedoc.c:	 strcpy(devhelpname, argv[++i]);	 
./allegro4.2_4.2.2/docs/src/makedoc/makedoc.c:	 strcpy(scitename, argv[++i]);
./allegro4.2_4.2.2/docs/src/makedoc/makedoc.c:	 strcpy(htmlname, argv[++i]);
./allegro4.2_4.2.2/docs/src/makedoc/makedoc.c:	 strcpy(htmlname, argv[++i]);
./allegro4.2_4.2.2/docs/src/makedoc/makedoc.c:	 strcpy(texinfoname, argv[++i]);
./allegro4.2_4.2.2/docs/src/makedoc/makedoc.c:	 strcpy(texinfoname, argv[++i]);
./allegro4.2_4.2.2/docs/src/makedoc/makedoc.c:	 strcpy(rtfname, argv[++i]);
./allegro4.2_4.2.2/docs/src/makedoc/makedoc.c:	 strcpy(manname, argv[++i]);
./allegro4.2_4.2.2/docs/src/makedoc/makedoc.c:	 strcpy(filename, argv[i]);
./allegro4.2_4.2.2/misc/vcvars.c:      strcat(cmd, argv[i]);
./allegro4.2_4.2.2/tests/digitest.c:      strcpy(samplename, argv[1]);
./allegro4.2_4.2.2/tools/dat2s.c:	 strcpy(prefix, argv[++c]);
./allegro4.2_4.2.2/tools/grabber.c:	    strcpy(password, argv[i]+2);
./allegro4.2_4.2.2/tools/grabber.c:	    strcpy(tmp, argv[i]+1);
./allegro4.2_4.2.2/tools/macosx/fixbundle.c:	 strcpy(bundle, argv[++arg]);
./allegro4.2_4.2.2/tools/macosx/fixbundle.c:	 strcpy(bundle_version, argv[++arg]);
./allegro4.2_4.2.2/tools/macosx/fixbundle.c:	 strcpy(bundle_long_version, argv[++arg]);
./allegro4.2_4.2.2/tools/macosx/fixbundle.c:	 strcpy(datafile, argv[++arg]);
./allegro4.2_4.2.2/tools/pat2dat.c:		  strcat(filename, argv[1]);
./allegro4.2_4.2.2/tools/win/wfixicon.c:               strcpy(dat_name, argv[++arg]);
./allegro4.2_4.2.2/tools/win/wfixicon.c:      sprintf(str, "allegro_icon ICON %s\n", argv[1]);
./alogg_1.3.7/alogg_encode.c:      sprintf(title,"TITLE=%s",argv[n]);
./alogg_1.3.7/alogg_encode.c:      strcpy(filename,argv[n]);
./amavisd-new_2.6.1.dfsg/helper-progs/amavis.c:	    path = strcpy(path, argv[ldaargs_ind]);
./antiword_0.37/startup.c:			strcat(szCommand, argv[1]);
./antiword_0.37/startup.c:		strcpy(tMsg.data.dataload.filename, argv[1]);
./apache2_2.2.9/srclib/apr/threadproc/win32/proc.c:            cmdline = apr_pstrcat(pool, shellcmd, " /C ", argv0, cmdline, NULL);
./apache2_2.2.9/srclib/apr/threadproc/win32/proc.c:            cmdline = apr_pstrcat(pool, shellcmd, " /C \"", argv0, cmdline, "\"", NULL);
./apache2_2.2.9/srclib/apr/threadproc/win32/proc.c:                cmdline = apr_pstrcat(pool, shellcmd, " /C ", argv0, cmdline, NULL);
./apache2_2.2.9/srclib/apr/threadproc/win32/proc.c:                    cmdline = apr_pstrcat(pool, shellcmd, " /C \"\"", argv0, "\"", cmdline, "\"", NULL);
./apache2_2.2.9/srclib/apr/threadproc/win32/proc.c:                    cmdline = apr_pstrcat(pool, shellcmd, " /C \"", argv0, cmdline, "\"", NULL);
./apache2_2.2.9/srclib/apr/threadproc/win32/proc.c:            cmdline = apr_pstrcat(pool, argv0, cmdline, NULL);
./apache2_2.2.9/test/cls.c:        sprintf(path, "%s/%s", argv[1], s);
./apcupsd_3.14.4/examples/client.c:      strcpy(host, argv[1]); /* get host from command line */
./apcupsd_3.14.4/examples/megaclient.c:      strcpy(host, argv[1]); /* get host from command line */
./apcupsd_3.14.4/examples/nagios_plugin_check_apcupsd.c:      strcpy(host, argv[1]); /* get host from command line */
./apcupsd_3.14.4/examples/newslave.c:      strcpy(host, argv[1]); /* get host from command line */
./apcupsd_3.14.4/examples/upsapm.c:      strcpy(host, argv[1]); /* get host from command line */
./apsfilter_7.2.6/contrib/okidisplay/okidisplay.c:		strcat(strcat(buf," "), argv[i]);
./arj_3.10.22/arjsfx.c:  strcpy(archive_name, argv[0]);
./arj_3.10.22/msgbind.c: strcat(target_i, argv[2]);
./arj_3.10.22/msgbind.c: strcat(target_n, argv[2]);
./arj_3.10.22/msgbind.c: strcat(target_f, argv[2]);
./arj_3.10.22/msgbind.c: strcat(target_h, argv[2]);
./arj_3.10.22/packager.c: sprintf(pkg_rsp_draft, "%s" P "pkg_dft.rsp", argv[2]);
./arj_3.10.22/packager.c: sprintf(pkg_rsp, "%s" P "pkg.rsp", argv[2]);
./arj_3.10.22/packager.c: sprintf(tmp_name, "%s" P "cmt.txt", argv[2]);
./arj_3.10.22/packager.c:  sprintf(platform_specific, "-e1 %s" P "u" P, argv[2]);
./arj_3.10.22/packager.c:  sprintf(platform_specific, "%s" P "u", argv[2]);
./arj_3.10.22/packager.c: sprintf(cmdline, "%s" P "arj" P "arj @%s -+", argv[1], pkg_rsp);
./arj_3.10.22/today.c: strcpy(out_name, argv[2]);
./asmix_1.5/asmix.c:	strcpy(&Execute[0], argv[i]);
./asmixer_0.5/asmixer.c:				strcpy(&device[0], argv[i]);
./asmixer_0.5/asmixer.c:				strcpy(&wintitle[0], argv[i]);
./aspectc++_1.0pre4~svn.20080711/Puma/tools/lemon/lemon.c:    if( path ) sprintf(path,"%s/%s",argv0,name);
./asterisk_1.4.21.2~dfsg/main/asterisk.c:		strcpy(argv[0], "rasterisk");
./avrdude_5.5/windows/loaddrv.c:            sprintf(path, "%s\\%s.sys", cwd, argv[2]);
./awesome_2.3.3/awesome.c:    a_strcpy(globalconf.argv, cmdlen, argv[0]);
./awesome_2.3.3/awesome.c:        a_strcat(globalconf.argv, cmdlen, " ");
./awesome_2.3.3/awesome.c:        a_strcat(globalconf.argv, cmdlen, argv[i]);
./ax25-apps_0.0.6/ax25rtd/ax25rtctl.c:				len += sprintf(buf + len, " %s", argv[k]);
./ax25-apps_0.0.6/ax25rtd/ax25rtctl.c:				len += sprintf(buf + len, " %s", argv[k]);
./ax25-apps_0.0.6/ax25rtd/ax25rtctl.c:			sprintf(buf, "del ax25 %s %s\n", argv[optind],
./ax25-apps_0.0.6/ax25rtd/ax25rtctl.c:			sprintf(buf, "del ip %s\n", argv[optind]);
./barnowl_1.0.1/commands.c:	strcat(newbuff, myargv[0]);
./barnowl_1.0.1/commands.c:      sprintf(recip, "%s ", argv[1]);
./barnowl_1.0.1/commands.c:  sprintf(newbuff, "%s ", argv[0]);
./barnowl_1.0.1/commands.c:    strcat(newbuff, argv[i+1]);
./barnowl_1.0.1/commands.c:    text = owl_sprintf("filter %s", argv[1]);
./barnowl_1.0.1/global.c:    sprintf(g->startupargs, "%s%s ", g->startupargs, argv[i]);
./barnowl_1.0.1/util.c:      strcpy(argv[*argc], curarg);
./barnowl_1.0.1/zwrite.c:	strcat(z->message, myargv[0]);
./bible-kjv_4.23/debian/randverse.c:      strcat(opt, argv[i]);
./bibtool_2.48alpha.2/BibTcl/bibtool.c:  strcpy(s,argv[1]);
./bibtool_2.48alpha.2/BibTcl/bibtool.c:  strcat(s,argv[2]);
./bind9_9.6.ESV.R1+dfsg/contrib/idn/idnkit-1.0-src/lib/resconf.c:	sprintf(scheme_name, "%s%s", IDN_CHECKER_PROHIBIT_PREFIX, argv[0]);
./bind9_9.6.ESV.R1+dfsg/contrib/idn/idnkit-1.0-src/lib/resconf.c:	sprintf(scheme_name, "%s%s", IDN_CHECKER_UNASSIGNED_PREFIX, argv[0]);
./bind9_9.6.ESV.R1+dfsg/contrib/idn/idnkit-1.0-src/lib/resconf.c:	sprintf(scheme_name, "%s%s", IDN_CHECKER_BIDI_PREFIX, argv[0]);
./bind9_9.6.ESV.R1+dfsg/lib/dns/zone.c:			strcpy(tmp2, zone->db_argv[i]);
./binkd_0.9.9+rel/binkd.c:	        strcpy(saved_argv[i]+(s-argv[i]), saved_argv[i]+(s-argv[i])+1);
./binkd_0.9.9+rel/nt/service.c:          len += sprintf(asp+len, "%s", argv[i]) + 1; /* count \0 */
./binstats_1.08/derefsymlink.c:	    strcpy(iname, argv[++i]);
./binstats_1.08/derefsymlink.c:	    strcpy(oname, argv[++i]);
./bitcollider_0.6.0/src/bitcollider.c:          strcpy(tagFile, argv[++argIndex]);
./bitcollider_0.6.0/src/bitcollider.c:              sprintf(checkAsExt, ".%s", argv[argIndex]);
./bitcollider_0.6.0/src/bitcollider.c:              strcpy(checkAsExt, argv[argIndex]);
./bitcollider_0.6.0/src/bitcollider.c:         strcpy(fileName, argv[argIndex]);
./blender_2.46+dfsg/release/datafiles/datatoc.c:	sprintf(cname, "%s.c", argv[1]);
./blender_2.46+dfsg/source/blender/makesdna/intern/makesdna.c:				strcpy(baseDirectory, argv[2]);
./blender_2.46+dfsg/source/blender/src/playanim.c:	if (argc > 1) strcpy(name,argv[1]);
./blender_2.46+dfsg/source/blender/src/playanim.c:		strcpy(name, argv[i]);
./blender_2.46+dfsg/source/gameengine/GamePlayer/netscape/src/UnixShell.c:				strcpy(This->loading_animation, argv[i]);
./blender_2.46+dfsg/source/gameengine/GamePlayer/netscape/src/UnixShell.c:				strcpy(This->blend_file, argv[i]);
./blt_2.4z/src/bltHierbox.c:	    sprintf(info, "\n    (while loading bindings for %s)", argv[0]);
./blt_2.4z/src/bltHierbox.c:	strcat(string, argv[5]);
./blt_2.4z/src/bltHierbox.c:	strcpy(string, argv[5]);
./blt_2.4z/src/bltHierbox.c:	strcpy(p, argv[5]);
./blt_2.4z/src/bltTable.c:	    sprintf(string, "%c%d", argv[i][0], rcPtr->index);
./blt_2.4z/src/bltTable.c:	sprintf(string, "%c%d", argv[3][0], rcPtr->index);
./blt_2.4z/src/bltTable.c:	    sprintf(string, "%c%d %d %d %d %d\n", argv[3][0], rcPtr->index,
./blt_2.4z/src/bltTabnotebook.c:	    sprintf(info, "\n    (while loading bindings for %s)", argv[0]);
./blt_2.4z/src/bltTabset.c:	    sprintf(info, "\n    (while loading bindings for %s)", argv[0]);
./blt_2.4z/src/bltUnixPipe.c:	sprintf(errSpace, "%dcan't execute \"%.150s\": ", errno, argv[0]);
./boinc_6.2.14/zip/unzip/process.c:            strcpy(G.zipfn, G.argv0);
./boinc_6.2.14/zip/zip/zip.c:          strcpy(tempath, argv[i]);
./boinc_6.2.14/zip/zip/zip.c:          strcpy(key, argv[i]);
./boinc_6.2.14/zip/zip/zip.c:        strcat(strcat(errbuf, argv[i]), "\" ");
./boinc_6.2.14/zip/zip/zip.c:      strcat(strcat(errbuf, argv[i]), " *.* -i");
./boinc_6.2.14/zip/zip/zip.c:        strcat(strcat(errbuf, " "), argv[i]);
./boinc_6.2.14/zip/zip/zip.c:        strcat(strcat(errbuf, " "), argv[i]);
./brandy_1.20~pre5/src/brandy.c:          strcpy(basicvars.loadpath, argv[n]);
./bvi_1.3.2/bmore.c:	strcpy(helppath, argv[0]);
./bvi_1.3.2/bmore.c:				strcpy(sstring, &argv[n][2]);
./bvi_1.3.2/bvi.c:					strcpy(cmdstr, argv[++n]);
./bvi_1.3.2/bvi.c:				strcpy(cmdstr, &argv[n][1]);
./bvi_1.3.2/comm.c:						sprintf(string, "File exists@- use \"%s! %s\" to overwrite", cmdname, c_argv[0]);
./bwbasic_2.20pl2/bwbasic.c:      strcpy( CURTASK progfile, argv[ 1 ] ); /* JBV */
./bwbasic_2.20pl2/bwbasic.c:            sprintf( bwb_ebuf, err_openfile, argv[ 1 ] );
./bwbasic_2.20pl2/bwbasic.c:         /* strcpy( CURTASK progfile, argv[ 1 ] ); */  /* Removed by JBV */
./bwbasic_2.20pl2/bwb_mth.c:   sprintf( tbuf, " %.*f", prn_precision( &( argv[ 0 ] ) ), 
./bwbasic_2.20pl2/bwb_mth.c:   sprintf( tbuf, "%X", (int) trnc_int( (bnumber) var_getnval( &( argv[ 0 ] )) ) );
./bwbasic_2.20pl2/bwb_mth.c:   /* sprintf( tbuf, "%o", (int) var_getnval( &( argv[ 0 ] ) ) ); */
./bwbasic_2.20pl2/bwb_mth.c:   sprintf( tbuf, "%o", (int) trnc_int( (bnumber) var_getnval( &( argv[ 0 ] )) ) );
./bwbasic_2.20pl2/renum.c:   if (argc > 1) strcpy(pstr, argv[1]);
./camserv_0.5.1/camserv/camserv.c:    strcpy( tmpbuf, argv[ 0 ] ); /* Last resort */
./catdoc_0.94.2/src/fileutil.c:	strcpy(pathbuf,_argv[0]); /* DOS ensures, that our exe path is no
./caudium_1.4.12/src/tools/htpasswd.c:  strcpy(user,argv[2]);
./caudium_1.4.12/src/tools/htpasswd.c:  sprintf(command,"cp %s %s",tn,argv[1]);
./caudium_1.4.12/tools/smartlink.c:      strcat(buffer, argv[1]);
./caudium_1.4.12/tools/smartlink.c:      strcat(buffer, argv[1]);
./ccmalloc_0.4.0/test/test_C_17.c:      sprintf(buffer, "%s %d", argv[0], n - 1);
./ccontrol_0.9.1+20071204/ccontrol.c:			strcpy(dirname, argv[1] + strlen("--section="));
./c-cpp-reference_2.0.2/reference/C/CONTRIB/SNIP/chgext.c:      strcpy(path, strupr(argv[1]));
./c-cpp-reference_2.0.2/reference/C/CONTRIB/SNIP/flopcopy.c:      strcpy(target, argv[2]);
./c-cpp-reference_2.0.2/reference/C/CONTRIB/SNIP/getopts.c:                              strcpy(ptr->buf, &argv[i][2]);
./c-cpp-reference_2.0.2/reference/C/CONTRIB/SNIP/getopts.c:                              strcat(strcpy(xargv[argidx], path), ffblk.name);
./c-cpp-reference_2.0.2/reference/C/CONTRIB/SNIP/killff.c:   strcpy(name,argv[1]);                     /* input filename   */
./c-cpp-reference_2.0.2/reference/C/CONTRIB/SNIP/killff.c:   if(argc == 3) strcpy(temp,argv[2]);       /* outfile name     */
./c-cpp-reference_2.0.2/reference/C/CONTRIB/SNIP/log.c:        sprintf( outline, "%3s %ld %s", argv[ 1 ], current_time,
./c-cpp-reference_2.0.2/reference/C/CONTRIB/SNIP/mv.c:                  strcpy(target, argv[argc - 1]);
./c-cpp-reference_2.0.2/reference/C/CONTRIB/SNIP/mv.c:                        strcat(target, strrchr(argv[src], '\\') + 1);
./c-cpp-reference_2.0.2/reference/C/CONTRIB/SNIP/mv.c:                        strcat(target, argv[src] + 2);
./c-cpp-reference_2.0.2/reference/C/CONTRIB/SNIP/mv.c:                  else  strcat(target, argv[src]);
./c-cpp-reference_2.0.2/reference/C/CONTRIB/SNIP/pr.c:                        strcpy(filenames[fi++], xargv[pn]);
./c-cpp-reference_2.0.2/reference/C/CONTRIB/SNIP/vfname.c:            strcpy(fname, *(++argv));
./c-cpp-reference_2.0.2/reference/C/CONTRIB/SNIP/wc.c:      strcpy(infile,argv[1]);
./c-cpp-reference_2.0.2/reference/C/CONTRIB/SNIP/where.c:            strcpy(sought,argv[1]);
./chrony_1.23/client.c:    strcat(line, argv[i]);
./ckermit_211/ckuusy.c:	    /* strcpy(kermrc,*xargv); ... already done in prescan()... */
./clara_20031214/sclara.c:            t += sprintf(s+t,"mc=%s\n",argv[8]);
./clara_20031214/sclara.c:            t += sprintf(s+t,"dt=%s\n",argv[4]);
./claws-mail_3.5.0/src/crash.c:		sprintf(buf, "%d,%d,%s", getppid(), sig, argv0);
./clif_0.93/utils/yy.c:		{strcat(yytext,argvv);
./clif_0.93/utils/yy.c:		{strcat(yytext,argvv);
./clif_0.93/utils/yy.c:		{strcat(yytext,argvv);
./clif_0.93/utils/yy.c:		{strcat(yytext,argvv);
./clif_0.93/utils/yy.c:		{strcat(yytext,argvv);
./clif_0.93/utils/yy.c:		{strcat(yytext,argvv);
./clif_0.93/utils/yy.c:		{strcat(yytext,argvv);
./clif_0.93/utils/yy.c:			 strcat(argvv_tmp,"U");
./clif_0.93/utils/yy.c:			 strcat(argvv_tmp,argvv);
./clif_0.93/utils/yy.c:			 strcat(argvv_tmp,"(");
./clif_0.93/utils/yy.c:			 strcpy(yytext,argvv_tmp);
./clif_0.93/utils/yy.c:/*			strcpy(yytext,strcat(strcat("U",argvv),"("));*/
./clif_0.93/utils/yy.c:		{strcat(yytext,argvv);
./clif_0.93/utils/yy.c:		{strcat(yytext,argvv);
./clif_0.93/utils/yy.c:		{strcat(yytext,argvv);
./clif_0.93/utils/yy.c:		{strcat(yytext,argvv);
./clig_1.9.11.1/c/catArgv.c:  strcpy(s, argv[0]);
./clig_1.9.11.1/c/catArgv.c:    strcpy(t, argv[i]);
./clustalw-mpi_0.15/clustalw-mpi.c:	    strcpy(args[i - 1], argv[i]);
./clustalx_1.83/clustalw.c:			strcpy(args[i-1],argv[i]);
./clustalx_1.83/clustalx.c:                        strcpy(args[i-1],argv[i]);
./commons-daemon_1.0.2~svn20061127/src/native/nt/procrun/apps/srvbatch/srvbatch.c:    lstrcpy(_service_name, argv[i++]);
./commons-daemon_1.0.2~svn20061127/src/native/nt/procrun/apps/srvbatch/srvbatch.c:        lstrcpy(_working_path, argv[i++]);
./commons-daemon_1.0.2~svn20061127/src/native/nt/procrun/apps/srvbatch/srvbatch.c:        lstrcpy(_service_disp, argv[i++]);
./commons-daemon_1.0.2~svn20061127/src/native/nt/procrun/apps/srvbatch/srvbatch.c:        lstrcpy(_service_desc, argv[i++]);
./commons-daemon_1.0.2~svn20061127/src/native/nt/procrun/apps/srvbatch/srvbatch.c:        lstrcpy(_service_bat, argv[i++]);
./commons-daemon_1.0.2~svn20061127/src/native/unix/native/jsvc-unix.c:          strcpy(buf,argv[0]);
./compartment_1.1.0/compartment.c:        strcat(buf, argv[0]); // argv[0] can not be bigger than 4096
./courier_0.60.0/cgi/cgi.c:			strcat(buf, argp->argvalue);
./courier_0.60.0/courier/module.local/local.c:		strcpy(argv[4], fd < 0 ? "rcptfilter":"smtpfilter");
./courier_0.60.0/courier/module.local/local.c:			strcat(strcat(argv[4], "-"), addr);
./courier_0.60.0/imap/imapd.c:		strcat(strcat(strcpy(q, p), "/"), argv0);
./courier_0.60.0/imap/imapd.c:		strcpy(q, argv0);
./courier-authlib_0.61.0/authmksock.c:	strcpy(skun.sun_path, argv[1]);
./courier-authlib_0.61.0/authpasswd.c:		sprintf(hint, "{%1.15s}", argv[1]);
./courier-authlib_0.61.0/authuserdbpwd.c:	strcpy(argv[1],udb->udb_source ? udb->udb_source:"");
./courier-authlib_0.61.0/authuserdbpwd.c:	strcat(argv[1],uid);
./courier-authlib_0.61.0/authuserdbpwd.c:	sprintf(argv[3], "%spw=%s", services, npwd);
./crafty_20.14/main.c: 	//strcpy(buffer, argv[i]);
./crafty_20.14/main.c: 	  //strcpy(buffer, argv[i]);
./crash_4.0-6.3/cmdline.c:		strcpy(buf, less_argv[0]);
./crash_4.0-6.3/cmdline.c:		strcpy(buf, more_argv[0]);
./crash_4.0-6.3/cmdline.c:			strcpy(pc->pipe_command, less_argv[0]);
./crash_4.0-6.3/cmdline.c:			strcpy(pc->pipe_command, more_argv[0]);
./crash_4.0-6.3/cmdline.c:			strcpy(pc->pipe_command, CRASHPAGER_argv[0]);
./crash_4.0-6.3/cmdline.c:                        strcpy(pc->pipe_command, less_argv[0]);
./crash_4.0-6.3/cmdline.c:                        strcpy(pc->pipe_command, more_argv[0]);
./crash_4.0-6.3/cmdline.c:                        strcpy(pc->pipe_command, CRASHPAGER_argv[0]);
./crashme_2.4/crashme.c:   {sprintf(note_buffer,"Subprocess %s: ",argv[4]);
./crashme_2.4/crashme.c:       strcat(notes,argv[j]);}
./crawl_0.4.1/source/rltiles/bmp2png/bmp2png.c:	argv0 = strcpy(exename, basname(argv0));
./crawl_0.4.1/source/rltiles/bmp2png/png2bmp.c:	argv0 = strcpy(exename, basname(argv0));
./crawl_0.4.1/source/rltiles/tool/dcpl.c:        strcpy(fn,argv[1]);
./crawl_0.4.1/source/rltiles/tool/dcqv.c:  else strcpy(fn,argv[1]);
./crawl_0.4.1/source/rltiles/tool/dctile.c:        strcpy(fn,argv[1]);
./crawl_0.4.1/source/rltiles/tool/mkmap.c:  else strcpy(fn,argv[1]);
./crawl_0.4.1/source/rltiles/tool/mkmapq.c:  else strcpy(fn,argv[1]);
./crawl_0.4.1/source/rltiles/tool/shade.c:    strcpy(fn, argv[1]);
./crawl_0.4.1/source/util/sqlite/sqlite3.c:  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));
./crawl_0.4.1/source/util/sqlite/sqlite3.c:  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));
./crawl_0.4.1/source/util/sqlite/sqlite3.c:        strcpy(z, argv[i]);
./crimson_0.5.1/tools/bi2cf.c:                strcpy(mapinfo.title, argv[++i]);
./crimson_0.5.1/tools/bi2cf.c:                strcpy(mapinfo.info, argv[++i]);
./crimson_0.5.1/tools/bi2cf.c:                strcpy(mapfiles.srcfilename, argv[++i]);
./crimson_0.5.1/tools/bi2cf.c:                strcpy(mapfiles.inputdir, argv[++i]);
./crimson_0.5.1/tools/bi2cf.c:                strcpy(mapfiles.outputdir, argv[++i]);
./crimson_0.5.1/tools/bi2cf.c:            strcpy(mapinfo.number,argv[i]);
./csound_5.08.0.dfsg2/frontends/tclcsound/commands.c:      sprintf(cmd, "csound %s", argv[1]);
./csound_5.08.0.dfsg2/frontends/tclcsound/commands.c:        strcpy(p->inchan->name, argv[1]);
./csound_5.08.0.dfsg2/frontends/tclcsound/commands.c:        strcpy(p->outchan->name, argv[1]);
./csound_5.08.0.dfsg2/frontends/tclcsound/commands.c:          strcpy((char *) pvalue, argv[2]);
./csound_5.08.0.dfsg2/frontends/tclcsound/commands.c:      strcpy(p->mess, argv[1]);
./csound_5.08.0.dfsg2/Opcodes/OSC.c:        strcpy(evt->e.strarg, &(argv[i]->s));
./csound_5.08.0.dfsg2/Opcodes/py/pythonopcodes.c:      sprintf(statement, "%s(%0.6f", callable, *(argv[0]));
./csound_5.08.0.dfsg2/Opcodes/py/pythonopcodes.c:        sprintf(statement + strlen(statement), ", %f", *(argv[i]));
./csound_5.08.0.dfsg2/Top/argdecode.c:      strcpy(p2, argv_[i]);
./csound_5.08.0.dfsg2/util1/csd_util/cs.c:        strcpy(tmp, argv[i]);
./csound_5.08.0.dfsg2/util1/csd_util/cs.c:        strcat(extra_opts, argv[i]);
./csound_5.08.0.dfsg2/util1/csd_util/cs.c:    strcpy(tmp, cs_argv[0]);                    /* with path */
./csync2_1.34/cygwin/cs2hintd.c:			pos += sprintf(command+pos, " '%s'", argv[i]);
./ctn_3.0.6/apps/ctnnetwork/ctnnetwork.c:	    strcpy(G_nodename, *argv);
./ctn_3.0.6/apps/ctnnetwork/enq_ctnnetwork.c:    strcpy(e.vendorid, argv[2]);
./ctn_3.0.6/apps/ctnnetwork/enq_ctnnetwork.c:    strcpy(e.dpnid, argv[3]);
./ctn_3.0.6/apps/database/dbaddimage.c:    strcpy(image.ImageNumber, argv[1]);
./ctn_3.0.6/apps/database/dbaddimage.c:    strcpy(image.ImageUID, argv[2]);
./ctn_3.0.6/apps/database/dbaddimage.c:    strcpy(image.ClassUID, argv[3]);
./ctn_3.0.6/apps/database/dbaddimage.c:    strcpy(image.FileName, argv[4]);
./ctn_3.0.6/apps/database/dbaddimage.c:    strcpy(patid, argv[5]);
./ctn_3.0.6/apps/database/dbaddimage.c:    strcpy(studyuid, argv[6]);
./ctn_3.0.6/apps/database/dbaddimage.c:    strcpy(seriesuid, argv[7]);
./ctn_3.0.6/apps/database/dbaddimage.c:    strcpy(dbname, argv[8]);
./ctn_3.0.6/apps/database/dbaddpat.c:    strcpy(pat.BirthDate, argv[1]);
./ctn_3.0.6/apps/database/dbaddpat.c:    strcpy(pat.Name, argv[2]);
./ctn_3.0.6/apps/database/dbaddpat.c:    strcpy(pat.PatID, argv[3]);
./ctn_3.0.6/apps/database/dbaddpat.c:    strcpy(dbname, argv[4]);
./ctn_3.0.6/apps/database/dbaddseries.c:    strcpy(series.Modality, argv[1]);
./ctn_3.0.6/apps/database/dbaddseries.c:    strcpy(series.SeriesNumber, argv[2]);
./ctn_3.0.6/apps/database/dbaddseries.c:    strcpy(series.SeriesUID, argv[3]);
./ctn_3.0.6/apps/database/dbaddseries.c:    strcpy(patid, argv[4]);
./ctn_3.0.6/apps/database/dbaddseries.c:    strcpy(studyuid, argv[5]);
./ctn_3.0.6/apps/database/dbaddseries.c:    strcpy(dbname, argv[6]);
./ctn_3.0.6/apps/database/dbaddstudy.c:    strcpy(study.StudyDate, argv[1]);
./ctn_3.0.6/apps/database/dbaddstudy.c:    strcpy(study.StudyTime, argv[2]);
./ctn_3.0.6/apps/database/dbaddstudy.c:    strcpy(study.StudyID, argv[3]);
./ctn_3.0.6/apps/database/dbaddstudy.c:    strcpy(study.AccessionNumber, argv[4]);
./ctn_3.0.6/apps/database/dbaddstudy.c:    strcpy(study.StudyUID, argv[5]);
./ctn_3.0.6/apps/database/dbaddstudy.c:    strcpy(study.ReferringPhysName, argv[6]);
./ctn_3.0.6/apps/database/dbaddstudy.c:    strcpy(study.InterpretingPhysName, argv[7]);
./ctn_3.0.6/apps/database/dbaddstudy.c:    strcpy(study.ProcedureDescription, argv[8]);
./ctn_3.0.6/apps/database/dbaddstudy.c:    strcpy(study.AdmittingDiagnosedDescription, argv[9]);
./ctn_3.0.6/apps/database/dbaddstudy.c:    strcpy(patid, argv[10]);
./ctn_3.0.6/apps/database/dbaddstudy.c:    strcpy(dbname, argv[11]);
./ctn_3.0.6/apps/database/dbdelimage.c:    strcpy(imageuid, argv[1]);
./ctn_3.0.6/apps/database/dbdelimage.c:    strcpy(patid, argv[2]);
./ctn_3.0.6/apps/database/dbdelimage.c:    strcpy(studyuid, argv[3]);
./ctn_3.0.6/apps/database/dbdelimage.c:    strcpy(seriesuid, argv[4]);
./ctn_3.0.6/apps/database/dbdelimage.c:    strcpy(dbname, argv[5]);
./ctn_3.0.6/apps/database/dbdelpat.c:    strcpy(pat, argv[1]);
./ctn_3.0.6/apps/database/dbdelpat.c:    strcpy(dbname, argv[2]);
./ctn_3.0.6/apps/database/dbdelseries.c:    strcpy(seriesuid, argv[1]);
./ctn_3.0.6/apps/database/dbdelseries.c:    strcpy(patid, argv[2]);
./ctn_3.0.6/apps/database/dbdelseries.c:    strcpy(studyuid, argv[3]);
./ctn_3.0.6/apps/database/dbdelseries.c:    strcpy(dbname, argv[4]);
./ctn_3.0.6/apps/database/dbdelstudy.c:    strcpy(study, argv[1]);
./ctn_3.0.6/apps/database/dbdelstudy.c:    strcpy(patid, argv[2]);
./ctn_3.0.6/apps/database/dbdelstudy.c:    strcpy(dbname, argv[3]);
./ctn_3.0.6/apps/database/dbdump.c:    strcpy(dbname, argv[1]);
./ctn_3.0.6/apps/database/dblstimages.c:    strcpy(patid, argv[1]);
./ctn_3.0.6/apps/database/dblstimages.c:    strcpy(studyuid, argv[2]);
./ctn_3.0.6/apps/database/dblstimages.c:    strcpy(seriesuid, argv[3]);
./ctn_3.0.6/apps/database/dblstimages.c:    strcpy(dbname, argv[4]);
./ctn_3.0.6/apps/database/dblstpats.c:    strcpy(dbname, argv[1]);
./ctn_3.0.6/apps/database/dblstseries.c:    strcpy(patid, argv[1]);
./ctn_3.0.6/apps/database/dblstseries.c:    strcpy(studyuid, argv[2]);
./ctn_3.0.6/apps/database/dblstseries.c:    strcpy(dbname, argv[3]);
./ctn_3.0.6/apps/database/dblststudies.c:    strcpy(patid, argv[1]);
./ctn_3.0.6/apps/database/dblststudies.c:    strcpy(dbname, argv[2]);
./ctn_3.0.6/apps/dicom_echo/dicom_echo.c:	sprintf(params.calledPresentationAddress, "%s:%s", node, *argv);
./ctn_3.0.6/apps/displays/ctndisp.c:	    strcpy(G_nodename, *argv);
./ctn_3.0.6/apps/displays/dcm_x_disp.c:	    strcpy(dicom_file, *argv);
./ctn_3.0.6/apps/displays/enq_ctndisp.c:    strcpy(e.imagefile, argv[2]);
./ctn_3.0.6/apps/displays/enq_ctndisp.c:    strcpy(e.dpnid, argv[3]);
./ctn_3.0.6/apps/fis_server/fis_server.c:	    strcpy(node, *argv);
./ctn_3.0.6/apps/fis_server/wlma_server.c:	    strcpy(node, *argv);
./ctn_3.0.6/apps/icon/create_db_entry.c:	(void) sprintf(imgfile, "%s/%s", cwd, *argv++);
./ctn_3.0.6/apps/icon/create_db_entry.c:	(void) sprintf(prefmtImgfile, "%s/%s", cwd, *argv++);
./ctn_3.0.6/apps/icon/create_db_entry.c:	(void) sprintf(imgfile, "%s", *argv++);
./ctn_3.0.6/apps/icon/create_db_entry.c:	(void) sprintf(prefmtImgfile, "%s", *argv++);
./ctn_3.0.6/apps/icon/create_print_entry.c:	(void) sprintf(imgfile, "%s/%s", cwd, *argv++);
./ctn_3.0.6/apps/icon/create_print_entry.c:	(void) sprintf(prefmtImgfile, "%s/%s", cwd, *argv++);
./ctn_3.0.6/apps/icon/create_print_entry.c:	(void) sprintf(imgfile, "%s", *argv++);
./ctn_3.0.6/apps/icon/create_print_entry.c:	(void) sprintf(prefmtImgfile, "%s", *argv++);
./ctn_3.0.6/apps/image_archive/archive_server.c:	    strcpy(node, *argv);
./ctn_3.0.6/apps/image_server/image_server.c:	    strcpy(node, *argv);
./ctn_3.0.6/apps/mwlQuery/mwlQuery.c:    sprintf(params.calledPresentationAddress, "%s:%s", node, *argv);
./ctn_3.0.6/apps/pmgr_motif/pmgr_motif.c:	    strcpy(applicationTitle, *argv);
./ctn_3.0.6/apps/print_clients/print_client.c:	    strcpy(format, *argv);
./ctn_3.0.6/apps/print_server/print_server.c:	    strcpy(node, *argv);
./ctn_3.0.6/apps/ris_gateway/ris_gateway.c:	    strcpy(node, *argv);
./ctn_3.0.6/apps/send_image/send_image.c:	    strcat(xferSyntaxBuf, UID_Translate(*argv));
./ctn_3.0.6/apps/spray_image/spray_image.c:	    strcat(xferSyntaxBuf, UID_Translate(*argv));
./ctn_3.0.6/apps/storage_commit/commit_agent.c:	    strcpy(node, *argv);
./dbview_1.0.4/dbview.c:    strcpy(dbfile, argv[optind]);
./dctc_0.85.9/src/dctc_cmd.c:	strcpy(name.sun_path,argv[1]);
./devil_1.6.8-rc2/test/VolTex/voltex.c:		strcpy(FileName, argv[2]);
./devil_1.6.8-rc2/test/VolTex/voltex.c:		strcpy(Ext, argv[3]);
./devmapper_1.02.27/dmsetup/dmsetup.c:		strcat(str, argv[i]);
./dhcp3_3.1.1/client/dhclient.c:		    strcpy(tmp->name, argv[i]);
./dhcp3_3.1.1/common/execute.c:                                strcpy(argv[0], r->data.execute.command);
./dialog_1.1-20080316/dialog.c:	sprintf(temp, "Expected a string-parameter for %.20s", argv[*num]);
./dialog_1.1-20080316/dialog.c:	sprintf(temp, "Expected a numeric-parameter for %.20s", argv[*num]);
./dialog_1.1-20080316/dialog.c:	    sprintf(temp, "Expected a filename for %.50s", argv[1]);
./dialog_1.1-20080316/dialog.c:	    sprintf(temp, "Expected --checklist, not %.20s", argv[offset]);
./dictd_1.10.11.dfsg/dictd.c:   strcpy( _dict_argvstart, buf );
./dietlibc_0.31/test/asprintf.c: asprintlen=asprintf(&path, "/proc" "/%s/stat", argv[1]);
./dietlibc_0.31/test/asprintf.c: asprintlen=asprintf(&path, "/proc" "/%d/stat", strlen(argv[1]));
./digikam_0.9.4/digikam/libs/sqlite2/func.c:    strcpy(p->z, argv[0]);
./digikam_0.9.4/digikam/libs/sqlite2/shell.c:      sprintf(data.separator,"%.*s",(int)sizeof(data.separator)-1,argv[i]);
./digikam_0.9.4/digikam/libs/sqlite2/shell.c:      sprintf(data.nullvalue,"%.*s",(int)sizeof(data.nullvalue)-1,argv[i]);
./digikam_0.9.4/digikam/libs/sqlite2/table.c:        strcpy(z, argv[i]);
./digikam_0.9.4/digikam/libs/sqlite2/vacuum.c:  sprintf(zBuf,"PRAGMA %s=%s;", p->zPragma, argv[0]);
./digikam_0.9.4/digikam/libs/sqlite3/sqlite3.c:    strcpy(z, argv[i]);
./dmucs_0.6.1/COSMIC/EXE/spmchk.c:if(argc > 1) strcpy(hostnm, argv[1]);
./dnsmasq_2.45/contrib/wrt/dhcp_release.c:  strcpy(ifr.ifr_name, argv[1]);
./dnstracer_1.9/dnstracer.c:    strcpy(argv0, argv[0]);
./dspam_3.6.8/src/agent_shared.c:          strcpy(user, argv[i]);
./dspam_3.6.8/src/agent_shared.c:          strcpy(user, argv[i]);
./dump_0.4b41/dump/main.c:			(void)strcpy(&nargv[0][2], *argv);
./dump_0.4b41/restore/main.c:			(void)strcpy(&nargv[0][2], *argv);
./dvi2ps_4.1j/run.c:	    (void)strcpy(dvidirpath, argv[argind]);
./e16_0.16.8.13/eesh/main.c:	     strcpy(command + len, argv[i]);
./e16_0.16.8.13/epp/cpplib.c:		       strcpy(dirtmp->fname, argv[++i]);
./e16_0.16.8.13/epp/cpplib.c:		       strcat(dirtmp->fname, argv[++i]);
./e16_0.16.8.13/epp/cpplib.c:		       strcat(dirtmp->fname, argv[++i]);
./e2fsprogs_1.41.3/ext2ed/main.c:		strcat(buf, argv[optind]);
./e2fsprogs_1.41.3/lib/ss/help.c:	(void) strcat(buffer, argv[1]);
./e2fsprogs_1.41.3/lib/ss/help.c:	strcat(buf, argv[1]);
./eb_4.3.2/ebrefile/ebrefile.c:        strcpy(book_path, argv[optind]);
./eb_4.3.2/ebzip/ebzip.c:        strcpy(book_path, argv[optind]);
./eblook_1.6.1/eblook.c:/*     sprintf(buff, "</sound=%d:%d>", argv[1], (2 < argc) ? argv[2] : 0); */
./eblook_1.6.1/eblook.c:    sprintf(workbuf, "<gaiji=%c%04x>", c, argv[0]);
./ebnetd_1.0.dfsg.1/ndtpd/hookset.c:	sprintf(alt_text, "#%04x", argv[0]);
./ebnetd_1.0.dfsg.1/ndtpd/hookset.c:    sprintf(tag, "<gaiji:h%04x>", argv[0]);
./ebnetd_1.0.dfsg.1/ndtpd/hookset.c:	sprintf(alt_text, "#%04x", argv[0]);
./ebnetd_1.0.dfsg.1/ndtpd/hookset.c:    sprintf(tag, "<gaiji:z%04x>", argv[0]);
./ebnetd_1.0.dfsg.1/ndtpd/hookset.c:    sprintf(tag, "<%x:%x>", argv[1], argv[2]);
./ebtables_2.0.8.2/ebtablesd.c:			strcpy(tmp.filename, argv[3]);
./ebtables_2.0.8.2/ebtablesd.c:			strcpy(replace[i].filename, argv[3]);
./ebtables_2.0.8.2/ebtablesu.c:		strcpy(pos, argv[i]);
./ebview_0.3.6/src/ebview-client.c:		strcpy(p, argv[i]);
./ebview_0.3.6/src/ebview.c:			strcat(word, g_argv[i]);
./ecasound2.2_2.4.6.1/ecatools/ecalength.c:      sprintf(cmd, "ai-add \"%s\"", argv[curarg]); 
./ecasound2.2_2.4.6.1/ecatools/ecalength.c:        sprintf(cmd, "ai-select %s", argv[curarg]); 
./ecasound2.2_2.4.6.1/ecatools/ecaplay.c:	    strcat(tmp, argv[i]);
./eggdrop_1.6.19/src/language.c:  strcpy(buf, argv[1]);
./eggdrop_1.6.19/src/mod/channels.mod/tclchan.c:      strcpy(ul->name, argv[3]);
./eggdrop_1.6.19/src/mod/filesys.mod/tclfiles.c:  malloc_strcpy(s, argv[1]);
./eggdrop_1.6.19/src/mod/filesys.mod/tclfiles.c:    malloc_strcpy(fdbe->chan, argv[3]);
./eggdrop_1.6.19/src/mod/filesys.mod/tclfiles.c:  malloc_strcpy(s, argv[1]);
./eggdrop_1.6.19/src/mod/filesys.mod/tclfiles.c:  malloc_strcpy(s, argv[1]);
./eggdrop_1.6.19/src/mod/filesys.mod/tclfiles.c:    malloc_strcpy(fdbe->filename, argv[1]);
./eggdrop_1.6.19/src/mod/filesys.mod/tclfiles.c:    malloc_strcpy(fdbe->chan, argv[3]);
./eggdrop_1.6.19/src/mod/filesys.mod/tclfiles.c:  malloc_strcpy(s, argv[1]);
./eggdrop_1.6.19/src/mod/filesys.mod/tclfiles.c:  malloc_strcpy(fn, argv[1]);
./eggdrop_1.6.19/src/mod/filesys.mod/tclfiles.c:  malloc_strcpy(s, argv[2]);
./eggdrop_1.6.19/src/mod/irc.mod/irc.c:  sprintf(x, "%d", F(argv[1], argv[2], argv[3], argv[4], argv[5], argv[6]));
./eggdrop_1.6.19/src/mod/notes.mod/notes.c:          simple_sprintf(work, "<%s@%s >%s %s", argv[2], botnetnick,
./eggdrop_1.6.19/src/mod/notes.mod/notes.c:          simple_sprintf(work, "<%s@%s %s", argv[2], botnetnick, argv[3]);
./eggdrop_1.6.19/src/mod/notes.mod/notes.c:      strcpy(work, argv[3]);
./eggdrop_1.6.19/src/mod/notes.mod/notes.c:    sprintf(s, "%d", num_notes(argv[1]));
./eggdrop_1.6.19/src/mod/transfer.mod/tcltransfer.c:      sprintf(sys, "*%s", argv[1]);
./eggdrop_1.6.19/src/mod/transfer.mod/tcltransfer.c:    strcpy(sys, argv[1]);
./eggdrop_1.6.19/src/tclmisc.c:        strcpy(logs[i].chname, argv[2]);
./eggdrop_1.6.19/src/tclmisc.c:      strcpy(logs[i].filename, argv[3]);
./eggdrop_1.6.19/src/tclmisc.c:      strcpy(logs[i].chname, argv[2]);
./eggdrop_1.6.19/src/tcluser.c:      strcpy(bi->address, argv[2]);
./eggdrop_1.6.19/src/userent.c:    strcpy(li->lastonplace, argv[4]);
./eggdrop_1.6.19/src/userent.c:    strcpy(bi->address, argv[3]);
./emboss_5.0.0/emboss/edialign.c:	strcpy( arguments[i] , argv[i] );
./emboss_5.0.0/emboss/edialign.c:	    strcat( input_line , argv[i] );
./emboss_5.0.0/emboss/edialign.c:	    strcat( input_line , argv[i] );
./emboss_5.0.0/scripts/bundlewin.c:	strcpy(basedir,argv[1]);
./epm_4.1/epm.c:      strcpy(prodname, argv[i]);
./epm_4.1/epm.c:      strcpy(listname, argv[i]);
./erlang_12.b.3-dfsg/erts/emulator/sys/vxworks/sys.c:	  strcpy(fn, argv[0]);
./erlang_12.b.3-dfsg/erts/epmd/src/epmd.c:      strcpy((sig->args.argv)[i], argv[i]);
./erlang_12.b.3-dfsg/erts/epmd/src/epmd.c:    strcpy(argv[i], (sig->args.argv)[i]);
./erlang_12.b.3-dfsg/erts/etc/common/heart.c:    strcpy(program_name, argv[0]);
./erlang_12.b.3-dfsg/erts/etc/common/heart.c:    strcpy(program_name, argv[0]);
./erlang_12.b.3-dfsg/erts/etc/ose/erl_utils/erl.exec.c:    strcpy(argv[argc], erl_argv[argc]);
./erlang_12.b.3-dfsg/erts/etc/ose/erl_utils/erl.exec.c:	    sprintf(tmpStr, "%s=%s", argv[i+1], argv[i+2]);
./erlang_12.b.3-dfsg/erts/etc/ose/erl_utils/erl_inet_cfg.c:  strcpy(buf, argv[1]);
./erlang_12.b.3-dfsg/erts/etc/win32/win_erlexec.c:		strcat(sbuf, argv[i]);
./erlang_12.b.3-dfsg/erts/etc/win32/win_erlexec.c:		strcat(buffer,argv[i]);
./erlang_12.b.3-dfsg/erts/etc/win32/win_erlexec.c:		strcat(sbuf, argv[i]);
./erlang_12.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c:	    strcpy(flags.node, argv[i+1]);
./erlang_12.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c:	    strcpy(flags.node, argv[i+1]);
./erlang_12.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c:		strcpy(flags.cookie, argv[i+1]);
./erlang_12.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c:		strcpy(flags.node, argv[i+1]);
./erlang_12.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c:		strcpy(flags.hidden, argv[i+1]);
./erlang_12.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c:		strcpy(flags.script, argv[i+1]);
./erlang_12.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c:		strcpy(flags.apply, argv[i+1]);
./erlang_12.b.3-dfsg/lib/erl_interface/src/prog/erl_start.c:    strcpy(argv[1],inet_ntoa(*hisaddr));
./erlang_12.b.3-dfsg/lib/os_mon/c_src/ferrule.c:    strcpy(pipename, argv[OWNPATH]);
./erlang_12.b.3-dfsg/lib/os_mon/c_src/mod_syslog.c:    strcpy(pipename, argv[OWNPATH]);
./erlang_12.b.3-dfsg/lib/os_mon/c_src/mod_syslog.c:    strcpy(srcname, argv[OWNPATH]);
./erlang_12.b.3-dfsg/lib/ssl/c_src/esock.c:	    sprintf(logfile, "%s/ssl_esock.%d.log", argv[i], (int)pid);
./e-uae_0.8.29-WIP4/amiga/source/transdisk.c:	    sprintf(devicebuf, "%s.device", argv[i+1]);
./euler_1.61.0/src/mainloop.c:		strcat(input_line,argv[i]);
./evilvte_0.4.3/src/sakura.c:    sprintf(default_command, "%s", argv[2]);
./evilwm_1.0.0/main.c:				strcpy(new->res_name, argv[i]);
./evolution-data-server_2.22.3/calendar/libical/src/libicalvcal/vctest.c:	    strcpy(buf,*argv);
./evolver_2.30c/src/tmain.c:                 sprintf(msg,"Illegal option: %s\n",argv[0]); outstring(msg);
./expect_5.43.0/Dbg.c:	sprintf(buf,"%.*s",buf_width,argv[0]);
./expect_5.43.0/Dbg.c:			sprintf(bufp," {%.*s}",space-3,*argv);
./expect_5.43.0/Dbg.c:			sprintf(bufp," %.*s",space-1,*argv);
./expect_5.43.0/exp_command.c:				strcpy(exp_onexit_action,*argv);
./expect_5.43.0/exp_command.c:		sprintf(argv[0],"-%s",command);
./expect-tcl8.3_5.43.0/Dbg.c:	sprintf(buf,"%.*s",buf_width,argv[0]);
./expect-tcl8.3_5.43.0/Dbg.c:			sprintf(bufp," {%.*s}",space-3,*argv);
./expect-tcl8.3_5.43.0/Dbg.c:			sprintf(bufp," %.*s",space-1,*argv);
./expect-tcl8.3_5.43.0/exp_command.c:				strcpy(exp_onexit_action,*argv);
./expect-tcl8.3_5.43.0/exp_command.c:		sprintf(argv[0],"-%s",command);
./fdclone_2.06c/doscom.c:		strcpy(buf, argv[n]);
./fdclone_2.06c/doscom.c:		strcpy(buf, argv[n]);
./fdclone_2.06c/doscom.c:	strcpy(src, argv[n]);
./fdclone_2.06c/doscom.c:		strcpy(&(src[size - 1]), argv[n]);
./fdclone_2.06c/doscom.c:		strcpy(dest, argv[n]);
./fenix_0.92a.dfsg1/fxc/src/main.c:							strcpy(langinfo,argv[i+1]) ;
./fenix_0.92a.dfsg1/fxc/src/main.c:					strcpy(langinfo,argv[i]+j+1) ;
./fftw_2.1.3/mpi/fftw_mpi_test.c:		    strcpy((*argv)[i], "");
./flac_1.2.1/src/monkeys_audio_utilities/flac_mac/main.c:		strcpy(macdir, argv[0]);
./flac_1.2.1/src/monkeys_audio_utilities/flac_mac/main.c:			strcat(options, argv[i]);
./flac_1.2.1/src/monkeys_audio_utilities/flac_mac/main.c:	sprintf(cmdline, "\"%s\" %s -o \"%s\" \"%s\"", prog, options, argv[to_arg], argv[from_arg]);
./flac_1.2.1/src/monkeys_audio_utilities/flac_mac/main.c:			strcpy(from, argv[to_arg]);
./flac_1.2.1/src/monkeys_audio_utilities/flac_mac/main.c:		strcat(from, p? p+1 : argv[from_arg]);
./flickcurl_1.3/utils/codegen.c:  strcpy(section+7, argv[1]);
./freeciv_2.1.5/dependencies/tolua/tolua.c:  strcpy(path,argv[0]);
./freeimage_3.10.0/Source/LibJPEG/wrjpgcom.c:	strcpy(comment_arg, argv[argn]+1);
./freeimage_3.10.0/Source/LibJPEG/wrjpgcom.c:	  strcat(comment_arg, argv[argn]);
./freej_0.10git20080824/lib/javascript/sh/jssh.c:        strcpy(source, JS_GetStringBytes(JS_ValueToString(cx, argv[i])));
./freetds_0.82/src/apps/datacopy.c:		strcpy(arg, argv[i]);
./freetds_0.82/src/apps/freebcp.c:	strcpy(pdata->dbdirection, argv[2]);
./freetds_0.82/src/apps/freebcp.c:	strcpy(pdata->hostfilename, argv[3]);
./freetds_0.82/src/ctlib/unittests/ct_options.c:		strcpy(common_pwd.SERVER, argv[1]);
./freetds_0.82/src/ctlib/unittests/ct_options.c:		strcpy(common_pwd.DATABASE, argv[2]);
./freetds_0.82/src/ctlib/unittests/ct_options.c:		strcpy(common_pwd.USER, argv[3]);
./freetds_0.82/src/ctlib/unittests/ct_options.c:		strcpy(common_pwd.PASSWORD, argv[4]);
./freetds_0.82/src/dblib/unittests/t0001.c:		strcpy(SERVER, argv[0]);
./fsl_4.0.4/src/miscvis/create_lut.c:  sprintf(filename,"%s%d.lut",argv[1],l+1);  lut[l]=fopen(filename,"wb");
./fsl_4.0.4/src/miscvis/create_lut.c:  sprintf(filename,"%s%d.map",argv[1],l+1);  map[l]=fopen(filename,"wb");
./fsl_4.0.4/src/miscvis/create_lut.c:  sprintf(filename,"%s%dt.lut",argv[1],l+1); lutt[l]=fopen(filename,"wb");
./fsl_4.0.4/src/miscvis/create_lut.c:  sprintf(filename,"%s%dt.map",argv[1],l+1); mapt[l]=fopen(filename,"wb");
./fsl_4.0.4/src/misc_c/tmpnam.c:    sprintf(theprefix,"%s_XXXXXX",argv[1]);
./funnelweb_3.2/source/machin.c: strcpy(&result[0],argv[0]);
./funnelweb_3.2/source/machin.c:    strcat(&result[0],argv[i]);
./fuseiso_20070708/src/fuseiso.c:                strcpy(str, argv[i + optind + 1]);
./fuzz_0.6/fuzz.c:    strcpy(progname,argv[optind]);
./fv_3.0/fitsTcl/cfitsio/compress_fits.c:    strcpy(infile, argv[1] );   /* name of file to compress */
./fv_3.0/fitsTcl/cfitsio/compress_fits.c:    strcpy(outfile, argv[2] );   /* name of output file */
./fv_3.0/fitsTcl/cfitsio/fitscopy.c:    strcpy(infile,  argv[1] );  
./fv_3.0/fitsTcl/cfitsio/fitscopy.c:    strcpy(outfile, argv[2] );  
./fv_3.0/fitsTcl/cfitsio/listhead.c:        strcpy(filename, argv[1] );   /* name of file to list */
./fv_3.0/fitsTcl/cfitsio/uncompress_fits.c:    strcpy(infile, argv[1] );   /* name of file to uncompress */
./fv_3.0/fitsTcl/cfitsio/uncompress_fits.c:    strcpy(outfile, argv[2] );   /* name of output file */
./fv_3.0/fitsTcl/cfitsio/windumpexts.c:		strcpy(&cmdline[pos], argv[i]);
./fv_3.0/fitsTcl/fitsCmds.c:            strcpy( wtcol, Tcl_GetStringFromObj( argv[argNum], NULL ) );
./fv_3.0/pow/PowColormap.c:  strcpy(toplevel,argv[1]);
./fv_3.0/pow/PowColormap.c:    strcpy(options,argv[4]);
./fv_3.0/pow/PowColormap.c:  strcpy(window,argv[1]);
./fv_3.0/pow/PowColormap.c:     sprintf(scrtch,"cmapLUT_%s,powDef",argv[1]);
./fv_3.0/pow/PowColormap.c:	sprintf(scrtch,"Unable to locate LUT for %s\n",argv[1]);
./fv_3.0/pow/PowCommands.c:  strcpy(imageName,argv[1]);
./fv_3.0/pow/PowCommands.c:  strcpy(graphName,argv[2]);
./fv_3.0/pow/PowCommands.c:    strcpy(whichPowCanvas,argv[14]);
./fv_3.0/pow/readpha.c:  strcpy(filename,argv[1]);
./fv_3.0/pow/Visu_tkImgPict.c:           sprintf(scrtch,"cmapLUT_%s,powDef",argv[2]);
./fv_3.0/pow/Visu_tkImgPict.c:              sprintf(scrtch,"Unable to locate LUT for %s\n",argv[2]);
./fv_3.0/tcl8.3.2/generic/tclCkalloc.c:	strcpy(curTagPtr->string, argv[2]);
./fv_3.0/tcl8.3.2/generic/tclCkalloc.c:    strcpy(tclMemDumpFileName, argv[1]);
./fv_3.0/tcl8.3.2/generic/tclPkg.c:		strcpy(availPtr->version, argv3);
./fv_3.0/tcl8.3.2/generic/tclPkg.c:	    strcpy(availPtr->script, argv4);
./fv_3.0/tcl8.3.2/generic/tclPkg.c:		    strcpy(iPtr->packageUnknown, argv2);
./fv_3.0/tcl8.3.2/generic/tclTest.c:	strcpy(asyncPtr->command, argv[2]);
./fv_3.0/tcl8.3.2/generic/tclTest.c:    strcpy(dPtr->deleteCmd, argv[3]);
./fv_3.0/tcl8.3.2/generic/tclTest.c:		strcpy(stringVar, argv[5]);
./fv_3.0/tcl8.3.2/generic/tclTest.c:		strcpy(stringVar, argv[5]);
./fv_3.0/tcl8.3.2/generic/tclTest.c:    strcpy(buf, argv[2]);
./fv_3.0/tcl8.3.2/mac/tclMacBOAMain.c:    strcpy(dumpFile, argv[1]);
./fv_3.0/tcl8.3.2/unix/tclUnixPipe.c:	sprintf(errSpace, "%dcouldn't execute \"%.150s\": ", errno, argv[0]);
./fv_3.0/tcl8.3.2/unix/tclUnixTest.c:	strcpy(tclDefaultEncodingDir, argv[1]);
./fv_3.0/tk8.3.2/generic/tkClipboard.c:	sprintf(buf, "bad option \"%.50s\": must be clear or append", argv[1]);
./fv_3.0/tk8.3.2/generic/tkTest.c:	    strcpy((char *) ckalloc(strlen(argv[3]) + 1), argv[3]);
./fv_3.0/tk8.3.2/generic/tkTest.c:		strcpy((char *) ckalloc(strlen(argv[4]) + 1), argv[4]);
./fv_3.0/tk8.3.2/mac/tkMacWm.c:	strcpy(wmPtr->clientMachine, argv[3]);
./fv_3.0/tk8.3.2/mac/tkMacWm.c:	    strcpy(wmPtr->leaderName, argv[3]);
./fv_3.0/tk8.3.2/mac/tkMacWm.c:	    strcpy(protPtr->command, argv[4]);
./fv_3.0/tk8.3.2/mac/tkMacWm.c:	    strcpy(wmPtr->masterWindowName, argv[3]);
./fv_3.0/tk8.3.2/unix/tkUnixWm.c:	strcpy(wmPtr->clientMachine, argv[3]);
./fv_3.0/tk8.3.2/unix/tkUnixWm.c:	    strcpy(wmPtr->leaderName, argv[3]);
./fv_3.0/tk8.3.2/unix/tkUnixWm.c:	    strcpy(wmPtr->iconName, argv[3]);
./fv_3.0/tk8.3.2/unix/tkUnixWm.c:	    strcpy(protPtr->command, argv[4]);
./fv_3.0/tk8.3.2/unix/tkUnixWm.c:	    strcpy(wmPtr->title, argv[3]);
./fv_3.0/tk8.3.2/unix/tkUnixWm.c:	    strcpy(wmPtr->masterWindowName, argv[3]);
./fv_3.0/tk8.3.2/win/tkWinWm.c:	strcpy(wmPtr->clientMachine, argv[3]);
./fv_3.0/tk8.3.2/win/tkWinWm.c:	    strcpy(wmPtr->leaderName, argv[3]);
./fv_3.0/tk8.3.2/win/tkWinWm.c:	    strcpy(protPtr->command, argv[4]);
./fvwm1_1.24r-53/fvwm/fvwm.c:		strcat(m4_options, argv[i]);
./fvwm1_1.24r-53/fvwm/fvwm.c:		strcpy(m4_startquote, argv[i]);
./fvwm1_1.24r-53/fvwm/fvwm.c:		strcpy(m4_endquote, argv[i]);
./fvwm1_1.24r-53/fvwm/fvwm.c:		strcpy(m4_prog, argv[i]);
./fvwm1_1.24r-53/fvwm/fvwm.c:		sprintf(message,"%s -d %s",argv[0],XDisplayString(dpy));
./gadmin-proftpd_0.3.0/src/gprostats.c:	    strcpy(conf, argv[x+1]);
./gadmin-proftpd_0.3.0/src/gprostats.c:	    strcpy(xferlog, argv[x+1]);
./gadmin-proftpd_0.3.0/src/gprostats.c:	    strcpy(welcome_name, argv[x+1]);
./gadmin-proftpd_0.3.0/src/gprostats.c:	    strcpy(html, argv[x+1]);
./gcal_3.01.1/src/file-io.c:           strcpy(my_argv[(*my_argc)++], s1);
./gcal_3.01.1/src/file-io.c:                  strcpy(s4, argv[i]+2);
./gcal_3.01.1/src/gcal.c:     strcpy(s3, *argv);
./gcal_3.01.1/src/gcal.c:                        strcpy(my_argv[my_argc++], s1);
./gcal_3.01.1/src/gcal.c:         strcpy(rsp_filename, *argv+1);
./gcal_3.01.1/src/gcal.c:            strcpy(my_argv[my_argc++], *argv);
./gcal_3.01.1/src/gcal.c:                  strcpy(pg_argv[pg_argc++], ext_pager);
./gcal_3.01.1/src/gcal.c:                     strcpy(pg_argv[pg_argc++], ext_pager + j);
./gcal_3.01.1/src/gcal.c:                           strcpy(argv[n], *ptr_argv);
./gcal_3.01.1/src/gcal.c:                           strcat(argv[n], *ptr2_argv);
./gcal_3.01.1/src/gcal.c:         strcpy(argv[n], *ptr_argv);
./gcal_3.01.1/src/gcal.c:                   strcpy(rc_period_argv, *argv);
./gcal_3.01.1/src/gcal2txt.c:     strcpy(s1, *argv);
./gcal_3.01.1/src/gcal2txt.c:      sprintf(s1, "%s: `%s' ", prgr_name, argv[1]);
./gcal_3.01.1/src/tcal.c:     strcpy(s1, *argv);
./gcal_3.01.1/src/tcal.c:   strcpy(my_argv[my_argc++], gcal_prgr);
./gcal_3.01.1/src/tcal.c:   strcpy(my_argv[my_argc++], s1);
./gcal_3.01.1/src/tcal.c:      strcpy(my_argv[my_argc++], *argv);
./gcal_3.01.1/src/txt2gcal.c:     strcpy(s1, *argv);
./gcal_3.01.1/src/txt2gcal.c:      sprintf(s1, "%s: `%s' ", prgr_name, argv[1]);
./gcpegg_5.1/basket.c:      strcpy(htmlFile, myargv[2]);
./gcpegg_5.1/basket.c:	strcat(tp, myargv[p]);
./gcpegg_5.1/egg.c:	strcat(tp, myargv[p]);
./gdb_6.8/sim/erc32/interf.c:		    strcpy(uart_dev1, argv[++stat]);
./gdb_6.8/sim/erc32/interf.c:		    strcpy(uart_dev2, argv[++stat]);
./gdb_6.8/sim/erc32/sis.c:		    strcpy(uart_dev1, argv[++stat]);
./gdb_6.8/sim/erc32/sis.c:		    strcpy(uart_dev2, argv[++stat]);
./gdb_6.8/sim/ppc/main.c:  strcat(arg_, argv[0]);
./geda-utils_1.4.0/src/grenum.c:		strcpy(&infilename[0],argv[optind]);	/*Copy the filename to the buffer*/
./geda-utils_1.4.0/src/olib.c:  strcpy(fnlib,argv[optind]);
./geda-utils_1.4.0/src/olib.c:  strcpy(sym_prefix,argv[optind+1]);
./geda-utils_1.4.0/src/smash_megafile.c:  strcpy(name,argv[1]);
./geda-utils_1.4.0/src/smash_megafile.c:      strcpy(output_name, argv[1]);
./gff2aplot_2.0/src/ali2gff/ali2gff.c:	strcpy(prgCall,argv[0]);
./gff2aplot_2.0/src/ali2gff/ali2gff.c:	strcpy(infile,argv[1]);
./glassfish_2+b58g/appserv-native/src/cpp/launcher/NativeInvokerMain.c:	        strcat(startservScript, argv[ii]);
./glassfish_2+b58g/appserv-native/src/cpp/launcher/NativeInvokerService.c:        strcpy(g_ServiceName, argv[0]);  
./glut_3.7/progs/demos/bounce/bounce.c:	    strcat(ofile, argv[1]);
./glut_3.7/progs/demos/bounce/bounce.c:	    strcpy(ofile, argv[1]);
./gmsh_2.2.3/utils/converters/autocad/dxf2msh.c:  strcpy(inname, argv[1]); /* make copy we can mess with */
./gmsh_2.2.3/utils/converters/autocad/dxf2pos.c:  strcpy(inname, argv[1]); /* make copy we can mess with */
./gnome-libs_1.4.2/support/findme.c:	sprintf(buf, "%s/%s", start, argv0);
./gnome-pilot_2.0.15/utils/make-password.c:   strcpy(addr.pi_device,argv[1]);
./gnuboy_1.0.3/main.c:			sprintf(cmd, "bind %s \"%s\"", argv[i+1], argv[i+2]);
./gnuboy_1.0.3/main.c:			sprintf(cmd, "source %s", argv[++i]);
./gnujump_1.0.0/src/main.c:            strcpy(*replay, argv[i]);
./gnupg2_2.0.9/g10/gpg.c:      strcat(str,argv[i]);
./gnuplot_4.2.2/src/os2/gnupmdrv.c:        strcpy( szIPCName, argv[1] ) ;
./gnuplot_4.2.2/src/os2/gnupmdrv.c:    strcpy( szIniFile, argv[0] ) ;
./gnuplot_4.2.2/src/plot.c:    strcpy(HelpFile, argv[0]);
./gnuplot_4.2.2/src/plot.c:	strcpy(HelpFile, argv[0]);
./gnuplot_4.2.2/src/win/geticon.c:                strcpy(iconname,argv[2]);
./gnuplot-mode_0.6.0/Win9x/pgnuplot.c:      strcat(cmdline, *argv);
./gnushogi_1.3.2/gnushogi/main.c:                strcpy(listfile, argv[0]);
./gnushogi_1.3.2/gnushogi/main.c:                strcpy(savefile, argv[0]);
./gnustep-base_1.16.1/NSCharacterSets/dataToHeader.c:      strcpy(name, argv[i]);
./goattracker_2.67/src/goattrk2.c:      strcpy(songfilename, argv[c]);
./goattracker_2.67/src/goattrk2.c:          strcpy(startpath, argv[c]);
./goattracker_2.67/src/goattrk2.c:          strcpy(songfilename, &argv[c][d+1]);
./gpe-timesheet_0.32/sql.c:      query = strcat(query,argv[0]);
./gpivtools_0.5.2/src/dac/rec_image.c:                strcpy(fname, argv[argc - 1]);
./gpivtools_0.5.2/src/evaluate/rr.c:        strcpy(fname, argv[argc - 1]);
./gpivtools_0.5.2/src/image/imgproc.c:        strcpy(fname, argv[argc - 1]);
./gpivtools_0.5.2/src/image/t-avg-img.c:		strcpy(fname, *++argv);
./gpivtools_0.5.2/src/image/t-avg-img.c:		strcpy(fname, *++argv);
./gpivtools_0.5.2/src/misc/combing.c:        strcpy(fname, argv[argc - 1]);
./gpivtools_0.5.2/src/misc/piv2gnuplt.c:		    strcpy(annot_unit, *++argv);
./gpivtools_0.5.2/src/misc/piv2gnuplt.c:     strcpy(fname, argv[0]); 
./gpivtools_0.5.2/src/misc/piv2grid.c:     strcpy(fname, argv[0]); 
./gpivtools_0.5.2/src/misc/piv2hdf.c:     strcpy(fname, argv[0]); 
./gpivtools_0.5.2/src/misc/suta.c:    strcpy(fname_mean, argv[0]);
./gpivtools_0.5.2/src/misc/suta.c:    strcpy(fname_in, argv[1]);
./gpivtools_0.5.2/src/misc/t-corr.c:    strcpy(fname, argv[0]);
./gpivtools_0.5.2/src/post/manipiv.c:        strcpy(fname, argv[argc - 1]);
./gpivtools_0.5.2/src/post/s-avg.c:        strcpy(fname, argv[argc - 1]);
./gpivtools_0.5.2/src/post/vorstra.c:        strcpy(fname, argv[argc - 1]);
./gpivtools_0.5.2/src/validate/errvec.c:        strcpy(fname, argv[argc - 1]);
./gplcver_2.12a/vcddiff.dir/src/vcddiff.c:   strcpy(file_nam1, argv[argc-2]);
./gplcver_2.12a/vcddiff.dir/src/vcddiff.c:   strcpy(file_nam2, argv[argc-1]);
./gprolog_1.3.0/src/Ma2Asm/extract_asm.c:	  sprintf(buff1 + strlen(buff1), " -e 's!^.*%s.*$!IGN!'", argv[++i]);
./gprolog_1.3.0/src/Ma2Asm/extract_asm.c:	  sprintf(buff1 + strlen(buff1), " -e 's!^.*%s.*$!END!'", argv[++i]);
./gprolog_1.3.0/src/TopComp/top_comp.c:  sprintf(warn_str + strlen(warn_str), "%s ", argv[i])
./gprolog_1.3.0/src/TopComp/top_comp.c:#define Add_Option(i, opt)         sprintf(opt + strlen(opt), "%s ", argv[i])
./gprolog_1.3.0/src/Win32/create_bat.c:  sprintf(buff, "%s\\gprologvars.bat", argv[1]);
./gprolog_1.3.0/src/Win32/create_bat.c:      sprintf(buff, "PATH=%%PATH%%;\"%s\\bin\"", argv[2]);
./gprolog_1.3.0/src/Win32/create_bat.c:  sprintf(buff, "%s\\autoexec.bat", argv[1]);
./grace6_5.99.1+dev4/src/main.c:                    strcpy(rt->print_file, argv[i]);
./gramophone2_0.8.13a/GRAMophone.c:		strcpy(namefile, argv[2]);
./gramophone2_0.8.13a/GRAMophone.c:		strcpy(namefile, argv[1]);		  
./graphicsmagick_1.1.11/magick/command.c:            (void) strcpy(argv[i]+1,"sans");
./graphicsmagick_1.1.11/magick/command.c:            (void) strcpy(argv[i]+1,"sans");
./graphicsmagick_1.1.11/magick/command.c:            (void) strcpy(argv[i]+1,"sans");
./graphicsmagick_1.1.11/magick/command.c:            (void) strcpy(argv[i]+1,"sans");
./graphicsmagick_1.1.11/magick/command.c:            (void) strcpy(argv[i]+1,"sans");
./grass_6.2.3/display/d.barscale/main.c:		sprintf(cmdbuf, "%s at=%f,%f", argv[0],east, north);
./grass_6.2.3/lib/fonts/for_grass/splitfont.c:		sprintf(buf2,"%s/%s", argv[2], buf) ;
./grass_6.2.3/raster/r.mapcalc/main.c:		strcat(buf, argv[i]);
./grass_6.2.3/raster/r.sunmask/main.c:    sprintf(hist.edhist[0], "%s", *argv); 
./grass_6.2.3/visualization/nviz/src/cutplane_obj.c:	sprintf(interp->result, "Usage: %s draw [surf1 surf2]", argv[0]);
./grass_6.2.3/visualization/nviz/src/cutplane_obj.c:	sprintf(interp->result, "Usage: %s on", argv[0]);
./grass_6.2.3/visualization/nviz/src/cutplane_obj.c:	sprintf(interp->result, "Usage: %s off", argv[0]);
./grass_6.2.3/visualization/nviz/src/cutplane_obj.c:	sprintf(interp->result, "Usage: %s state", argv[0]);
./grass_6.2.3/visualization/nviz/src/cutplane_obj.c:	sprintf(interp->result, "Usage: %s set_rot dx dy dz", argv[0]);
./grass_6.2.3/visualization/nviz/src/cutplane_obj.c:	sprintf(interp->result, "Usage: %s set_trans dx dy dz", argv[0]);
./grass_6.2.3/visualization/nviz/src/cutplane_obj.c:	sprintf(interp->result, "Usage: %s get_rot", argv[0]);
./grass_6.2.3/visualization/nviz/src/cutplane_obj.c:	sprintf(interp->result, "Usage: %s get_trans", argv[0]);
./grass_6.2.3/visualization/nviz/src/do_zoom.c:    strcpy(pref, argv[1]);
./grass_6.2.3/visualization/nviz/src/draw.c:    strcpy(cancel_script, argv[1]);
./grass_6.2.3/visualization/nviz/src/draw.c:    sprintf(name, "%s", argv[1]);
./grass_6.2.3/visualization/nviz/src/draw.c:    sprintf(font, "%s", argv[2]);
./grass_6.2.3/visualization/nviz/src/draw.c:    sprintf(list_name, "%s", argv[1]);
./grass_6.2.3/visualization/nviz/src/glwrappers.c:	    sprintf(buf, "Unable to convert %s to color\n", argv[1]);
./grass_6.2.3/visualization/nviz/src/label.c:    sprintf(text, "%s", argv[1]);
./grass_6.2.3/visualization/nviz/src/label.c:    sprintf(font, "%s", argv[2]);
./grass_6.2.3/visualization/nviz/src/map_obj.c:    strcpy(data->logical_name, argv[2]);
./grass_6.2.3/visualization/nviz/src/map_obj.c:    sprintf(temp_space, "%s*%ld", argv[1], tp);
./grass_6.2.3/visualization/nviz/src/nvizMain.c:			sprintf(argv[1], "--");
./grass_6.2.3/visualization/nviz/src/nviz_init.c:	    sprintf(tmp2, "%s %s %s", cmd, argv0, tmp);
./grass_6.2.3/visualization/nviz/src/nviz_init.c:	    sprintf(tmp2, "%s %s", argv0, tmp);
./gretl_1.7.5/lib/src/gretl_panel.c:	strcpy(targinfo->varname[targv], "uhat");
./gretl_1.7.5/lib/src/gretl_panel.c:	strcpy(VARLABEL(targinfo, targv), _("residual"));
./gretl_1.7.5/lib/src/gretl_panel.c:	strcpy(targinfo->varname[targv], srcinfo->varname[srcv]);
./gretl_1.7.5/lib/src/gretl_panel.c:	strcpy(VARLABEL(targinfo, targv), VARLABEL(srcinfo, srcv));
./gretl_1.7.5/plugin/tramo-x12a.c:    strcpy(targinfo->varname[targv], srcinfo->varname[srcv]);
./gretl_1.7.5/plugin/tramo-x12a.c:    strcpy(VARLABEL(targinfo, targv), VARLABEL(srcinfo, srcv));
./gretl_1.7.5/share/bcih/mkbin.c:	sprintf(datpath, "%s/%s", argv[1], datfile);
./gretl_1.7.5/tests/nistcheck.c:	strcpy(datadir, argv[1]);
./gretl_1.7.5/tests/nistcheck.c:	strcpy(datadir, argv[2]);
./gri_2.12.17/src/popt/findme.c:	sprintf(buf, "%s/%s", start, argv0);
./gri_2.12.17/src/popt/popt.c:	sprintf(argv[pos], "%s/%s", con->execPath, script);
./gromacs_3.3.3/src/gmxlib/statutil.c:    strcat(cmdline,argv[i]);
./gromacs_3.3.3/src/tools/gmx_wham.c:      sprintf(Buffer,"/bin/gunzip -c < %s",argv[i]);
./gromacs_3.3.3/src/tools/gmx_wham.c:      sprintf(Buffer,"%s/gunzip -c < %s",Path,argv[i]);
./gtkwave_3.1.10/src/helpers/lxt2miner.c:                        strcpy(lxname, argv[optind++]);
./gtkwave_3.1.10/src/helpers/lxt2vcd.c:                        strcpy(lxname, argv[optind++]);
./gtkwave_3.1.10/src/helpers/tla2vcd.c:    strcpy( dumpfname, argv[optind] );
./gtkwave_3.1.10/src/helpers/vcd2lxt2.c:                        strcpy(vname, argv[optind++]);
./gtkwave_3.1.10/src/helpers/vcd2lxt2.c:                        strcpy(lxname, argv[optind++]);
./gtkwave_3.1.10/src/helpers/vcd2vzt.c:                        strcpy(vname, argv[optind++]);
./gtkwave_3.1.10/src/helpers/vcd2vzt.c:                        strcpy(lxname, argv[optind++]);
./gtkwave_3.1.10/src/helpers/vzt2vcd.c:                        strcpy(lxname, argv[optind++]);
./gtkwave_3.1.10/src/helpers/vztminer.c:                        strcpy(lxname, argv[optind++]);
./gtkwave_3.1.10/src/main.c:strcpy(GLOBALS->whoami, argv[0]);
./gtkwave_3.1.10/src/main.c:			strcpy(GLOBALS->loaded_file_name, argv[optind++]);
./gtkwave_3.1.10/src/main.c:			strcpy(wname, argv[optind++]);
./gtkwave_3.1.10/src/main.c:			strcpy(override_rc, argv[optind++]);
./gtypist_2.7/gtypist.c:    strcpy( script_file, argv[optind] );
./guava_3.6/src/leon/src/cent.c:         strcpy( prefix, argv[i]+3);
./guava_3.6/src/leon/src/cent.c:         strcpy( suffix, argv[i]+3);
./guava_3.6/src/leon/src/cent.c:            strcpy( options.genNamePrefix, argv[i]+4);
./guava_3.6/src/leon/src/cent.c:            strcpy( outputObjectName, argv[i]+3);
./guava_3.6/src/leon/src/cent.c:         strcpy( knownSubgroupSpecifier, argv[i]+3);
./guava_3.6/src/leon/src/cent.c:         strcpy( knownSubgroup_L_Specifier, argv[i]+4);
./guava_3.6/src/leon/src/cent.c:         strcpy( knownSubgroup_R_Specifier, argv[i]+4);
./guava_3.6/src/leon/src/cjrndper.c:         strcpy( permGroupSpecifier, argv[i]+3);
./guava_3.6/src/leon/src/cjrndper.c:         strcpy( outputObjectName, argv[i]+3);
./guava_3.6/src/leon/src/cjrndper.c:            strcpy( options.genNamePrefix, argv[i]+4);
./guava_3.6/src/leon/src/cjrndper.c:         strcpy( prefix, argv[i]+3);
./guava_3.6/src/leon/src/cjrndper.c:         strcpy( suffix, argv[i]+3);
./guava_3.6/src/leon/src/commut.c:         strcpy( prefix, argv[i]+3);
./guava_3.6/src/leon/src/commut.c:         strcpy( suffix, argv[i]+3);
./guava_3.6/src/leon/src/commut.c:            strcpy( commutatorName, argv[i]+3);
./guava_3.6/src/leon/src/compgrp.c:         strcpy( prefix, argv[i]+3);
./guava_3.6/src/leon/src/compgrp.c:         strcpy( suffix, argv[i]+3);
./guava_3.6/src/leon/src/desauto.c:         strcpy( prefix, argv[i]+3);
./guava_3.6/src/leon/src/desauto.c:         strcpy( suffix, argv[i]+3);
./guava_3.6/src/leon/src/desauto.c:            strcpy( options.genNamePrefix, argv[i]+4);
./guava_3.6/src/leon/src/desauto.c:            strcpy( outputObjectName, argv[i]+3);
./guava_3.6/src/leon/src/desauto.c:         strcpy( knownSubgroupSpecifier, argv[i]+3);
./guava_3.6/src/leon/src/desauto.c:         strcpy( knownSubgroup_L_Specifier, argv[i]+4);
./guava_3.6/src/leon/src/desauto.c:         strcpy( knownSubgroup_R_Specifier, argv[i]+4);
./guava_3.6/src/leon/src/fndelt.c:         strcpy( outputObjectName, argv[i]+3);
./guava_3.6/src/leon/src/fndelt.c:         strcpy( prefix, argv[i]+3);
./guava_3.6/src/leon/src/fndelt.c:         strcpy( suffix, argv[i]+3);
./guava_3.6/src/leon/src/fndelt.c:         strcpy( permOutputName, argv[i]+4);
./guava_3.6/src/leon/src/fndelt.c:         strcpy( groupOutputName, argv[i]+4);
./guava_3.6/src/leon/src/generate.c:         strcpy( genGroupObjectName, argv[i]+3);
./guava_3.6/src/leon/src/generate.c:         strcpy( prefix, argv[i]+3);
./guava_3.6/src/leon/src/generate.c:         strcpy( suffix, argv[i]+3);
./guava_3.6/src/leon/src/inter.c:         strcpy( prefix, argv[i]+3);
./guava_3.6/src/leon/src/inter.c:         strcpy( suffix, argv[i]+3);
./guava_3.6/src/leon/src/inter.c:            strcpy( options.genNamePrefix, argv[i]+4);
./guava_3.6/src/leon/src/inter.c:            strcpy( outputObjectName, argv[i]+3);
./guava_3.6/src/leon/src/inter.c:         strcpy( knownSubgroupFileName, argv[i]+3);
./guava_3.6/src/leon/src/orblist.c:            strcpy( options.genNamePrefix, argv[i]+4);
./guava_3.6/src/leon/src/orblist.c:         strcpy( prefix, argv[i]+3);
./guava_3.6/src/leon/src/randobj.c:            strcpy( outputObjectName, argv[i]+3);
./guava_3.6/src/leon/src/setstab.c:         strcpy( prefix, argv[i]+3);
./guava_3.6/src/leon/src/setstab.c:         strcpy( suffix, argv[i]+3);
./guava_3.6/src/leon/src/setstab.c:            strcpy( options.genNamePrefix, argv[i]+4);
./guava_3.6/src/leon/src/setstab.c:            strcpy( outputObjectName, argv[i]+3);
./guava_3.6/src/leon/src/setstab.c:         strcpy( knownSubgroupSpecifier, argv[i]+3);
./guava_3.6/src/leon/src/setstab.c:         strcpy( knownSubgroup_L_Specifier, argv[i]+4);
./guava_3.6/src/leon/src/setstab.c:         strcpy( knownSubgroup_R_Specifier, argv[i]+4);
./guava_3.6/src/leon/src/wtdist.c:         strcpy( prefix, argv[i]+3);
./guava_3.6/src/leon/src/wtdist.c:         strcpy( suffix, argv[i]+3);
./guava_3.6/src/leon/src/wtdist.c:            strcpy( matrixObjectName, argv[i]+3);
./gv_3.6.5/src/Ghostview.c:	sprintf(buf, "Exec of %s failed", argv[0]);
./gv_3.6.5/src/options.c:  strcpy(*argvP,value);
./gv_3.6.5/src/process.c:         sprintf(tmp, "Exec of %s failed", argv[0]);
./hanzim_1.3/hanzim.c:	strcpy(dbase_dir,argv[i+1]);
./hat_2.05+rerolled/src/hattools/hat-anim.c:    strcpy(filename, argv[1]);
./hat_2.05+rerolled/src/hattools/hat-check.c:  strcpy(filename, argv[i]);
./hatari_1.0.1/src/options.c:				strcpy(bootdisk, argv[i]);
./hdf5_1.6.6/hl/tools/gif2h5/hdf2gif.c:            strcpy(image_name , argv[arg_index]);
./hdf5_1.6.6/tools/h5import/h5import.c:	        (void) HDstrcpy(opt.infiles[opt.fcount].datafile, argv[i]);
./hdf5_1.6.6/tools/h5import/h5import.c:        (void) HDstrcpy(opt.infiles[opt.fcount-1].configfile, argv[i]);
./hdf5_1.6.6/tools/h5import/h5import.c:        (void) HDstrcpy(opt.outfile, argv[i]);
./hercules_3.05/conspawn.c:                strcat(p,argv[i]);
./hercules_3.05/conspawn.c:        strcat(p,argv[i]);
./hercules_3.05/ctc_ctci.c:        strcpy( pCTCBLK->szGuestIPAddr, *argv );
./hercules_3.05/ctc_ctci.c:        strcpy( pCTCBLK->szDriveIPAddr, *argv );
./hercules_3.05/ctc_ctci.c:        strcpy( pCTCBLK->szTUNCharName, *argv );
./hercules_3.05/ctc_ctci.c:        strcpy( pCTCBLK->szMTU, *argv );
./hercules_3.05/ctc_ctci.c:        strcpy( pCTCBLK->szGuestIPAddr, *argv );
./hercules_3.05/ctc_ctci.c:        strcpy( pCTCBLK->szDriveIPAddr, *argv );
./hercules_3.05/ctc_ctci.c:        strcpy( pCTCBLK->szNetMask, *argv );
./hercules_3.05/ctc_ctci.c:                strcpy( pCTCBLK->szGuestIPAddr, *argv );
./hercules_3.05/ctc_ctci.c:                strcpy( pCTCBLK->szTUNCharName, *argv );
./hercules_3.05/ctc_lcs.c:            strcpy( pPort->szMACAddress, argv[0] );
./hercules_3.05/hetupd.c:            sprintf( toname, "%s.%010d", argv[ optind ], rand() );
./hercules_3.05/tapedev.c:    strcpy(dev->al_argv[dev->al_argc],par);
./hercules_3.05/tapedev.c:        strcpy(tae.argv[tae.argc],p);
./hercules_3.05/tapedev.c:        strcpy(pars[pcount],dev->al_argv[i]);
./hercules_3.05/tapedev.c:        strcpy(pars[pcount],dev->als[alix].argv[i]);
./hexer_0.1.4c/calc.c:      for (i = 1; i < argc; ++i) strcat(buf, argv[i]);
./hfsprogs_332.14/dump.tproj/main.c:			(void)strcpy(&nargv[0][2], *argv);
./hfsprogs_332.14/restore.tproj/main.c:			(void)strcpy(&nargv[0][2], *argv);
./hfsprogs_332.14/ufs.tproj/ufsutil.c:    sprintf(dev, "/dev/r%s", argv[2]);
./hk-classes_0.8.3/hk_sqlite3classes/sqlite/func.c:  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));
./hk-classes_0.8.3/hk_sqlite3classes/sqlite/func.c:  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));
./hk-classes_0.8.3/hk_sqlite3classes/sqlite/shell.c:      sprintf(data.separator,"%.*s",(int)sizeof(data.separator)-1,argv[i]);
./hk-classes_0.8.3/hk_sqlite3classes/sqlite/shell.c:      sprintf(data.nullvalue,"%.*s",(int)sizeof(data.nullvalue)-1,argv[i]);
./hk-classes_0.8.3/hk_sqlite3classes/sqlite/table.c:        strcpy(z, argv[i]);
./hk-classes_0.8.3/hk_sqliteclasses/sqlite/func.c:    strcpy(p->z, argv[0]);
./hk-classes_0.8.3/hk_sqliteclasses/sqlite/shell.c:      sprintf(data.separator,"%.*s",(int)sizeof(data.separator)-1,argv[i]);
./hk-classes_0.8.3/hk_sqliteclasses/sqlite/shell.c:      sprintf(data.nullvalue,"%.*s",(int)sizeof(data.nullvalue)-1,argv[i]);
./hk-classes_0.8.3/hk_sqliteclasses/sqlite/table.c:        strcpy(z, argv[i]);
./hmmer_2.3.2/src/plan7.c:      strcat(hmm->comlog, argv[i]);
./hoz_1.65/getopt.c:        sprintf(var, "_%d_GNU_nonoption_argv_flags_", getpid());
./httrack_3.42.3/src/htscoremain.c:            sprintf(s,"Missing quote in %s",argv[na]);
./httrack_3.42.3/src/htscoremain.c:            sprintf(s,"%s not available in this version",argv[i]);
./httrack_3.42.3/src/htscoremain.c:            sprintf(s,"%s not recognized",argv[i]);
./httrack_3.42.3/src/htscoremain.c:          sprintf(s,"Missing quote in %s",argv[na]);
./httrack_3.42.3/src/htscoremain.c:                    sprintf(tmp, "option %%W : unable to plug the module %s (returncode != 1)", argv[na]);
./httrack_3.42.3/src/htscoremain.c:                    sprintf(tmp, "option %%W : unable to load the module %s: %s (check the library path ?)", argv[na], strerror(last_errno));
./hylafax_4.4.4/util/faxmodem.c:            strcpy(devname, argv[optind] + pdevlen);
./hylafax_4.4.4/util/faxmodem.c:            strcpy(devname, argv[optind]);
./hylafax_4.4.4/util/faxmsg.c:                strcpy(fifoname, argv[optind]);
./hylafax_4.4.4/util/faxstate.c:        strcpy(devid, argv[optind]);
./hyperestraier_1.4.9/windows/scmutil.c:      wp += sprintf(wp, "%s", argv[i]);
./iceweasel_3.0.6/db/sqlite3/src/sqlite3.c:    strcpy(z, argv[i]);
./iceweasel_3.0.6/security/nss/lib/sqlite/sqlite3.c:  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));
./iceweasel_3.0.6/security/nss/lib/sqlite/sqlite3.c:  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));
./iceweasel_3.0.6/security/nss/lib/sqlite/sqlite3.c:        strcpy(z, argv[i]);
./imagemagick_6.3.7.9.dfsg2/www/source/core.c:  (void) strcpy(image_info->filename,argv[1]);
./imagemagick_6.3.7.9.dfsg2/www/source/core.c:  (void) strcpy(thumbnails->filename,argv[2]);
./inadyn_1.96/src/inadyn_cmd.c:	strcpy(p_self->dbg.p_logfilename, p_cmd->argv[current_nr]);
./inadyn_1.96/src/inadyn_cmd.c:	strcpy(p_self->info.credentials.my_username, p_cmd->argv[current_nr]);
./inadyn_1.96/src/inadyn_cmd.c:	strcpy(p_self->info.credentials.my_password, (p_cmd->argv[current_nr]));
./inadyn_1.96/src/inadyn_cmd.c:	strcpy(p_self->alias_info.names[p_self->alias_info.count].name, (p_cmd->argv[current_nr]));
./inadyn_1.96/src/inadyn_cmd.c:	strcpy(p_self->info.ip_server_url, p_cmd->argv[current_nr + 1]);
./inadyn_1.96/src/inadyn_cmd.c:	strcpy(p_self->info.dyndns_server_url, p_cmd->argv[current_nr]);
./inetutils_1.5.dfsg.1/ftp/cmds.c:		len += strlen(strcpy(&buf[len], argv[1]));
./inetutils_1.5.dfsg.1/ftp/cmds.c:			len += strlen(strcpy(&buf[len], argv[i]));
./inetutils_1.5.dfsg.1/gwhois/whois.c:	    strcat(qstring, *argv++);
./inetutils_1.5.dfsg.1/telnet/tn3270.c:	strcpy(transcom, argv[1]);
./inetutils_1.5.dfsg.1/telnet/tn3270.c:	    strcat(transcom, argv[i]);
./inn2_2.4.5/innd/cc.c:    strcpy(client.sun_path, argv[0]);
./insight_6.6/libgui/src/tkGraphCanvas.c:    strcpy(*fp, argv[4]);
./insight_6.6/libgui/src/tkGraphCanvas.c:    strcpy(*tp, argv[4]);
./insight_6.6/sim/erc32/interf.c:		    strcpy(uart_dev1, argv[++stat]);
./insight_6.6/sim/erc32/interf.c:		    strcpy(uart_dev2, argv[++stat]);
./insight_6.6/sim/erc32/sis.c:		    strcpy(uart_dev1, argv[++stat]);
./insight_6.6/sim/erc32/sis.c:		    strcpy(uart_dev2, argv[++stat]);
./insight_6.6/sim/ppc/main.c:  strcat(arg_, argv[0]);
./insight_6.6/tcl/generic/tclCkalloc.c:	strcpy(curTagPtr->string, argv[2]);
./insight_6.6/tcl/generic/tclCkalloc.c:    strcpy(tclMemDumpFileName, argv[1]);
./insight_6.6/tcl/generic/tclPkg.c:		strcpy(availPtr->version, argv3);
./insight_6.6/tcl/generic/tclPkg.c:	    strcpy(availPtr->script, argv4);
./insight_6.6/tcl/generic/tclPkg.c:		    strcpy(iPtr->packageUnknown, argv2);
./insight_6.6/tcl/generic/tclTest.c:	strcpy(asyncPtr->command, argv[2]);
./insight_6.6/tcl/generic/tclTest.c:    strcpy(dPtr->deleteCmd, argv[3]);
./insight_6.6/tcl/generic/tclTest.c:		strcpy(stringVar, argv[5]);
./insight_6.6/tcl/generic/tclTest.c:		strcpy(stringVar, argv[5]);
./insight_6.6/tcl/generic/tclTest.c:    strcpy(buf, argv[2]);
./insight_6.6/tcl/unix/tclUnixPipe.c:	sprintf(errSpace, "%dcouldn't execute \"%.150s\": ", errno, argv[0]);
./insight_6.6/tcl/unix/tclUnixTest.c:	strcpy(tclDefaultEncodingDir, argv[1]);
./insight_6.6/tk/generic/tkTest.c:	    strcpy((char *) ckalloc(strlen(argv[3]) + 1), argv[3]);
./insight_6.6/tk/generic/tkTest.c:		strcpy((char *) ckalloc(strlen(argv[4]) + 1), argv[4]);
./insight_6.6/tk/mac/tkMacWm.c:    strcpy(wmPtr->clientMachine, argv3);
./insight_6.6/tk/mac/tkMacWm.c:	strcpy(wmPtr->leaderName, argv3);
./insight_6.6/tk/mac/tkMacWm.c:	strcpy(wmPtr->iconName, argv3);
./insight_6.6/tk/mac/tkMacWm.c:	strcpy(wmPtr->title, argv3);
./insight_6.6/tk/mac/tkMacWm.c:	strcpy(wmPtr->masterWindowName, argv3);
./insight_6.6/tk/macosx/tkMacOSXWm.c:    strcpy(wmPtr->clientMachine, argv3);
./insight_6.6/tk/macosx/tkMacOSXWm.c:        strcpy(wmPtr->leaderName, argv3);
./insight_6.6/tk/macosx/tkMacOSXWm.c:        strcpy(wmPtr->iconName, argv3);
./insight_6.6/tk/macosx/tkMacOSXWm.c:        strcpy(wmPtr->masterWindowName, argv3);
./insight_6.6/tk/unix/tkUnixWm.c:    strcpy(wmPtr->clientMachine, argv3);
./insight_6.6/tk/unix/tkUnixWm.c:	strcpy(wmPtr->leaderName, argv3);
./insight_6.6/tk/unix/tkUnixWm.c:	strcpy(wmPtr->iconName, argv3);
./insight_6.6/tk/unix/tkUnixWm.c:	strcpy(wmPtr->title, argv3);
./insight_6.6/tk/win/tkWinWm.c:    strcpy(wmPtr->clientMachine, argv3);
./insight_6.6/tk/win/tkWinWm.c:	strcpy(wmPtr->leaderName, argv3);
./insight_6.6/tk/win/tkWinWm.c:	strcpy(wmPtr->iconName, argv3);
./insight_6.6/tk/win/tkWinWm.c:	strcpy(wmPtr->title, argv3);
./insight_6.6/tk/win/winDumpExts.c:		strcpy(&cmdline[pos], argv[i]);
./insighttoolkit_3.6.0/Utilities/nifti/utils/nifti_tool.c:   len = sprintf( opts->command, "\n  command: %s", argv[0] );
./insighttoolkit_3.6.0/Utilities/nifti/utils/nifti_tool.c:      if( has_space ) len = sprintf(cp, " '%s'", argv[ac]);
./insighttoolkit_3.6.0/Utilities/nifti/utils/nifti_tool.c:      else            len = sprintf(cp, " %s",   argv[ac]);
./ircd-hybrid_7.2.2.dfsg.2/src/getopt.c:		  strcpy(*((char**)opts[i].argloc), (*argv)[1]);
./ircd-ratbox_2.2.8.dfsg/src/getopt.c:					strcpy(*((char **) opts[i].argloc), (*argv)[1]);
./isdnutils_3.9.20060704/act2000/actctrl.c:			strcpy(ioctl_s.drvid, argv[2]);
./isdnutils_3.9.20060704/act2000/actctrl.c:				strcpy(msnlist, argv[arg_ofs + 2]);
./isdnutils_3.9.20060704/eicon/eiconctrl.c:			strcpy(ioctl_s.drvid, argv[arg_ofs++]);
./isdnutils_3.9.20060704/eicon/eiconctrl.c:		strcpy(cdef->id, argv[arg_ofs + 1]);
./isdnutils_3.9.20060704/eicon/eiconctrl.c:		strcpy(newargv[0], "eiconctrl.divaload");
./isdnutils_3.9.20060704/eicon/eiconctrl.c:				strcpy(newargv[newarg], "-t");
./isdnutils_3.9.20060704/eicon/eiconctrl.c:				strcpy(newargv[newarg], argv[i] + 2);
./isdnutils_3.9.20060704/eicon/eiconctrl.c:				strcpy(newargv[newarg], "-l");
./isdnutils_3.9.20060704/eicon/eiconctrl.c:				strcpy(newargv[newarg], argv[i] + 2);
./isdnutils_3.9.20060704/eicon/eiconctrl.c:				strcpy(newargv[newarg], "-s");
./isdnutils_3.9.20060704/eicon/eiconctrl.c:				strcpy(newargv[newarg], argv[i] + 2);
./isdnutils_3.9.20060704/eicon/eiconctrl.c:				strcpy(newargv[newarg], argv[i]);
./isdnutils_3.9.20060704/eicon/eiconctrl.c:			strcpy(newargv[newarg], "-c");
./isdnutils_3.9.20060704/eicon/eiconctrl.c:			sprintf(newargv[newarg], "%d", lcard + 1);
./isdnutils_3.9.20060704/eicon/eiconctrl.c:			strcpy(newargv[newarg], "-f");
./isdnutils_3.9.20060704/eicon/eiconctrl.c:			strcpy(newargv[newarg], protoname);
./isdnutils_3.9.20060704/eicon/eiconctrl.c:	                        strcpy(protoname,argv[++arg_ofs]);
./isdnutils_3.9.20060704/eicon/eiconctrl.c:				strcpy(file, argv[arg_ofs]);
./isdnutils_3.9.20060704/eicon/eiconctrl.c:				strcpy(Man_Path, argv[arg_ofs + 1]);
./isdnutils_3.9.20060704/eicon/eiconctrl.c:				strcpy(Man_Path, argv[arg_ofs + 1]);
./isdnutils_3.9.20060704/eurofile/src/wuauth/private.c:            strcpy(aptr->gname, (char *) argv[0]);
./isdnutils_3.9.20060704/eurofile/src/wuauth/private.c:            strcpy(aptr->gpass, (char *) argv[1]);
./isdnutils_3.9.20060704/eurofile/src/wuauth/private.c:            strcpy(aptr->gr_name, (char *) argv[2]);
./isdnutils_3.9.20060704/hisax/hisaxctrl.c:		strcpy(ioctl_s.drvid, argv[1]);
./isdnutils_3.9.20060704/icn/icnctrl.c:			strcpy(ioctl_s.drvid, argv[2]);
./isdnutils_3.9.20060704/isdnlog/isdnconf/isdnconf.c:			strcpy(alias, argv[optind]);
./isdnutils_3.9.20060704/isdnlog/isdnlog/ilp/ilp.c:  strcpy(call.num[1], argc > 1 ? argv[1] : "1234567");
./isdnutils_3.9.20060704/isdnlog/isdnlog/kernel_2_0/iiocnetgpn.c:    strcpy(phone.name, argv[1] && *argv[1] ? argv[1] : "ippp0");
./isdnutils_3.9.20060704/loop/loopctrl.c:			strcpy(ioctl_s.drvid, argv[2]);
./isdnutils_3.9.20060704/loop/loopctrl.c:				strcpy(startparm.num[0], argv[arg_ofs + 2]);
./isdnutils_3.9.20060704/loop/loopctrl.c:					strcpy(startparm.num[1], argv[arg_ofs + 3]);
./isdnutils_3.9.20060704/loop/loopctrl.c:					strcpy(startparm.num[2], argv[arg_ofs + 4]);
./isync_1.0.4/src/compat/main.c:			strcat( buf, argv[optind] );
./isync_1.0.4/src/compat/main.c:				strcat( buf, argv[optind] );
./italc_1.0.9~rc3/ica/x11/x11vnc/x11vnc.c:			sprintf(t, "%s=%s", t0, argv[i]);
./italc_1.0.9~rc3/ica/x11/x11vnc/x11vnc.c:			sprintf(raw_fb_str, "vnc:%s", argv[++i]);
./italc_1.0.9~rc3/ica/x11/x11vnc/x11vnc.c:				sprintf(str, "%s:%s", remote_cmd, argv[i]);
./jed_0.99.18+dfsg.1/src/mswshell.c:		  strcpy(p, argv[i]);
./jfbterm_0.4.7/pcf.c:    sprintf(buf, "gunzip < %s", argv[1]);
./jove_4.16.0.70/mac.c:				strcpy(argv[argc], pathname);
./jove_4.16.0.70/mac.c:				strcat(argv[argc], "/");
./jove_4.16.0.70/mac.c:				strcat(argv[argc], (char *)p.fName);
./jove_4.16.0.70/xjove/xjove.c:		sprintf(&buffer[strlen(buffer)], "%s ", argv[i]);
./joy2key_1.6.1/joy2key.c:			sprintf(string, "xwininfo -name \"%s\"", argv[1]);
./joy2key_1.6.1/joy2key.c:			sprintf(string, "xwininfo -id \"%s\"", argv[1]);
./joy2key_1.6.1/joy2key.c:			strcpy(string, argv[1]);
./joy2key_1.6.1/joy2key.c:			sprintf(string, "/dev/tty%s", argv[1][0] == '-' ? "" : argv[1]);
./kannel_1.4.1/wmlscript/wmlsc.c:        strcpy(outname, argv[i]);
./kbd_1.14.1/src/openvt.c:		   strcat(cmd, argv[optind]);
./kbuild_0.1.3svn1610/src/ash/exec.c:		strcpy(cmdname, argv[0]);
./kbuild_0.1.3svn1610/src/fastdep/fastdep.c:                            strcpy(szObjectExt, argv[argi]+4);
./kbuild_0.1.3svn1610/src/fastdep/fastdep.c:                            strcpy(szObjectExt, argv[argi]);
./kbuild_0.1.3svn1610/src/fastdep/fastdep.c:                            strcpy(szObjectDir, argv[argi]+2);
./kbuild_0.1.3svn1610/src/fastdep/fastdep.c:                        strcpy(szObjectDir, argv[argi]);
./kbuild_0.1.3svn1610/src/fastdep/fastdep.c:                        strcpy(szRsrcExt, argv[argi]+2);
./kbuild_0.1.3svn1610/src/fastdep/fastdep.c:                        strcpy(szRsrcExt, argv[argi]);
./kbuild_0.1.3svn1610/src/fastdep/fastdep.c:                        strcpy(psz, &argv[argi][2]);
./kbuild_0.1.3svn1610/src/fastdep/fastdep.c:                        strcpy(psz, argv[argi]);
./kbuild_0.1.3svn1610/src/kash/exec.c:		strcpy(cmdname, argv[0]);
./kbuild_0.1.3svn1610/src/kmk/kmkbuiltin/mv.c:	(void)strcpy(path, argv[argc - 1]);
./kdemultimedia_3.5.9/kscd/libwm/buildindex.c:			sprintf(indname, "%s: fstat", argv[i]);
./kdemultimedia_3.5.9/kscd/libwm/buildindex.c:			sprintf(indname, "%s: Warning: Couldn't lock", argv[i]);
./kdemultimedia_3.5.9/kscd/libwm/buildindex.c:		sprintf(indname, "%s.ind", argv[i]);
./kdenetwork_3.5.10/kopete/plugins/statistics/sqlite/func.c:  strcpy(z, sqlite3_value_text(argv[0]));
./kdenetwork_3.5.10/kopete/plugins/statistics/sqlite/func.c:  strcpy(z, sqlite3_value_text(argv[0]));
./kdenetwork_3.5.10/kopete/plugins/statistics/sqlite/shell.c:      sprintf(data.separator,"%.*s",(int)sizeof(data.separator)-1,argv[i]);
./kdenetwork_3.5.10/kopete/plugins/statistics/sqlite/shell.c:      sprintf(data.nullvalue,"%.*s",(int)sizeof(data.nullvalue)-1,argv[i]);
./kdenetwork_3.5.10/kopete/plugins/statistics/sqlite/table.c:        strcpy(z, argv[i]);
./klamav_0.44/src/sqlite/func.c:  strcpy(z, sqlite3_value_text(argv[0]));
./klamav_0.44/src/sqlite/func.c:  strcpy(z, sqlite3_value_text(argv[0]));
./klamav_0.44/src/sqlite/table.c:        strcpy(z, argv[i]);
./knews_1.0b.1/regexp/split.c:			(void) strcpy(buf, argv[1]);
./knews_1.0b.1/regexp/split.c:			(void) strcpy(buf, argv[1]);
./koffice_1.6.3/kexi/3rdparty/kexisql/src/func.c:    strcpy(p->z, argv[0]);
./koffice_1.6.3/kexi/3rdparty/kexisql/src/shell.c:      sprintf(data.separator,"%.*s",(int)sizeof(data.separator)-1,argv[i]);
./koffice_1.6.3/kexi/3rdparty/kexisql/src/shell.c:      sprintf(data.nullvalue,"%.*s",(int)sizeof(data.nullvalue)-1,argv[i]);
./koffice_1.6.3/kexi/3rdparty/kexisql/src/table.c:        strcpy(z, argv[i]);
./koffice_1.6.3/kexi/3rdparty/kexisql/src/vacuum.c:  sprintf(zBuf,"PRAGMA %s=%s;", p->zPragma, argv[0]);
./koffice_1.6.3/kexi/3rdparty/kexisql/tool/lemon.c:    if( path ) sprintf(path,"%s/%s",argv0,name);
./koffice_1.6.3/kexi/3rdparty/kexisql3/src/func.c:  strcpy(z, sqlite3_value_text(argv[0]));
./koffice_1.6.3/kexi/3rdparty/kexisql3/src/func.c:  strcpy(z, sqlite3_value_text(argv[0]));
./koffice_1.6.3/kexi/3rdparty/kexisql3/src/shell.c:      sprintf(data.separator,"%.*s",(int)sizeof(data.separator)-1,argv[i]);
./koffice_1.6.3/kexi/3rdparty/kexisql3/src/shell.c:      sprintf(data.nullvalue,"%.*s",(int)sizeof(data.nullvalue)-1,argv[i]);
./koffice_1.6.3/kexi/3rdparty/kexisql3/src/table.c:        strcpy(z, argv[i]);
./krb5_1.6.dfsg.4~beta1/src/appl/bsd/krcp.c:	    strcpy(krb_realm, *argv);	
./krb5_1.6.dfsg.4~beta1/src/appl/bsd/krcp.c:	    strcpy(krb_cache, *argv);	
./krb5_1.6.dfsg.4~beta1/src/appl/bsd/krcp.c:	    strcpy(krb_config, *argv);	
./krb5_1.6.dfsg.4~beta1/src/appl/bsd/krlogin.c:	strcpy(krb_realm, *argv);
./krb5_1.6.dfsg.4~beta1/src/appl/bsd/krsh.c:	strcpy(krb_realm, *argv);
./krb5_1.6.dfsg.4~beta1/src/kadmin/testing/util/tcl_kadm5.c:	  strcpy((char *) tl->tl_data_contents, argv1[2]);
./krb5_1.6.dfsg.4~beta1/src/util/ss/mk_cmds.c:    strcpy(path, argv[1]);
./krb5_1.6.dfsg.4~beta1/src/wconfig.c:		strcat(wflags, *argv);
./krb5_1.6.dfsg.4~beta1/src/wconfig.c:			sprintf(tmp, "%s##", (*argv)+ignore_len);
./ksh_93s+20080202/src/cmd/ksh93/sh/io.c:				strcpy(ap->argval,iop->ioname);
./ksh_93s+20080202/src/cmd/ksh93/sh/lex.c:	strcpy(iop->ioname,shlex.arg->argval);
./ksh_93s+20080202/src/cmd/ksh93/sh/parse.c:			strcpy(shlex.arg->argval,"CUR");
./l2tpns_2.1.21/cli.c:			strcpy(ip_filters[filt].name, argv[1]);
./lablgl_1.03/Togl/src/Togl/double.c:   strcpy( interp->result, argv[2] );
./lablgl_1.03/Togl/src/Togl/double.c:   strcpy( interp->result, argv[2] );
./lablgl_1.03/Togl/src/Togl/gears.c:   strcpy( interp->result, argv[2] );
./lablgl_1.03/Togl/src/Togl/stereo.c:   strcpy( interp->result, argv[2] );
./lablgl_1.03/Togl/src/Togl/stereo.c:   strcpy( interp->result, argv[2] );
./lablgl_1.03/Togl/src/Togl/stereo.c:   strcpy( interp->result, argv[2] );
./lablgl_1.03/Togl/src/Togl/texture.c:   strcpy( interp->result, argv[2] );
./lablgl_1.03/Togl/src/Togl/texture.c:   strcpy( interp->result, argv[2] );
./lablgl_1.03/Togl/src/Togl/texture.c:   strcpy( interp->result, argv[2] );
./lablgl_1.03/Togl/src/Togl/texture.c:   strcpy( interp->result, argv[2] );
./lablgl_1.03/Togl/src/Togl/texture.c:   strcpy( interp->result, argv[2] );
./lablgl_1.03/Togl/src/Togl/texture.c:   strcpy( interp->result, argv[2] );
./lablgl_1.03/Togl/src/Togl/texture.c:   strcpy( interp->result, argv[2] );
./lablgl_1.03/Togl/src/Togl/texture.c:   strcpy( interp->result, argv[2] );
./lablgl_1.03/Togl/src/Togl/texture.c:   strcpy( interp->result, argv[2] );
./lcd4linux_0.10.1~rc2/plugin_cfg.c:	strcat(buffer, R2S(argv[i]));
./lcdproc_0.4.5-1.1/server/drivers/bayrad.c:	  strcpy(device, argv[++i]);
./lcdproc_0.4.5-1.1/server/drivers/lb216.c:	 strcpy(device, argv[++i]);
./lesstif2_0.95.0/lib/Xm-2.1/Xpms_popen.c:    strcpy(argv[i], ptr);
./lesstif2_0.95.0/test/Xm/protocols/test1.c:			save_argv[save_argc] = strcpy(XtMalloc(strlen(argv[save_argc])+1),
./levee_3.5a/main.c:	strcpy(filenm, argv[0]);
./lgc-pg_0.32/src/main.c:            strcpy( tacicons, argv[i + 1] );
./lgrind_3.67/source/lgrind.c:		 strcpy(language, argv[1]);
./lgrind_3.67/source/lgrind.c:		 strcpy(language, argv[0]+2);
./lgrind_3.67/source/lgrind.c:		strcpy(defsfile, argv[1]);
./lgrind_3.67/source/lgrind.c:	 strcpy(fname, argv[0]);
./libchewing_0.3.0/src/tools/sort_dic.c:		strcpy( in_file, argv[ 1 ] );
./libcli_1.9.1~20080302/libcli.c:	strcat(p, argv[i]);
./libcsoap_1.1.0/wsdl2c/wsdl2c.c:      else strcpy(outDir, argv[++i]);
./libcsoap_1.1.0/wsdl2c/wsdl2c.c:    else strcpy(fname, argv[i]);
./libcsoap_1.1.0/xsd2c/main.c:      else strcpy(outDir, argv[++i]);
./libcsoap_1.1.0/xsd2c/main.c:    else strcpy(fname, argv[i]);
./libctl_3.0.2/base/main.c:      strcat(definestr,argv[i]);
./libctl_3.0.2/base/main.c:	   strcpy(definestr,argv[i]);
./libdbd-sqlite2-perl_0.33/func.c:    strcpy(p->z, argv[0]);
./libdbd-sqlite2-perl_0.33/table.c:        strcpy(z, argv[i]);
./libdbd-sqlite2-perl_0.33/vacuum.c:  sprintf(zBuf,"PRAGMA %s=%s;", p->zPragma, argv[0]);
./libdbd-sqlite3-perl_1.14/fts2.c:    strcpy(z, argv[i]);
./libdvdnav_4.1.2/msvc/contrib/getopt.c:		sprintf(var, "_%d_GNU_nonoption_argv_flags_", getpid());
./libfann1_1.2.0/benchmarks/quality_fixed.c:		sprintf(file, "%s_%d", argv[1], fann_get_decimal_point(ann));
./libfann1_1.2.0/benchmarks/quality_fixed.c:		sprintf(file, "%s_%d", argv[2], fann_get_decimal_point(ann));
./libfcgi_2.4.0/cgi-fcgi/cgi-fcgi.c:                    strcpy(connectPathPtr, argv[i]);
./libfcgi_2.4.0/cgi-fcgi/cgi-fcgi.c:            strcpy(appPathPtr, argv[i]);
./libfcgi-ruby_0.8.7/ext/fcgi/fcgi.c:  fcgi_stream_write(out, rb_f_sprintf(argc, argv));
./libgda3_3.0.2/providers/sqlite/sqlite-src/fts1.c:    strcpy(z, argv[i]);
./libgda3_3.0.2/providers/sqlite/sqlite-src/func.c:  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));
./libgda3_3.0.2/providers/sqlite/sqlite-src/func.c:  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));
./libgda3_3.0.2/providers/sqlite/sqlite-src/table.c:        strcpy(z, argv[i]);
./libgsl-ruby_1.10.3/ext/function.c:    strcpy(opt, STR2CSTR(argv[1]));
./libgsl-ruby_1.10.3/ext/graph.c:    sprintf(command, "%s %s", command, STR2CSTR(argv[2]));
./libgsl-ruby_1.10.3/ext/graph.c:      sprintf(command, "%s %s", command, STR2CSTR(argv[1]));
./libgsl-ruby_1.10.3/ext/graph.c:      sprintf(command, "%s %s", command, STR2CSTR(argv[0]));
./libgsl-ruby_1.10.3/ext/graph.c:    sprintf(command, "%s %s", command, STR2CSTR(argv[2]));
./libgsl-ruby_1.10.3/ext/graph.c:      sprintf(command, "%s %s", command, STR2CSTR(argv[1]));
./libgsl-ruby_1.10.3/ext/graph.c:      sprintf(command, "%s %s", command, STR2CSTR(argv[0]));
./libgsl-ruby_1.10.3/ext/histogram.c:  strcpy(fittype, STR2CSTR(argv[0]));
./libgsl-ruby_1.10.3/ext/multifit.c:      strcpy(name, STR2CSTR(argv[0]));
./libgsl-ruby_1.10.3/ext/multifit.c:    strcpy(fittype, STR2CSTR(argv[2]));
./libgsl-ruby_1.10.3/ext/multifit.c:    strcpy(fittype, STR2CSTR(argv[3]));
./libgsl-ruby_1.10.3/ext/vector_double.c:    sprintf(command, "graph -T X %s", STR2CSTR(argv[argc-1]));
./libgsl-ruby_1.10.3/ext/vector_double.c:      sprintf(command, "%s %s", command, STR2CSTR(argv[4]));
./libgsl-ruby_1.10.3/ext/vector_double.c:      sprintf(command, "%s %s", command, STR2CSTR(argv[3]));
./libgsl-ruby_1.10.3/ext/vector_double.c:      sprintf(command, "%s %s", command, STR2CSTR(argv[2]));
./libgsl-ruby_1.10.3/ext/vector_double.c:      sprintf(command, "%s %s", command, STR2CSTR(argv[1]));
./libgsl-ruby_1.10.3/ext/vector_double.c:      sprintf(command, "%s %s", command, STR2CSTR(argv[0]));
./libhdf4_4.1r4/hdf/fmpool/test_fmpio.c:      strcpy(t_filename,argv[1]);
./libhdf4_4.1r4/hdf/fmpool/test_fmpio.c:      strcpy(t_filename,argv[1]);
./libhdf4_4.1r4/hdf/fmpool/test_fmpio.c:      strcpy(t_filename,argv[1]);
./libhdf4_4.1r4/hdf/fmpool/tfmpio_read.c:      strcpy(t_filename,argv[1]);
./libhdf4_4.1r4/hdf/fmpool/tfmpio_read.c:      strcpy(t_filename,argv[1]);
./libhdf4_4.1r4/hdf/fmpool/tfmpio_read.c:      strcpy(t_filename,argv[1]);
./libhdf4_4.1r4/hdf/fmpool/tfmpio_write.c:      strcpy(t_filename,argv[1]);
./libhdf4_4.1r4/hdf/fmpool/tfmpio_write.c:      strcpy(t_filename,argv[1]);
./libhdf4_4.1r4/hdf/fmpool/tfmpio_write.c:      strcpy(t_filename,argv[1]);
./libhdf4_4.1r4/hdf/jpeg/wrjpgcom.c:	strcpy(comment_arg, argv[argn]+1);
./libhdf4_4.1r4/hdf/jpeg/wrjpgcom.c:	  strcat(comment_arg, argv[argn]);
./libhdf4_4.1r4/hdf/util/fp2hdf.c:                    (void) HDstrcpy(opt.outfile, argv[i]);
./libhdf4_4.1r4/hdf/util/fp2hdf.c:                    (void) HDstrcpy(opt.palfile, argv[i]);
./libhdf4_4.1r4/hdf/util/hdf2jpeg.c:        HDstrcpy(jfif_name, argv[2]);   /* copy the JPEG file name */
./libhdf4_4.1r4/hdf/util/hdfpack.c:    HDstrcpy(invoke, strtok(argv[0], "/]\\\0"));
./libhdf4_4.1r4/hdf/util/hdfpack.c:                      HDstrcpy(fname[fnum], argv[i]);
./libhdf4_4.1r4/hdf/util/hdfunpac.c:                          strcpy(datafilename, *argv++);
./libhdf4_4.1r4/hdf/zlib/contrib/minizip/minizip.c:		strcpy(filename_try,argv[zipfilenamearg]);
./libhdf4_4.1r4/mfhdf/dumper/hdp_gr.c:             HDstrcpy(dumpgr_opts->file_name, argv[++(*curr_arg)]);
./libhdf4_4.1r4/mfhdf/dumper/hdp_gr.c:      HDstrcpy(file_name, argv[curr_arg]);   /* get file name */
./libhdf4_4.1r4/mfhdf/dumper/hdp_rig.c:                HDstrcpy(dumprig_opts->file_name, argv[++(*curr_arg)]);
./libhdf4_4.1r4/mfhdf/dumper/hdp_rig.c:          HDstrcpy(file_name, argv[curr_arg]);
./libhdf4_4.1r4/mfhdf/dumper/hdp_sds.c:                HDstrcpy(dumpsds_opts->file_name, argv[++(*curr_arg)]);
./libhdf4_4.1r4/mfhdf/dumper/hdp_sds.c:      HDstrcpy(file_name, argv[curr_arg]);
./libhdf4_4.1r4/mfhdf/dumper/hdp_vd.c:             HDstrcpy(dumpvd_opts->file_name, argv[++(*curr_arg)]);
./libhdf4_4.1r4/mfhdf/dumper/hdp_vd.c:   HDstrcpy(file_name, argv[curr_arg]); 
./libhdf4_4.1r4/mfhdf/dumper/hdp_vg.c:             HDstrcpy(dumpvg_opts->file_name, argv[++(*curr_arg)]);
./libhdf4_4.1r4/mfhdf/dumper/hdp_vg.c:      HDstrcpy(file_name, argv[curr_arg]);  /* get current input file name */
./libhdf4_4.1r4/mfhdf/ncgen/main.c:	strcpy(cdlname, argv[0]);
./libical_0.31/src/libicalvcal/vctest.c:	    strcpy(buf,*argv);
./libicns_0.5.9/icnsutils/icns2png.c:		strcpy(inputFileNames[fileCount], argv[0]);
./libjpeg6b_6b/wrjpgcom.c:	strcpy(comment_arg, argv[argn]+1);
./libjpeg6b_6b/wrjpgcom.c:	  strcat(comment_arg, argv[argn]);
./libmpeg3_1.5.4/mpeg2qt.c:			strcpy(input_path, argv[i]);
./libmpeg3_1.5.4/mpeg2qt.c:			strcpy(output_path, argv[i]);
./libmpeg3_1.5.4/mpeg3cat.c:					strcpy(outpath, argv[++i]);
./libmpeg3_1.5.4/mpeg3cat.c:		strcpy(inpath, argv[current_file]);
./libmpeg3_1.5.4/mpeg3dump.c:				strcpy(outfile, argv[++i]);
./libmtp_0.2.6.1/examples/delfile.c:      strcpy(argv[1],"");
./libmtp_0.2.6.1/examples/delfile.c:      strcpy(argv[1],"0");
./libowfat_0.27/test/dllink.c:    strcat(buf,argv[1]+5);
./libowfat_0.27/test/dllink.c:    strcat(buf,argv[1]);
./libpam-radius-auth_1.3.16/pam_radius_auth.c:      strcpy(conf_file,*argv+5);
./libpano12_2.8.6/shell_mac.c:	strcpy( argv[0], appName );
./libpano12_2.8.6/shell_mac.c:	strcpy( argv[0], appName );
./libpano12_2.8.6/shell_mac.c:									strcpy(argv[0], appName );
./libpano12_2.8.6/shell_mac.c:									strcpy(argv[0], appName );
./libpano13_2.9.12.dfsg/shell_mac.c:	strcpy( argv[0], appName );
./libpano13_2.9.12.dfsg/shell_mac.c:	strcpy( argv[0], appName );
./libpano13_2.9.12.dfsg/shell_mac.c:									strcpy(argv[0], appName );
./libpano13_2.9.12.dfsg/shell_mac.c:									strcpy(argv[0], appName );
./libproc-processtable-perl_0.44/os/bsdi.c:		strcat(cmndline, argv[j]);
./libproc-processtable-perl_0.44/os/FreeBSD-kvm.c:         strcat(cmndline, argv[j]);
./librsync_0.9.7/popt/findme.c:	sprintf(buf, "%s/%s", start, argv0);
./librsync_0.9.7/popt/poptparse.c:	dst += strlen(strcpy(dst, argv[i])) + 1;
./libsvm_2.85.0/svm-train.c:	strcpy(input_file_name, argv[i]);
./libsvm_2.85.0/svm-train.c:		strcpy(model_file_name,argv[i+1]);
./libtasn1-3_1.4/src/asn1Coding.c: strcpy(inputFileAsnName,argv[optind]);
./libtasn1-3_1.4/src/asn1Coding.c: strcpy(inputFileAssignmentName,argv[optind+1]);
./libtasn1-3_1.4/src/asn1Decoding.c: strcpy(inputFileAsnName,argv[optind]);
./libtasn1-3_1.4/src/asn1Decoding.c: strcpy(inputFileDerName,argv[optind+1]);
./libtasn1-3_1.4/src/asn1Decoding.c: strcpy(typeName,argv[optind+2]);
./libtasn1-3_1.4/src/asn1Parser.c:   strcpy(inputFileName,argv[optind]);
./libthai_0.1.9/tests/thsort.c:        strcpy(DataFileName, argv[1]);
./libthai_0.1.9/tests/thsort.c:        strcpy(OutFileName, argv[2]);
./libtk-img_1.3-release/libjpeg/wrjpgcom.c:	strcpy(comment_arg, argv[argn]+1);
./libtk-img_1.3-release/libjpeg/wrjpgcom.c:	  strcat(comment_arg, argv[argn]);
./libtk-img_1.3-release/libtiff/tools/tiff2bw.c:	sprintf(thing, "B&W version of %s", argv[optind]);
./libtk-img_1.3-release/libtiff/tools/tiffdither.c:	sprintf(thing, "Dithered B&W version of %s", argv[optind]);
./libtk-img_1.3-release/libtiff/tools/tiffsplit.c:		strcpy(fname, argv[2]);
./libtunepimp_0.5.3/examples/puid.c:    strcpy(clientId, argv[index++]);
./libvncserver_0.9.3.dfsg.1/x11vnc/misc/blockdpy.c:			sprintf(estr, "DISPLAY=%s", argv[++i]);
./libvncserver_0.9.3.dfsg.1/x11vnc/misc/blockdpy.c:			sprintf(estr, "XAUTHORITY=%s", argv[++i]);
./libvncserver_0.9.3.dfsg.1/x11vnc/x11vnc.c:			sprintf(t, "%s=%s", t0, argv[i]);
./libvncserver_0.9.3.dfsg.1/x11vnc/x11vnc.c:			sprintf(raw_fb_str, "vnc:%s", argv[++i]);
./libvncserver_0.9.3.dfsg.1/x11vnc/x11vnc.c:				sprintf(str, "%s:%s", remote_cmd, argv[i]);
./libvorbis_1.2.0.dfsg/vq/latticebuild.c:    strcpy(filename,argv[1]);
./libvorbis_1.2.0.dfsg/vq/latticepare.c:	  sprintf(buff,"%s.vqh",*argv);
./libvorbis_1.2.0.dfsg/vq/train.c:    strcpy(filename,*argv);
./libx11_1.1.5/src/SetHints.c:		    (void) strcpy(bp, argv[i]);
./linphone_2.1.1/oRTP/src/tests/mrtprecv.c:		sprintf(filename,"%s%4.4d.dat",argv[1],i);
./linphone_2.1.1/oRTP/src/tests/rtpmemtest.c:		sprintf(filename,"%s%4.4d.dat",argv[1],i);
./linphone_2.1.1/oRTP/src/tests/tevmrtprecv.c:		sprintf(filename,"%s%4.4d.dat",argv[1],i);
./lpe_1.2.6.13-0.1/data/comp.c:		strcat(s,argv[i]);
./lp-solve_5.5.0.10/bfp/bfp_LUSOL/LUSOL/lusolmain.c:  strcpy(fileext, strchr(argv[useropt], '.'));
./lp-solve_5.5.0.10/bfp/bfp_LUSOL/LUSOL/lusolmain.c:    strcpy(fileext, strchr(argv[useropt], '.'));
./magnus_20060324/back_end/black_boxes/homology/src/homology/chom.c:				strcpy(input_file, argv[count_arg]);
./magnus_20060324/back_end/black_boxes/homology/src/homology/chom_stats.c:				strcpy(statsfilename, argv[count_arg]);
./magnus_20060324/back_end/black_boxes/homology/src/kbeqn/cfsa.c:			strcpy(inf, argv[i]);
./magnus_20060324/back_end/black_boxes/homology/src/kbeqn/kbeqn2.c:			strcpy(inf, argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/fsaand.c:         strcpy(inf1,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/fsaand.c:         strcpy(inf2,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/fsaand.c:         strcpy(outf,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/fsabfs.c:       strcpy(inf,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/fsacount.c:       strcpy(inf,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/fsaenumerate.c:       else strcpy(inf,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/fsaexists.c:       strcpy(inf,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/fsafilter.c:       strcpy(inf,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/fsamin.c:       strcpy(inf,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/fsanot.c:       strcpy(inf,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/fsaor.c:         strcpy(inf1,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/fsaor.c:         strcpy(inf2,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/fsaor.c:         strcpy(outf,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/gpaxioms.c:       strcpy(gpname,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/gpcheckmult.c:       strcpy(inf1,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/gpcomp.c:         strcpy(inf1,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/gpcomp.c:         strcpy(inf2,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/gpcomp.c:         strcpy(outf,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/gpgenmult.c:         strcpy(inf1,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/gpgenmult2.c:         strcpy(inf,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/gpgenmult3.c:         strcpy(inf1,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/gpmakefsa.c:         strcpy(inf1,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/gpminkb.c:       strcpy(gpname,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/gpmult.c:         strcpy(groupname,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/gpmult2.c:         strcpy(inf,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/gpranred.c:         strcpy(inf1,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/gpwa.c:       strcpy(inf,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/gpwab.c:       strcpy(inf,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/kbprog.c:			strcpy(inf, argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/ppgap.c:  strcpy(gpname,argv[1]);
./magnus_20060324/back_end/black_boxes/kbmag/src/wordreduce.c:         strcpy(gpname,argv[arg]);
./magnus_20060324/back_end/black_boxes/kbmag/src/wordreduce.c:         strcpy(inf2,argv[arg]);
./mailman_2.1.11/src/common.c:        strcpy(newargv[j], scriptdir);
./mailman_2.1.11/src/common.c:        strcat(newargv[j], script);
./maloc_0.2/src/vsh/vpars.c:        strcpy(inbuf_argv,inbuf);
./maloc_0.2/src/vsh/vsh.c:    sprintf(PR_TMP,"%s: %s",PR,argv[0]);
./maloc_0.2/src/vsh/vsh.c:                strcat(buf,argv[i]);
./matchbox-panel_0.9.3/applets/mb-applet-launcher.c:      strcpy(win_panel_title, argv[1+switch_count]);
./matchbox-panel_0.9.3/src/panel_util.c:   strcpy(cmd, argv_win[0]);
./mcl_06-058/src/contrib/tribe/tribe-matrix.c:		strcpy(file1,argv[i+1]);
./mcl_06-058/src/contrib/tribe/tribe-matrix.c:		strcpy(file2,argv[i+1]);
./mcpp_2.7.1/src/system.c:                strcpy( arch, argv[ mcpp_optind++]);
./mcpp_2.7.1/tool/cpp_test.c:    strcpy( cmp_name, argv[ 1]);
./mcpp_2.7.1/tool/cpp_test.c:        strcpy( comp_fmt, argv[ 2]);
./mcpp_2.7.1/tool/cpp_test.c:            sprintf( buf, argv[i], pgm_name, pgm_name);
./mdbtools_0.5.99.0.6pre1.0.20051109/src/util/prole.c:		strcpy(sarg.value.s, sargval);
./meritous_1.2+dfsg/src/levelblit.c:				strcpy(record_filename, argv[i+1]);
./meritous_1.2+dfsg/src/levelblit.c:				strcpy(record_filename, argv[i+1]);
./minc_2.0.15/conversion/dcm2mnc/dcm2mnc.c:        strcpy(out_dir, argv[argc - 1]); 
./minc_2.0.15/conversion/dcm2mnc/dcm2mnc.c:                    strcpy(tmp_str, argv[ifile + 1]);
./minc_2.0.15/conversion/micropet/upet2mnc.c:        strcpy(img_fname, argv[i]);
./minc_2.0.15/conversion/micropet/upet2mnc.c:        strcpy(hdr_fname, argv[i]);
./minc_2.0.15/conversion/micropet/upet2mnc.c:            strcpy(out_fname, argv[i+1]);
./minc_2.0.15/conversion/nifti1/mnc2nii.c:        strcpy(out_str, argv[1]);
./minc_2.0.15/conversion/nifti1/mnc2nii.c:        strcpy(out_str, argv[2]);
./minc_2.0.15/conversion/nifti1/nii2mnc.c:        strcpy(out_str, argv[1]);
./minc_2.0.15/conversion/nifti1/nii2mnc.c:        strcpy(out_str, argv[2]);
./minc_2.0.15/conversion/vff2mnc/vff2mnc.c:	strcpy(out_str, argv[1]);
./minc_2.0.15/conversion/vff2mnc/vff2mnc.c:	  strcpy(out_dir, argv[argc - 1]); 
./minc_2.0.15/conversion/vff2mnc/vff2mnc.c:	      strcpy(tmp_str, argv[ifile + 1]);
./minc_2.0.15/libsrc/time_stamp.c:      (void) strcat(str, argv[i]);
./mldonkey_2.9.5/config/wget.c:            strcpy( pathname, argv[3] );
./mnogosearch_3.3.7/src/utils.c:					strcpy(d,argv[argn-1]);
./mpack_1.6/unixpk.c:	sprintf(headers, "To: %s", argv[optind]);
./mpack_1.6/unixpk.c:	    strcat(headers, argv[i]);
./mpc_0.12.1/src/command.c:					strcpy(argv[i], fromUtf8(pl->path));
./mysql-dfsg-5.0_5.0.51a/libmysql/mytest.c:      strcpy( szDB, argv[ 1 ] ) ;
./mysql-dfsg-5.0_5.0.51a/libmysql/mytest.c:    strcpy( szDB, argv[ 1 ] ) ;
./mysql-dfsg-5.0_5.0.51a/libmysql/mytest.c:    strcpy( szSQL, argv[ 2 ] ) ;
./mysql-dfsg-5.0_5.0.51a/netware/my_manage.c:    strcpy(al->argv[al->argc], temp);
./mysql-dfsg-5.0_5.0.51a/netware/my_manage.c:	strcpy(temp, strlwr(argv0));
./mysql-dfsg-5.0_5.0.51a/pstack/pstack.c:			bufptr += sprintf(bufptr, "%s = ", f->argv[i].name);
./mysql-dfsg-5.0_5.0.51a/regex/split.c:			(void) strcpy(buf, argv[1]);
./mysql-dfsg-5.0_5.0.51a/regex/split.c:			(void) strcpy(buf, argv[1]);
./mysql-dfsg-5.0_5.0.51a/strings/conf_to_src.c:  sprintf(filename,"%s/%s",argv[1],"Index.xml");
./mysql-dfsg-5.0_5.0.51a/strings/conf_to_src.c:        sprintf(filename,"%s/%s.xml",argv[1],cs->csname);
./nagiosgrapher_1.6.1rc5/contrib/udpecho/udpecho.c:        strcpy(buffer, argv[2]);
./nagios-plugins_1.4.12/contrib/check_http-with-client-certificate.c:                        strcpy( argv[c], "-t" );
./nagios-plugins_1.4.12/contrib/check_http-with-client-certificate.c:                        strcpy( argv[c], "-H" );
./nagios-plugins_1.4.12/contrib/check_http-with-client-certificate.c:                        strcpy( argv[c], "-w" );
./nagios-plugins_1.4.12/contrib/check_http-with-client-certificate.c:                        strcpy( argv[c], "-c" );
./nagios-plugins_1.4.12/contrib/check_http-with-client-certificate.c:                asprintf( &server_host, "%s", argv[c++] );
./nagios-plugins_1.4.12/contrib/check_http-with-client-certificate.c:               asprintf( &server_hostname, "%s", argv[c++] ); 
./nagios-plugins_1.4.12/plugins/check_nt.c:      strcpy(argv[c],"-t");
./nagios-plugins_1.4.12/plugins/check_nt.c:      strcpy(argv[c],"-w");
./nagios-plugins_1.4.12/plugins/check_nt.c:      strcpy(argv[c],"-c");
./nagios-plugins_1.4.12/plugins/check_nwstat.c:      strcpy(argv[c],"-t");
./nagios-plugins_1.4.12/plugins/check_nwstat.c:      strcpy(argv[c],"-w");
./nagios-plugins_1.4.12/plugins/check_nwstat.c:      strcpy(argv[c],"-c");
./nasm_2.03.01/rdoff/ldrdf.c:                add_library(newstrcat(libpath, *argv + 2));
./nasm_2.03.01/rdoff/ldrdf.c:                loadmodule(newstrcat(objpath, *argv));
./nat_1.0/client.c:      strcpy(service,argv[1]);  
./nat_1.0/client.c:	  strcpy(password,argv[1]);  
./nedit_5.5/source/window.c:        	sprintf(argv[argc++], "%s%s", win->path, win->filename);
./netpbm-free_10.0/pbm/libpbmvms.c:	strcpy(subcmd, cmargv[0]);
./netpbm-free_10.0/pbm/libpbmvms.c:	    strcat(subcmd, cmargv[j]);
./netpbm-free_10.0/pbm/libpbmvms.c:    strcat(command, argv[0]);
./netpbm-free_10.0/pbm/libpbmvms.c:	strcat(command, *(++argv));
./netpbm-free_10.0/pbm/pbmtext.c:            strcat(cmdline_p->text, argv[i]);
./netpbm-free_10.0/pbm/pbmtextps.c:    strcat(cmdlineP->text, argv[i]);
./netpbm-free_10.0/pbm/pbmtoatk.c:	strcpy( name, argv[1] );
./netpbm-free_10.0/pbm/pbmtomacp.c:    strcpy( name, argv[argn] );
./netpbm-free_10.0/pbm/pbmtox10bm.c:	strcpy( name, argv[1] );
./netpbm-free_10.0/pbm/pbmtozinc.c:	strcpy( name, argv[1] );
./netpbm-free_10.0/ppm/ppmtompeg/file.c:	strcpy(globString, argv[1]);
./netpbm-free_10.0/ppm/ppmtompeg/main.c:    strcpy(encoder_name, argv[0]);
./netpbm-free_10.0/ppm/ppmtotga.c:            (void) strcpy( out_name, argv[argn] );
./netpbm-free_10.0/ppm/ppmtotga.c:            (void) strcpy( out_name, argv[argn] );
./netpbm-free_10.0/ppm/ppmtouil.c:	    (void) strcpy( out_name, argv[argn] );
./netpbm-free_10.0/ppm/ppmtouil.c:	    (void) strcpy( out_name, argv[argn] );
./netpbm-free_10.0/ppm/ppmtoyuvsplit.c:        strcpy(ufname,argv[1]);
./netpbm-free_10.0/ppm/ppmtoyuvsplit.c:        strcpy(vfname,argv[1]);
./netpbm-free_10.0/ppm/ppmtoyuvsplit.c:        strcpy(yfname,argv[1]);
./netpbm-free_10.0/ppm/yuvsplittoppm.c:	strcpy(ufname,argv[1]);
./netpbm-free_10.0/ppm/yuvsplittoppm.c:	strcpy(vfname,argv[1]);
./netpbm-free_10.0/ppm/yuvsplittoppm.c:	strcpy(yfname,argv[1]);
./netpbm-free_10.0/urt/rle_addhist.c:		(void)strcat(newc,argv[i]);(void)strcat(newc," ");
./netperf_2.4.4/src/netserver.c:	strcpy(program, argv[0]);
./netperf_2.4.4/src/netsh.c:  strcpy(program, argv[0]);
./netw-ib-ox-ag_5.35.0/src/netwib-src/src/netwib/sys/priv/cmdline.c:    netwib_c_strcpy(argv[0], filename);
./netw-ib-ox-ag_5.35.0/src/netwib-src/src/netwib/sys/priv/cmdline.c:    netwib_c_strcpy(argv[0], pcfind2+1);
./netw-ib-ox-ag_5.35.0/src/netwib-src/src/netwib/sys/priv/cmdline.c:    netwib_c_strcpy(argv[0], pcfind1+1);
./netw-ib-ox-ag_5.35.0/src/netwib-src/src/netwib/sys/priv/cmdline.c:      netwib_c_strcpy(argv[0], pcfind2+1);
./netw-ib-ox-ag_5.35.0/src/netwib-src/src/netwib/sys/priv/cmdline.c:      netwib_c_strcpy(argv[0], pcfind1+1);
./netw-ib-ox-ag_5.35.0/src/netwox-src/src/modules/cmdline.c:    netwib_c_strcpy(argv[0], filename);
./netw-ib-ox-ag_5.35.0/src/netwox-src/src/modules/cmdline.c:    netwib_c_strcpy(argv[0], pcfind2+1);
./netw-ib-ox-ag_5.35.0/src/netwox-src/src/modules/cmdline.c:    netwib_c_strcpy(argv[0], pcfind1+1);
./netw-ib-ox-ag_5.35.0/src/netwox-src/src/modules/cmdline.c:      netwib_c_strcpy(argv[0], pcfind2+1);
./netw-ib-ox-ag_5.35.0/src/netwox-src/src/modules/cmdline.c:      netwib_c_strcpy(argv[0], pcfind1+1);
./netw-ib-ox-ag_5.35.0/src/netwox-src/src/modules/tool/arg.c:      netwib_c_strcpy(pc, argv[i]);
./nexuiz-data_2.4.2/qcsrc/menu/nexuiz/maplist.c:				s = strcat(s, " ", argv(i));
./nfs-utils_1.1.2/tools/rpcdebug/rpcdebug.c:	strcpy(cdename, basename(argv[0]));
./nfs-utils_1.1.2/tools/rpcgen/rpc_main.c:					(void) strcpy(pathbuf, argv[i]);
./nis_3.17/debian/Old/domainname.c:	strcpy(buf, argv[1]);
./nosql_4.0.14/src/awktable.c:		strcat(prog, *argv);
./nosql_4.0.14/src/keysearch.c:		strcpy(tmpbuf, argv[i]);
./nosql_4.0.14/src/keysearch.c:		if (flags.sndx) strcat(tmpbuf, soundex(argv[i],sl,ct));
./nosql_4.0.14/src/keysearch.c:		else strcat(tmpbuf, argv[i]);
./nosql_4.0.14/src/keysearch.c:		   strcat(tmpbuf, argv[i+1]);	/* append table name */
./nosql_4.0.14/src/sorttable.c:  sprintf(tmpbuf, "sort");		/* init h.argv */
./nosql_4.0.14/src/uniontable.c:         strcpy(h_file, argv[i]);
./nosql_4.0.14/src/uniontable.c:       strcpy(h_file, argv[i]);
./nss_3.12.3.1/mozilla/security/nss/lib/sqlite/sqlite3.c:  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));
./nss_3.12.3.1/mozilla/security/nss/lib/sqlite/sqlite3.c:  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));
./nss_3.12.3.1/mozilla/security/nss/lib/sqlite/sqlite3.c:        strcpy(z, argv[i]);
./ntp_4.2.4p4+dfsg/ports/winnt/instsrv/instsrv.c:   strcpy(lpszExeName,argv[1]);
./nvi_1.81.6/common/main.c:			(void)strcpy(*argv, sp->frp->name);
./nvi_1.81.6/common/main.c:				(void)strcpy(argv[0], "-c$");
./nvi_1.81.6/common/main.c:				(void)strcpy(argv[0] + 2, p + 1);
./nvi_1.81.6/common/main.c:				(void)strcpy(argv[0], "-s");
./nvi_1.81.6/tcl_api/tcl.c:	strcpy(setting+5, argv[2]);
./nwrite_1.9.2/nwrite.c:		    strcat(usr->info.local->ttys->name, argv[optind]);
./nwrite_1.9.2/nwrite.c:                    strcat(usr->info.local->ttys->name, argv[optind]);
./nws_2.13/Interface/halt_activity.c:    sprintf(filter, "(&%s(%s=*%s*))", ACTIVITIES, NAME_ATTR, argv[optind]);
./nws_2.13/Interface/halt_activity.c:    strcpy(name, argv[optind]);
./nws_2.13/Interface/nws_cmd.c:		strcat(commandLine, argv[optind]);
./nws_2.13/Interface/nws_ctrl.c:		strcat(commandLine, argv[optind]);
./nws_2.13/Server/Nwslapd/nws_back_config.c:	 strcpy(nbc->ns_cookie.name, argv[1]);
./nws_2.13/Server/Nwslapd/nws_back_config.c:	  strcpy(nbc->forc_cookie.name, argv[1]);
./nxtvepg_2.7.6/epgui/epgmain.c:   sprintf(comm,   pUsageFmt, argv0, reason, argvn, argv0);
./nxtvepg_2.7.6/epgui/epgmain.c:   sprintf(comm, pUsageFmt, argv0, reason, argvn, argv0);
./nxtvepg_2.7.6/epgui/wmhooks.c:         sprintf(comm, "wm frame %s\n", argv[1]);
./nxtvepg_2.7.6/epgui/wmhooks.c:      sprintf(comm, "wm frame %s\n", argv[1]);
./nxtvepg_2.7.6/epgvbi/syserrmsg.c:            strcpy(*ppErrorText + off, argv[idx]);
./nxtvepg_2.7.6/epgvbi/winshmsrv.c:         strcpy(pLastErrorText + off, argv[idx]);
./nxtvepg_2.7.6/tcl2c.c:                    strcpy(optOutPrefix, argv[argIdx + 1]);
./nxtvepg_2.7.6/tvsim/winshmclnt.c:         strcpy(pLastErrorText + off, argv[idx]);
./nyquist_2.29/cmt/cmdline.c:            strcpy(argv[i], arg);
./nyquist_2.29/misc/cmdline.c:            strcpy((*argvp)[i], arg);
./ocaml_3.10.2/otherlibs/labltk/support/cltkEval.c:      strcpy(argv[where], merged);
./ocaml_3.10.2/yacc/main.c:      strcpy(file_prefix, argv[i]);
./ocp_0.1.15/filesel/adb.c:						strcpy(argv[argc], arc);
./ocp_0.1.15/filesel/adb.c:						strcat(argv[argc], arc);
./ocp_0.1.15/filesel/adb.c:						strcpy(argv[argc], name);
./ocp_0.1.15/filesel/adb.c:						strcat(argv[argc], name);
./ocp_0.1.15/filesel/adb.c:						strcpy(argv[argc], dir);
./ocp_0.1.15/filesel/adb.c:						strcat(argv[argc], dir);
./octaviz_0.4.7/Wrapping/vtkWrapOctave.c:    fprintf(fp,"    temp%i->command = strcpy(new char [strlen(argv[2])+1],argv[2]);\n",i);
./omake_0.9.8.5-3/src/clib/omake_shell_sys.c:            strcpy(argv + index, argp);
./omniorb4_4.1.2/src/tool/win32/clwrapper.c:	sprintf(tmp, "-Tp%s", argv[i]);
./omniorb4_4.1.2/src/tool/win32/libwrapper.c:	sprintf(tmp, "/OUT:%s", argv[i]);
./omniorb4_4.1.2/src/tool/win32/omake.c:    sprintf(tmp,"OMAKE_TARGET=%s",argv[argc-1]);
./oneko_1.2.sakura.6/oneko.c:	strcpy(theDisplayName, argv[ArgCounter]);
./openais_0.83/test/testcpg.c:		strcpy(group_name.value, argv[optind]);
./openarena_0.7.7+dfsg1/code/qcommon/cmd.c:		strcat( cmd_args, cmd_argv[i] );
./openarena_0.7.7+dfsg1/code/qcommon/cmd.c:		strcat( cmd_args, cmd_argv[i] );
./openarena_0.7.7+dfsg1/code/sys/sys_main.c:		Q_strcat( commandLine, sizeof( commandLine ), argv[ i ] );
./openarena_0.7.7+dfsg1/code/tools/asm/q3asm.c:			strcpy( outputFilename, argv[ i+1 ] );
./openswan_2.4.12+dfsg/programs/pluto/pluto_crypt.c:	sprintf(global_argv[0], "pluto helper %s #%3d   ", pluto_ifn_inst, n);
./openswan_2.4.12+dfsg/programs/pluto/pluto_crypt.c:	    sprintf(global_argv[0], "pluto helper %s #%3d (waiting for GDB) "
./openswan_2.4.12+dfsg/programs/pluto/pluto_crypt.c:	    sprintf(global_argv[0], "pluto helper %s #%3d                   "
./openswan_2.4.12+dfsg/programs/starter/starter.c:		    strcpy(configfile, argv[i+1]);
./openswan_2.4.12+dfsg/programs/starter/starter.c:		    strcpy(rootdir, argv[i+1]);
./opie_2.32/opiesu.c:    strcat(argvbuf, argv[i]);
./opie_2.32/opiesu.c:      strcat(argvbuf, " ");
./orbit_0.5.17/popt/findme.c:	sprintf(buf, "%s/%s", start, argv0);
./orbit_0.5.17/popt/poptparse.c:	dst += strlen(strcpy(dst, argv[i])) + 1;
./owl_2.1.8/commands.c:  sprintf(newbuff, "%s ", argv[0]);
./owl_2.1.8/commands.c:    strcat(newbuff, argv[i+1]);
./owl_2.1.8/global.c:    sprintf(g->startupargs, "%s%s ", g->startupargs, argv[i]);
./owl_2.1.8/util.c:      strcpy(argv[*argc], curarg);
./owl_2.1.8/zwrite.c:	strcat(z->message, myargv[0]);
./paje.app_1.97+cvs20080110/Tracers/JRastro/libRastro/src/rastro_write.c:                strcpy(rst_dirname, argv[++arg]);
./paraview_3.2.2/Utilities/IceT/tests/init.c:            sprintf(display, "DISPLAY=%s", argv[++arg]);
./paraview_3.2.2/VTK/Wrapping/vtkWrapTcl.c:    fprintf(fp,"    temp%i->command = strcpy(new char [strlen(argv[2])+1],argv[2]);\n",i);
./paraview_3.2.2/VTK/Wrapping/vtkWrapTcl.c:  fprintf(fp,"    char temps2[256];\n    sprintf(temps2,\"Object named: %%s, could not find requested method: %%s\\nor the method was called with incorrect arguments.\\n\",argv[0],argv[1]);\n    Tcl_AppendResult(interp,temps2,NULL);\n    }\n");
./pcal_4.10.0/src/pcal.c:   strcpy(progname, **argv ? *argv : "pcal");
./pcx_1.1.18/SRC/main.c:   strcpy(infile, argv[1]);
./pen_0.18.0/penctl.c:	strcpy(b, argv[1]);
./pen_0.18.0/penctl.c:	strcpy(b, argv[2]);
./pen_0.18.0/penctl.c:		strcat(b, argv[i]);
./perl_5.10.0/beos/nm.c:	if (!strcat(path, argv[1])) { printf("feh1\n"); exit(1); }
./perl_5.10.0/beos/nm.c:	if (!strcpy(path, argv[1])) { printf("gah!\n"); exit(1); }
./perl_5.10.0/NetWare/Nwpipe.c:		strcpy(ptpf->m_argv[dindex], ptpf->m_pipeCommand->m_argv[sindex]);
./perl_5.10.0/NetWare/Nwpipe.c:		strcpy(ptpf->m_argv[dindex], (char*) ptpf->m_redirect);
./perl_5.10.0/NetWare/NWUtil.c:			strcpy(new_argv[i], pclp->m_argv[i]);  // copy old arg strings
./perl_5.10.0/NetWare/NWUtil.c:	strcpy(pclp->m_argv[pclp->m_argc], new_arg);	// Appended the new argument.
./perl_5.10.0/NetWare/NWUtil.c:		strcpy(pclp->m_argv[i], pclp->m_argv[i+1]);
./perl_5.10.0/NetWare/NWUtil.c:		tptr += sprintf(tptr, (char *)"%s ", argv[k]);
./perl_5.10.0/vms/munchconfig.c:      strcpy(WorkString, argv[i]);
./perl_5.10.0/vms/vms.c:        strcpy(temp, PL_origargv[0]);
./perl_5.10.0/vms/vms.c:    strcat(command, argv[0]);
./perl_5.10.0/vms/vms.c:	strcat(command, *(++argv));
./perl_5.10.0/vms/vms.c:    strcpy(newargv[1], "-T");
./perl_5.10.0/vms/vms.c:	  strcat(vmscmd->dsc$a_pointer,image_argv);
./pfmon_3.2.070507/tests/forkexectest.c:	strcpy(fake_cmd+1, argv[0]);
./pgapack_1.1/source/cmdline.c:          strcpy(PGAProgram, *argv);
./pgplot5_5.2.2/pgdispd/resdb.c:	if ((progname=strrchr(argv[0],'/')) == NULL) strcpy(prog,argv[0]);
./pgpool2_1.3/pcp/pcp_attach_node.c:	strcpy(host, argv[2]);
./pgpool2_1.3/pcp/pcp_attach_node.c:	strcpy(user, argv[4]);
./pgpool2_1.3/pcp/pcp_attach_node.c:	strcpy(pass, argv[5]);
./pgpool2_1.3/pcp/pcp_detach_node.c:	strcpy(host, argv[2]);
./pgpool2_1.3/pcp/pcp_detach_node.c:	strcpy(user, argv[4]);
./pgpool2_1.3/pcp/pcp_detach_node.c:	strcpy(pass, argv[5]);
./pgpool2_1.3/pcp/pcp_node_count.c:	strcpy(host, argv[2]);
./pgpool2_1.3/pcp/pcp_node_count.c:	strcpy(user, argv[4]);
./pgpool2_1.3/pcp/pcp_node_count.c:	strcpy(pass, argv[5]);
./pgpool2_1.3/pcp/pcp_node_info.c:	strcpy(host, argv[2]);
./pgpool2_1.3/pcp/pcp_node_info.c:	strcpy(user, argv[4]);
./pgpool2_1.3/pcp/pcp_node_info.c:	strcpy(pass, argv[5]);
./pgpool2_1.3/pcp/pcp_proc_count.c:	strcpy(host, argv[2]);
./pgpool2_1.3/pcp/pcp_proc_count.c:	strcpy(user, argv[4]);
./pgpool2_1.3/pcp/pcp_proc_count.c:	strcpy(pass, argv[5]);
./pgpool2_1.3/pcp/pcp_proc_info.c:	strcpy(host, argv[2]);
./pgpool2_1.3/pcp/pcp_proc_info.c:	strcpy(user, argv[4]);
./pgpool2_1.3/pcp/pcp_proc_info.c:	strcpy(pass, argv[5]);
./pgpool2_1.3/pcp/pcp_stop_pgpool.c:	strcpy(host, argv[2]);
./pgpool2_1.3/pcp/pcp_stop_pgpool.c:	strcpy(user, argv[4]);
./pgpool2_1.3/pcp/pcp_stop_pgpool.c:	strcpy(pass, argv[5]);
./pgpool2_1.3/pcp/pcp_systemdb_info.c:	strcpy(host, argv[2]);
./pgpool2_1.3/pcp/pcp_systemdb_info.c:	strcpy(user, argv[4]);
./pgpool2_1.3/pcp/pcp_systemdb_info.c:	strcpy(pass, argv[5]);
./php5_5.2.6.dfsg.1/ext/pdo_sqlite/sqlite/src/func.c:  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));
./php5_5.2.6.dfsg.1/ext/pdo_sqlite/sqlite/src/func.c:  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));
./php5_5.2.6.dfsg.1/ext/pdo_sqlite/sqlite/src/shell.c:      sprintf(data.separator,"%.*s",(int)sizeof(data.separator)-1,argv[i]);
./php5_5.2.6.dfsg.1/ext/pdo_sqlite/sqlite/src/shell.c:      sprintf(data.nullvalue,"%.*s",(int)sizeof(data.nullvalue)-1,argv[i]);
./php5_5.2.6.dfsg.1/ext/pdo_sqlite/sqlite/src/table.c:        strcpy(z, argv[i]);
./php5_5.2.6.dfsg.1/ext/pdo_sqlite/sqlite/tool/lemon.c:    if( path ) sprintf(path,"%s/%s",argv0,name);
./php5_5.2.6.dfsg.1/ext/sqlite/libsqlite/src/func.c:    strcpy(p->z, argv[0]);
./php5_5.2.6.dfsg.1/ext/sqlite/libsqlite/src/table.c:        strcpy(z, argv[i]);
./php5_5.2.6.dfsg.1/regex/split.c:			(void) strcpy(buf, argv[1]);
./php5_5.2.6.dfsg.1/regex/split.c:			(void) strcpy(buf, argv[1]);
./picp_0.6.7/fixchksum/fixchksum.c:	strcpy(fname, argv[1]);
./pike7.6_7.6.112/src/dlopen.c:	strcpy(pdbname, argv[0]);
./pike7.6_7.6.112/src/smartlink.c:      strcat(buffer, argv[1]);
./pike7.6_7.6.112/src/smartlink.c:      strcat(buffer, argv[1]);
./pilot-link_0.12.3/popt/findme.c:	sprintf(buf, "%s/%s", start, argv0);
./pilot-link_0.12.3/popt/popt.c:	sprintf(s, "%s/%s", con->execPath, item->argv[0]);
./pilot-link_0.12.3/popt/poptparse.c:	dst += strlen(strcpy(dst, argv[i])) + 1;
./pilot-link_0.12.3/src/pilot-debug.c:        strcpy(buffer + 6, argv[1]);
./pilot-link_0.12.3/src/pilot-debug.c:        strcpy(laddr.pi_device, argv[1]);
./pimd_2.1.0-alpha29.17/main.c:		strcpy(configfilename, *argv);
./pkg-config_0.22/findme.c:	sprintf(buf, "%s/%s", start, argv0);
./pkg-config_0.22/popt.c:	sprintf(argv[pos], "%s/%s", con->execPath, script);
./player_2.0.4/utils/playervcr/playervcr.c:        strcpy(gui_data->hostname, argv[i]);
./ploticus_2.40/src/glroutines.c: * strcpy( buf, argv[1] );
./ploticus_2.40/src/pl.c:		sprintf( buf, "SCRIPT_FILENAME=%s", argv[0] );
./plt-scheme_4.0.1/src/mzscheme/src/struct.c:    sprintf(digitbuf, "field%d", (int)SCHEME_INT_VAL(argv[1]));
./plt-scheme_4.0.1/src/wxcommon/jpeg/wrjpgcom.c:	strcpy(comment_arg, argv[argn]+1);
./plt-scheme_4.0.1/src/wxcommon/jpeg/wrjpgcom.c:	  strcat(comment_arg, argv[argn]);
./pngcrush_1.6.7/pngcrush.c:            strcpy(iccp_name, argv[++i]);
./pngcrush_1.6.7/pngcrush.c:            strcpy(pplt_string, argv[i]);
./pngcrush_1.6.7/pngcrush.c:                strcpy(&text_keyword[text_inputs * 80], argv[++i]);
./pngcrush_1.6.7/pngcrush.c:                    strcpy(&text_lang[text_inputs * 80], argv[++i]);
./pngcrush_1.6.7/pngcrush.c:                    strcpy(&text_lang_key[text_inputs * 80], argv[++i]);
./pngcrush_1.6.7/pngcrush.c:                strcpy(&text_text[text_inputs * 2048], argv[++i]);
./pocketpc-gcc_3.4.2/gcc/fixinc/fixfixes.c:  strcpy( pz_tmptmp, argv[4] );
./policycoreutils_2.0.49/newrole/newrole.c:	if (asprintf(&shell_argv0, "-%s", pw.pw_shell) < 0) {
./povray_3.6.1/libraries/jpeg/wrjpgcom.c:	strcpy(comment_arg, argv[argn]+1);
./povray_3.6.1/libraries/jpeg/wrjpgcom.c:	  strcat(comment_arg, argv[argn]);
./povray_3.6.1/libraries/tiff/tools/tiff2bw.c:	sprintf(thing, "B&W version of %s", argv[optind]);
./povray_3.6.1/libraries/tiff/tools/tiffdither.c:	sprintf(thing, "Dithered B&W version of %s", argv[optind]);
./povray_3.6.1/libraries/tiff/tools/tiffsplit.c:		strcpy(fname, argv[2]);
./pppstatus_0.4.2/runonboot.c:		     sprintf(tty, "%s", argv[i+1]);
./pptpd_1.3.4/inststr.c:		strcpy(argv[0], src);
./pptp-linux_1.7.2/inststr.c:        strcpy(argv[0], src);
./psad_2.1.3/whois/whois.c:	    strcat(qstring, *argv++);
./psi_0.11/src/tools/zip/minizip/minizip.c:		strcpy(filename_try,argv[zipfilenamearg]);
./psmisc_22.6/src/fuser.c:				asprintf(&(this_name->filename), "%s/tcp", argv[optc]);
./psmisc_22.6/src/fuser.c:				asprintf(&(this_name->filename), "%s/udp", argv[optc]);
./pstotext_1.9/mkbundle.c:    strcpy(inbuf, argv[1]);
./pstotext_1.9/mkrch.c:    strcpy(inbuf, argv[1]);
./pulseaudio_0.9.10/src/utils/pactl.c:                    p += sprintf(p, "%s%s", p == module_args ? "" : " ", argv[i]);
./putty_0.60/unix/gtkwin.c:	    strcpy(data + p, pty_argv[i]);
./putty_0.60/windows/winutils.c:	    q = str + sprintf(str, "%s -splat ", argv[0]);
./putty_0.60/windows/winutils.c:			p = teststr + sprintf(teststr, "%s -split ", argv[0]);
./pwlib_1.10.10/src/ptlib/common/regex/split.c:			(void) strcpy(buf, argv[1]);
./pwlib_1.10.10/src/ptlib/common/regex/split.c:			(void) strcpy(buf, argv[1]);
./pyparallel_0.2/src/win32/loaddrv_console/loaddrv.c:            sprintf(path, "%s\\%s.sys", cwd, argv[2]);
./python2.4_2.4.6/Modules/getpath.c:    strcpy(prefix, argv0_path);
./python2.4_2.4.6/Modules/getpath.c:        strcpy(prefix, argv0_path);
./python2.4_2.4.6/Modules/getpath.c:    strcpy(exec_prefix, argv0_path);
./python2.4_2.4.6/Modules/_tkinter.c:	strcpy(argv0, className);
./python2.4_2.4.6/PC/getpathp.c:	strcpy(prefix, argv0_path);
./python2.4_2.4.6/PC/getpathp.c:	strcpy(argv0_path, progpath);
./python2.4_2.4.6/PC/getpathp.c:		strcpy(buf, argv0_path);
./python2.4_2.4.6/PC/os2emx/getpathp.c:	strcpy(prefix, argv0_path);
./python2.4_2.4.6/PC/os2emx/getpathp.c:	strcpy(argv0_path, progpath);
./python2.4_2.4.6/PC/os2emx/getpathp.c:		strcpy(buf, argv0_path);
./python2.4_2.4.6/PC/os2vacpp/getpathp.c:	strcpy(prefix, argv0_path);
./python2.4_2.4.6/PC/os2vacpp/getpathp.c:	strcpy(argv0_path, progpath);
./python2.4_2.4.6/PC/os2vacpp/getpathp.c:		strcpy(buf, argv0_path);
./python2.4_2.4.6/Python/sysmodule.c:					strcpy(argv0copy, argv0);
./python2.5_2.5.2/Modules/getpath.c:    strcpy(prefix, argv0_path);
./python2.5_2.5.2/Modules/getpath.c:        strcpy(prefix, argv0_path);
./python2.5_2.5.2/Modules/getpath.c:    strcpy(exec_prefix, argv0_path);
./python2.5_2.5.2/Modules/_tkinter.c:	strcpy(argv0, className);
./python2.5_2.5.2/PC/getpathp.c:	strcpy(prefix, argv0_path);
./python2.5_2.5.2/PC/getpathp.c:	strcpy(argv0_path, progpath);
./python2.5_2.5.2/PC/getpathp.c:		strcpy(buf, argv0_path);
./python2.5_2.5.2/PC/os2emx/getpathp.c:	strcpy(prefix, argv0_path);
./python2.5_2.5.2/PC/os2emx/getpathp.c:	strcpy(argv0_path, progpath);
./python2.5_2.5.2/PC/os2emx/getpathp.c:		strcpy(buf, argv0_path);
./python2.5_2.5.2/PC/os2vacpp/getpathp.c:	strcpy(prefix, argv0_path);
./python2.5_2.5.2/PC/os2vacpp/getpathp.c:	strcpy(argv0_path, progpath);
./python2.5_2.5.2/PC/os2vacpp/getpathp.c:		strcpy(buf, argv0_path);
./python2.5_2.5.2/Python/sysmodule.c:					strcpy(argv0copy, argv0);
./qstat_2.11/qstat.c:		sprintf( opt, "-%s", argv[arg]);
./qt4-x11_4.4.3/src/3rdparty/sqlite/sqlite3.c:    strcpy(z, argv[i]);
./qtads_1.7/tads2/ler.c:                sprintf(buf, "%d", argv[argi].erraint);
./qtads_1.7/tads2/ler.c:                sprintf(buf, "%u", argv[argi].erraint);
./radiance_3R9+20080530/src/cv/ies2rad.c:					strcat(units,argv[i]+3);
./radiance_3R9+20080530/src/cv/ies2rad.c:					strcat(units,argv[i]+3);
./radiance_3R9+20080530/src/cv/ies2rad.c:				strcat(units,argv[i]+3);
./radiance_3R9+20080530/src/cv/ies2rad.c:					strcat(units,argv[i]+3);
./radiance_3R9+20080530/src/cv/ies2rad.c:		tailtrunc(strcpy(outname,filename(argv[i])));
./radiance_3R9+20080530/src/cv/obj2rad.c:				strcpy(matname, argv[1]);
./radiance_3R9+20080530/src/cv/obj2rad.c:					sprintf(mapname, "%s.pic", argv[1]);
./radiance_3R9+20080530/src/cv/obj2rad.c:			strcpy(objname, argv[1]);
./radiance_3R9+20080530/src/cv/obj2rad.c:				strcpy(group[i-1], argv[i]);
./radiance_3R9+20080530/src/gen/genrev.c:	sprintf(stmp, "%s(t)=%s;", ZNAME, argv[3]);
./radiance_3R9+20080530/src/gen/genrev.c:	sprintf(stmp, "%s(t)=%s;", RNAME, argv[4]);
./radiance_3R9+20080530/src/gen/gensky.c:				sprintf(errmsg, "unknown option: %s", argv[i]);
./radiance_3R9+20080530/src/gen/gensurf.c:			sprintf(stmp, "%s(s,t)=%s;", XNAME, argv[3]);
./radiance_3R9+20080530/src/gen/gensurf.c:			sprintf(stmp, "%s(s,t)=%s;", YNAME, argv[4]);
./radiance_3R9+20080530/src/gen/gensurf.c:		sprintf(stmp, "%s(s,t)=%s;", XNAME, argv[3]);
./radiance_3R9+20080530/src/gen/gensurf.c:		sprintf(stmp, "%s(s,t)=%s;", YNAME, argv[4]);
./radiance_3R9+20080530/src/gen/gensurf.c:		sprintf(stmp, "%s(s,t)=%s;", ZNAME, argv[5]);
./radiance_3R9+20080530/src/gen/genworm.c:	sprintf(stmp, "%s(t)=%s;", XNAME, argv[3]);
./radiance_3R9+20080530/src/gen/genworm.c:	sprintf(stmp, "%s(t)=%s;", YNAME, argv[4]);
./radiance_3R9+20080530/src/gen/genworm.c:	sprintf(stmp, "%s(t)=%s;", ZNAME, argv[5]);
./radiance_3R9+20080530/src/gen/genworm.c:	sprintf(stmp, "%s(t)=%s;", RNAME, argv[6]);
./radiance_3R9+20080530/src/gen/mkillum.c:			sprintf(errmsg, "cannot expand '%s'", argv[i]);
./radiance_3R9+20080530/src/gen/mkillum.c:			sprintf(errmsg, "bad render option at '%s'", argv[i]);
./radiance_3R9+20080530/src/hd/rholo.c:			sprintf(errmsg, "unknown variable: %s", argv[i]);
./radiance_3R9+20080530/src/meta/igraph.c:		mgload(strcpy(curfile, argv[i]));
./radiance_3R9+20080530/src/meta/meta2bmp.c:	  strcpy(outname, *++argv);
./radiance_3R9+20080530/src/meta/meta2bmp.c:       strcat(comargs, *argv);
./radiance_3R9+20080530/src/meta/meta2tga.c:	  strcpy(outname, *++argv);
./radiance_3R9+20080530/src/meta/meta2tga.c:       strcat(comargs, *argv);
./radiance_3R9+20080530/src/meta/mtext.c:                sprintf(errmsg, "unknown option '%s'", *argv);
./radiance_3R9+20080530/src/meta/psort.c:          sprintf(errmsg, "unknown option \"%s\"", *argv);
./radiance_3R9+20080530/src/meta/xmeta.c:       strcat(comargs, *argv);
./radiance_3R9+20080530/src/ot/obj2mesh.c:			sprintf(errmsg, "unknown option: '%s'", argv[i]);
./radiance_3R9+20080530/src/ot/oconv.c:			sprintf(errmsg, "unknown option: '%s'", argv[i]);
./radiance_3R9+20080530/src/ot/wfconv.c:				strcpy(material, argv[1]);
./radiance_3R9+20080530/src/ot/wfconv.c:				strcpy(group, argv[1]);
./radiance_3R9+20080530/src/px/ra_t16.c:		sprintf(msg, "can't open input \"%s\"", argv[i]);
./radiance_3R9+20080530/src/px/ra_t16.c:		sprintf(msg, "can't open output \"%s\"", argv[i+1]);
./radiance_3R9+20080530/src/px/ra_t8.c:		sprintf(errmsg, "cannot open input \"%s\"", argv[i]);
./radiance_3R9+20080530/src/px/ra_t8.c:		sprintf(errmsg, "cannot open output \"%s\"", argv[i+1]);
./radiance_3R9+20080530/src/px/xshowtrace.c:		strcat(combuf, argv[i]);
./radiance_3R9+20080530/src/rt/rpmain.c:			sprintf(errmsg, "cannot expand '%s'", argv[i]);
./radiance_3R9+20080530/src/rt/rpmain.c:	sprintf(errmsg, "command line error at '%s'", argv[i]);
./radiance_3R9+20080530/src/rt/rtmain.c:			sprintf(errmsg, "cannot expand '%s'", argv[i]);
./radiance_3R9+20080530/src/rt/rtmain.c:	sprintf(errmsg, "command line error at '%s'", argv[i]);
./radiance_3R9+20080530/src/rt/rvmain.c:			sprintf(errmsg, "cannot expand '%s'", argv[i]);
./radiance_3R9+20080530/src/rt/rvmain.c:			strcpy(rifname, argv[++i]);
./radiance_3R9+20080530/src/rt/rvmain.c:	sprintf(errmsg, "command line error at '%s'", argv[i]);
./radiance_3R9+20080530/src/util/rsensor.c:			sprintf(errmsg, "cannot expand '%s'", argv[i]);
./radiance_3R9+20080530/src/util/rsensor.c:				sprintf(errmsg, "bad option at '%s'", argv[i]);
./radiance_3R9+20080530/src/util/rsensor.c:			sprintf(errmsg, "bad view option at '%s'", argv[i]);
./radiance_3R9+20080530/src/util/rsensor.c:			sprintf(errmsg, "bad render option at '%s'", argv[i]);
./radiusd-livingston_2.1/src/radtest.c:			strcpy(u_name,*argv);
./radiusd-livingston_2.1/src/radtest.c:			strcpy(u_passwd,*argv);
./readseq_1/macinit.c:  strcpy( targv[argc], sptr);  \
./readseq_1/readseq.c:        strcpy( inputfile, argv[ifile]);
./recordmydesktop_0.3.7.3/src/parseargs.c:            strcpy(arg_return->filename,argv[1]);
./recordmydesktop_0.3.7.3/src/parseargs.c:                strcpy(arg_return->display,argv[i+1]);
./recordmydesktop_0.3.7.3/src/parseargs.c:                strcpy(arg_return->filename,argv[i+1]);
./recordmydesktop_0.3.7.3/src/parseargs.c:                strcpy(arg_return->device,argv[i+1]);
./recordmydesktop_0.3.7.3/src/parseargs.c:                strcpy(arg_return->workdir,argv[i+1]);
./recordmydesktop_0.3.7.3/src/parseargs.c:                strcpy(arg_return->pause_shortcut,argv[i+1]);
./recordmydesktop_0.3.7.3/src/parseargs.c:                strcpy(arg_return->stop_shortcut,argv[i+1]);
./redhat-cluster_2.20081102/cman/tests/client.c:	strcpy(message, argv[2]);
./redhat-cluster_2.20081102/gfs/gfs_tool/misc.c:	sprintf(buf, "margs %s\n", argv[optind]);
./redhat-cluster_2.20081102/gfs2/convert/gfs2_convert.c:		strcpy(device, argv[optind]);
./redhat-cluster_2.20081102/gfs2/edit/hexedit.c:				strcpy(device, argv[i]);
./redhat-cluster_2.20081102/gfs2/mkfs/main_mkfs.c:		strcpy(sdp->device_name, argv[optind++]);
./redhat-cluster_2.20081102/group/daemon/main.c:	strcpy(client[ci].type, argv[1]);
./redhat-cluster_2.20081102/group/test/client.c:		strcat(buf, argv[i]);
./redhat-cluster_2.20081102/group/tool/main.c:	sprintf(outbuf, "plocks %s", argv[opt_ind + 1]);
./regina_3.3/doscmd.c:         strcat(new_cmdline, argv0);
./regina_3.3/doscmd.c:         strcpy(new_cmdline, argv0);
./regina_3.3/doscmd.c:               strcpy(new_cmdline, argv0);
./regina_3.3/doscmd.c:         strcpy(new_cmdline, argv0);
./remem_2.12/main/rmain.c:            sprintf(errorstring, "%s is not a valid docnum\n", argv[i]);
./rlpr_2.05/src/rlprm.c:	strcat(request, argv[i]);
./rman_3.2/rman.c:		strcpy(plain,argvch[optind]);
./rnahybrid_2.1/src/rnacalibrate.c:    strcpy(query_sq,argv[argc-1]);
./rnahybrid_2.1/src/rnacalibrate.c:    strcpy(target_sq,argv[argc-1-(!qflag)]);
./rnahybrid_2.1/src/rnaeffective.c:    strcpy(query_sq,argv[argc-1]);
./rnahybrid_2.1/src/rnaeffective.c:    strcpy(target_sq,argv[argc-1-(!qflag)]);
./rnahybrid_2.1/src/rnahybrid.c:    strcpy(query_sq,argv[argc-1]);
./rnahybrid_2.1/src/rnahybrid.c:    strcpy(target_sq,argv[argc-1]);
./rnahybrid_2.1/src/rnahybrid.c:    strcpy(target_sq,argv[argc-2]);
./rnahybrid_2.1/src/rnahybrid.c:    strcpy(query_sq,argv[argc-1]);
./root-system_5.18.00/cint7/lib/WildCard/TclIns.c:    sprintf(p,"%s ",argv[i]);
./root-system_5.18.00/cint7/lib/WildCard/TclIns.c:    sprintf(p,"%s ",argv[i]);
./root-system_5.18.00/cint7/lib/WildCard/WildCard.c:    sprintf(p,"%s ",argv[i]);
./root-system_5.18.00/cint7/lib/WildCard/WildCard.c:    sprintf(p,"%s ",argv[i]);
./root-system_5.18.00/cint7/lib/WildCard/WildCard.c:    sprintf(p,"%s ",argv[i]);
./root-system_5.18.00/cint7/lib/wintcldl/cintlib.c:    sprintf(p,"%s ",argv[i]);
./root-system_5.18.00/cint7/lib/wintcldl/cintlib.c:    sprintf(p,"%s ",argv[i]);
./root-system_5.18.00/cint7/lib/wintcldl83/cintlib.c:    sprintf(p,"%s ",argv[i]);
./root-system_5.18.00/cint7/lib/wintcldl83/cintlib.c:    sprintf(p,"%s ",argv[i]);
./root-system_5.18.00/cint7/tool/cxx2cpp.c:      strcpy(buf,argv[i]);
./rsrce_0.2.2/command.c:		strcpy(cmd_ifname, argv[1]);
./rsrce_0.2.2/command.c:		strcpy(cmd_ofname, argv[1]);
./ruby1.8_1.8.7.72/ext/syslog/syslog.c:    str = rb_f_sprintf(argc, argv);
./ruby1.8_1.8.7.72/io.c:    rb_io_write(out, rb_f_sprintf(argc, argv));
./ruby1.8_1.8.7.72/io.c:    rb_io_write(out, rb_f_sprintf(argc, argv));
./ruby1.8_1.8.7.72/process.c:	    new_argv[1] = strcpy(ALLOCA_N(char, strlen(argv[0]) + 1), argv[0]);
./ruby1.8_1.8.7.72/process.c:	new_argv[1] = strcpy(ALLOCA_N(char, strlen(argv[0]) + 1), argv[0]);
./ruby1.8_1.8.7.72/sprintf.c:rb_f_sprintf(argc, argv)
./ruby1.9_1.9.0.2/ext/syslog/syslog.c:    str = rb_f_sprintf(argc, argv);
./ruby1.9_1.9.0.2/io.c:    rb_io_write(out, rb_f_sprintf(argc, argv));
./ruby1.9_1.9.0.2/io.c:    rb_io_write(out, rb_f_sprintf(argc, argv));
./ruby1.9_1.9.0.2/process.c:	    new_argv[1] = strcpy(ALLOCA_N(char, strlen(argv[0]) + 1), argv[0]);
./ruby1.9_1.9.0.2/process.c:	new_argv[1] = strcpy(ALLOCA_N(char, strlen(argv[0]) + 1), argv[0]);
./ruby1.9_1.9.0.2/sprintf.c:rb_f_sprintf(int argc, const VALUE *argv)
./ruby-gnome2_0.17.0~rc1/glib/src/rbglib_iochannel.c:    ioc_write_chars(self, rb_f_sprintf(argc, argv));
./rvm_1.15+debian/rvm/rvmutl.c:                (void)strcat(sw,argv[args]);
./sac_1.9b5/sac.c:	    sprintf(buf,"%s/%s/%s",RADIUS_DIR,argv[i],DETAIL_NAME);
./sam_4.3/sam/sam.c:			strcpy(*argv+1, *argv+2);
./scilab_4.1.2/imp/SEpsf.c:      strcpy(file1,argv[1]);
./scilab_4.1.2/imp/SEpsf.c:      strcpy(file1,argv[2]);
./scilab_4.1.2/imp/Slatexpr.c:      strcpy(file1,argv[3]);
./scilab_4.1.2/imp/Slatexpr.c:      strcpy(file1,argv[4]);
./scilab_4.1.2/imp/Slatexpr2.c:  sprintf(filename1,"%s.ps",argv[1]);
./scilab_4.1.2/imp/Slatexprs.c:  sprintf(filename1,"%s.ps",argv[1]);
./scilab_4.1.2/macros/Forwin.c:   strcpy(fname,argv[1]);  fname[strlen(fname)]= '\0';
./scilab_4.1.2/macros/Forwin.c:  strcpy(fname,argv[2]);  fname[strlen(fname)]= '\0';
./scilab_4.1.2/macros/Gengatsce.c:  strcpy(fname,argv[4]);
./scilab_4.1.2/macros/Gengatsce.c:  strcpy(fname,argv[3]);
./scilab_4.1.2/macros/Gengatsce.c:  strcpy(fname,argv[1]);
./scilab_4.1.2/macros/Gengatsce.c:  strcpy(fname,argv[3]);
./scilab_4.1.2/macros/Gengatsce.c:  strcpy(fname,argv[2]);
./scilab_4.1.2/macros/Gensomex.c:  strcpy(fname,argv[2]);
./scilab_4.1.2/macros/Gensomex.c:  strcpy(fname,argv[1]);
./scilab_4.1.2/macros/Gensomex.c:  strcpy(fname,argv[1]);
./scilab_4.1.2/macros/Gensosce.c:  strcpy(fname,argv[2]);
./scilab_4.1.2/macros/Gensosce.c:  strcpy(fname,argv[1]);
./scilab_4.1.2/macros/Lib.c:  strcpy(fname,argv[1]);
./scilab_4.1.2/macros/Name.c:  strcpy(fname,argv[1]);
./scilab_4.1.2/macros/Tomake.c:  strcpy(fname,argv[narg]); fname[strlen(fname)]= '\0';
./scilab_4.1.2/macros/Tomake.c:  strcpy(fname,argv[1]);  fname[strlen(fname)]= '\0';
./scilab_4.1.2/macros/Tomake.c:  strcpy(fname,argv[2]); fname[strlen(fname)]= '\0';
./scilab_4.1.2/macros/Tomake.c:  strcpy(fname,argv[2]); fname[strlen(fname)]= '\0';
./scilab_4.1.2/macros/Tomake.c:  strcpy(fname,argv[3]); fname[strlen(fname)]= '\0';
./scilab_4.1.2/macros/Tomake.c:  strcpy(fname,argv[2]); fname[strlen(fname)]= '\0';
./scilab_4.1.2/macros/Tomake.c:  strcpy(fname,argv[3]); fname[strlen(fname)]= '\0';
./scilab_4.1.2/macros/Tomake.c:  strcpy(fname,argv[4]); fname[strlen(fname)]= '\0';
./scilab_4.1.2/macros/Tomake.c:  strcpy(fname,argv[2]); fname[strlen(fname)]= '\0';
./scilab_4.1.2/macros/Tomake.c:  strcpy(fname,argv[3]); fname[strlen(fname)]= '\0';
./scilab_4.1.2/macros/Tomake.c:  strcpy(fname,argv[4]); fname[strlen(fname)]= '\0';
./scilab_4.1.2/macros/Tomake.c:  strcpy(fname,argv[5]); fname[strlen(fname)]= '\0';
./scilab_4.1.2/pvm3/src/pvmd.c:					strcpy(username,argv[i]);
./scilab_4.1.2/pvm3/src/pvmd.c:					if (strcmp(strcat("-u",username),argv[i])) {
./scilab_4.1.2/pvm3/src/pvmd.c:			strcpy(fixedargv,argv[0]);
./scilab_4.1.2/pvm3/src/pvmd.c:			strcat(fixedargv," ");
./scilab_4.1.2/pvm3/src/pvmd.c:				strcat(fixedargv,argv[i]);
./scilab_4.1.2/pvm3/src/pvmd.c:				strcat(fixedargv," ");
./scilab_4.1.2/pvm3/src/pvmdunix.c:	strcpy(filename,wxp->w_argv[0]);
./scilab_4.1.2/pvm3/src/pvmdunix.c:			strcpy(wxp->w_argv[0],filename);
./scilab_4.1.2/routines/gtksci/x_main.c:      strcpy(argv[i],buf);
./scilab_4.1.2/routines/os_specific/link_SYSV.c:    strcpy(argv[1],Use_c_cpp);
./scilab_4.1.2/routines/wsci/winmain.c:			strcpy(FileName,my_argv[2]);
./scilab_4.1.2/routines/wsci/winmain.c:				strcat(FileName,my_argv[j]);
./scilab_4.1.2/routines/wsci/winmain.c:		strcpy(ArgTmp,my_argv[argcount]);
./scilab_4.1.2/routines/xsci/x_main.c:      strcpy(argv[i],buf);
./scilab_4.1.2/Win-util/Nm/winDumpExts.c:		strcpy(&cmdline[pos], argv[i]);
./sdcc-nf_2.8.0/as/xa51/xa_main.c:  strcpy(infilename, argv[i]);
./sdcc-nf_2.8.0/debugger/mcs51/sdcdb.c:                    strcat(strcat(strcpy(p,&argv[i][12]),":"),ssdirl);
./sdcc-nf_2.8.0/support/librarian/sdcclib.c:                        strcpy(LibName, argv[j]);
./sdcc-nf_2.8.0/support/librarian/sdcclib.c:                        strcpy(ListName, argv[j]);
./sdcc-nf_2.8.0/support/librarian/sdcclib.c:                        strcpy(RelName[0], argv[j]);
./sdcc-nf_2.8.0/support/librarian/sdcclib.c:                    strcpy(RelName[NumRelFiles-1], argv[j]);
./sdcc-nf_2.8.0/support/scripts/mh2h.c:    strcpy(inc_dir, argv[1]);
./sdcc-nf_2.8.0/support/scripts/mh2h.c:    strcpy(bin_dir, argv[2]);
./sdcc-nf_2.8.0/support/Util/findme.c:	sprintf(buf, "%s/%s", start, argv0);
./sdl-ttf2.0_2.0.9/showfont.c:	sprintf(string, "Font file: %s", argv[0]);  /* possible overflow */
./seesat5_0.90.10-1.1/cr.c:	strcpy(option,argv[1]);
./seesat5_0.90.10-1.1/cr.c:	strcpy(in_name,argv[2]);
./seesat5_0.90.10-1.1/cr.c:	strcpy(out_name,argv[3]);
./seesat5_0.90.10-1.1/driver.c:	      strcat(cmdline_buff,argv[cmdline_ct]);
./sgf2dg_4.026/sgfsplit.c:    strcat(extra_args,argv[i]);
./shell-fm_0.4+svn20071125.r282/src/http.c:					pos += sprintf(& url[pos], "%d", va_arg(argv, int));
./shell-fm_0.4+svn20071125.r282/src/http.c:					pos += sprintf(& url[pos], "%u", va_arg(argv, unsigned));
./silc-client_1.1.4/apps/irssi/src/lib-popt/findme.c:	sprintf(buf, "%s/%s", start, argv0);
./sipcrack_0.2/SIPcrack.c:  strcpy(dump_file, argv[0]);
./sipcrack_0.2/SIPdump.c:  strcpy(dump_file, argv[0]);
./sirc_2.211/ssfe.c:      strcat(tmpstr, argv[i]);
./skencil_0.6.17/Pax/paxtkinter.c:	strcpy(argv0, className);
./skinedit_1.26/man/cleaner.c:  strcpy(filename, argv[1]);
./slashem_0.0.7E7F3/sys/msdos/bmp2txt.c:	if (has_index) sprintf(filename, argv[1]);
./slashem_0.0.7E7F3/sys/msdos/idx2bmp.c:	if (has_index) sprintf(filename, argv[1]);
./slashem_0.0.7E7F3/sys/msdos/idx2bmp.c:	if (has_output) sprintf(filename, argv[2]);
./slashem_0.0.7E7F3/util/dgn_main.c:		fname = strcpy(infile, argv[i]);
./slashem_0.0.7E7F3/win/gem/tile2img.c:		strcpy(bmpname, argv[1]);
./slashem_0.0.7E7F3/win/proxy/test_com.c:    sprintf(cmdline, "%s -c", argv0);
./slashem_0.0.7E7F3/win/share/tile2bmp.c:		strcpy(bmpname, argv[1]);
./slony1_1.2.15/src/slon/port/win32service.c:	strcpy(running_servicename, argv[0]);
./slurm-llnl_1.3.6/src/api/pmi.c:		strcpy(temp[j].val, argv[i]);
./slurm-llnl_1.3.6/src/api/pmi.c:			strcpy(temp[j].key, argv[i]);
./slurm-llnl_1.3.6/src/api/pmi.c:				strcpy(temp[j].val, argv[i]);
./slurm-llnl_1.3.6/src/scontrol/update_node.c:				strcpy(reason_str, &argv[i][8]);
./slurm-llnl_1.3.6/src/scontrol/update_node.c:				strcpy(reason_str, &argv[i][7]);
./slurm-llnl_1.3.6/src/slurmctld/job_mgr.c:				xstrcat(cmd_line, detail_ptr->argv[i]);
./slurm-llnl_1.3.6/testsuite/slurm_unit/api/manual/cancel-tst.c:			sprintf(msg, "slurm_kill_job(%.12s)",argv[i]);
./slurm-llnl_1.3.6/testsuite/slurm_unit/api/manual/complete-tst.c:			sprintf(msg, "slurm_complete_job(%.12s)",argv[i]);
./slurm-llnl_1.3.6/testsuite/slurm_unit/common/runqsw.c:		sprintf(cmdbuf + strlen(cmdbuf), "%s ", argv[optind++]);
./smartlist_3.15/src/manconf.c:   { sprintf(filebuf,"%s.%04d",*gargv,filecount++);freopen(filebuf,"w",stdout);
./smsclient_2.0.8z-10/src/client/sms_client.c:			strcpy(message[i - mind], argv[i]);
./smsclient_2.0.8z-10/src/driver/mtn_webtmp.c:	sprintf(num, "%%2B%s", argv[1]);
./smsclient_2.0.8z-10/src/driver/test.c:	strcpy(ipaddress, argv[1]);
./snoopy_1.3/snoopy.c:	   spos += sprintf(logstring+spos, "%s ", *(argv+i));
./sopwith_1.7.1/src/swinit.c:				strcpy(asynhost, argv[i]);
./sortmail_2.4/sortmail.c:	strcpy(*argv, "pop") ;
./spellcast_1.0/main.c:		strcpy(displist[numplayers], argv[ix]);
./spooles_2.2/Eigen/drivers/testMPI.c:   sprintf(buffer, "%s.%d", argv[2], myid) ;
./spooles_2.2/LinSol/drivers/testWrapperMPI.c:   sprintf(buffer, "%s.%d", argv[2], myid) ;
./spooles_2.2/MPI/drivers/testGather.c:   sprintf(buffer, "%s.%d", argv[2], myid) ;
./spooles_2.2/MPI/drivers/testGraph_Bcast.c:   sprintf(buffer, "%s.%d", argv[2], myid) ;
./spooles_2.2/MPI/drivers/testGridMPI.c:   sprintf(buffer, "%s.%d", argv[2], myid) ;
./spooles_2.2/MPI/drivers/testIVL_allgather.c:   sprintf(buffer, "%s.%d", argv[2], myid) ;
./spooles_2.2/MPI/drivers/testIVL_alltoall.c:   sprintf(buffer, "%s.%d", argv[2], myid) ;
./spooles_2.2/MPI/drivers/testIVL_Bcast.c:   sprintf(buffer, "%s.%d", argv[2], myid) ;
./spooles_2.2/MPI/drivers/testIV_allgather.c:   sprintf(buffer, "%s.%d", argv[2], myid) ;
./spooles_2.2/MPI/drivers/testMMM.c:   sprintf(buffer, "%s.%d", argv[2], myid) ;
./spooles_2.2/MPI/drivers/testScatterDenseMtx.c:   sprintf(buffer, "%s.%d", argv[2], myid) ;
./spooles_2.2/MPI/drivers/testScatterInpMtx.c:   sprintf(buffer, "%s.%d", argv[2], myid) ;
./spooles_2.2/MPI/drivers/testSplitDenseMtx.c:   sprintf(buffer, "%s.%d", argv[2], myid) ;
./spooles_2.2/MPI/drivers/testSplitInpMtx.c:   sprintf(buffer, "%s.%d", argv[2], myid) ;
./spooles_2.2/MPI/drivers/testSymbFac.c:   sprintf(buffer, "%s.%d", argv[2], myid) ;
./spread_3.17.4/flooder.c:                        strcpy( User, argv[1] );
./spread_3.17.4/flooder.c:                        strcpy( Spread_name, argv[1] ); 
./spread_3.17.4/monitor.c:			strcpy( Config_file, argv[1] );
./spread_3.17.4/simple_user.c:			strcpy( User, argv[1] );
./spread_3.17.4/simple_user.c:			strcpy( Spread_name, argv[1] ); 
./spread_3.17.4/spread.c:			strcpy( Config_file, argv[1] );
./spread_3.17.4/user.c:                        strcpy( User, argv[1] );
./spread_3.17.4/user.c:			strcpy( Spread_name, argv[1] ); 
./spread_3.17.4/user.c:			strcpy( Pword_username, argv[1] ); 
./spread_3.17.4/user.c:			strcpy( Pword_password, argv[1] ); 
./sqlite_2.8.17/src/func.c:    strcpy(p->z, argv[0]);
./sqlite_2.8.17/src/shell.c:      sprintf(data.separator,"%.*s",(int)sizeof(data.separator)-1,argv[i]);
./sqlite_2.8.17/src/shell.c:      sprintf(data.nullvalue,"%.*s",(int)sizeof(data.nullvalue)-1,argv[i]);
./sqlite_2.8.17/src/table.c:        strcpy(z, argv[i]);
./sqlite_2.8.17/tool/lemon.c:    if( path ) sprintf(path,"%s/%s",argv0,name);
./sqlite3_3.5.9/ext/fts1/fts1.c:    strcpy(z, argv[i]);
./sqlite3_3.5.9/ext/fts2/fts2.c:    strcpy(z, argv[i]);
./sqlite3_3.5.9/ext/fts3/fts3.c:    strcpy(z, argv[i]);
./sqlite3_3.5.9/tool/lemon.c:    if( path ) sprintf(path,"%s/%s",argv0,name);
./sqlitebrowser_1.3/sqlitebrowser/sqlite_source/attach.c:/*** 2003 April 6**** The author disclaims copyright to this source code.  In place of** a legal notice, here is a blessing:****    May you do good and not evil.**    May you find forgiveness for yourself and forgive others.**    May you share freely, never taking more than you give.***************************************************************************** This file contains code used to implement the ATTACH and DETACH commands.**** $Id: attach.c,v 1.7 2006/05/04 13:48:36 tabuleiro Exp $*/#include "sqliteInt.h"/*** Resolve an expression that was part of an ATTACH or DETACH statement. This** is slightly different from resolving a normal SQL expression, because simple** identifiers are treated as strings, not possible column names or aliases.**** i.e. if the parser sees:****     ATTACH DATABASE abc AS def**** it treats the two expressions as literal strings 'abc' and 'def' instead of** looking for columns of the same name.**** This only applies to the root node of pExpr, so the statement:****     ATTACH DATABASE abc||def AS 'db2'**** will fail because neither abc or def can be resolved.*/static int resolveAttachExpr(NameContext *pName, Expr *pExpr){  int rc = SQLITE_OK;  if( pExpr ){    if( pExpr->op!=TK_ID ){      rc = sqlite3ExprResolveNames(pName, pExpr);    }else{      pExpr->op = TK_STRING;    }  }  return rc;}/*** An SQL user-function registered to do the work of an ATTACH statement. The** three arguments to the function come directly from an attach statement:****     ATTACH DATABASE x AS y KEY z****     SELECT sqlite_attach(x, y, z)**** If the optional "KEY z" syntax is omitted, an SQL NULL is passed as the** third argument.*/static void attachFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  int i;  int rc = 0;  sqlite3 *db = sqlite3_user_data(context);  const char *zName;  const char *zFile;  Db *aNew;  char zErr[128];  char *zErrDyn = 0;  zFile = (const char *)sqlite3_value_text(argv[0]);  zName = (const char *)sqlite3_value_text(argv[1]);  /* Check for the following errors:  **  **     * Too many attached databases,  **     * Transaction currently open  **     * Specified database name already being used.  */  if( db->nDb>=MAX_ATTACHED+2 ){    sqlite3_snprintf(      127, zErr, "too many attached databases - max %d", MAX_ATTACHED    );    goto attach_error;  }  if( !db->autoCommit ){    strcpy(zErr, "cannot ATTACH database within transaction");    goto attach_error;  }  for(i=0; i<db->nDb; i++){    char *z = db->aDb[i].zName;    if( z && sqlite3StrICmp(z, zName)==0 ){      sqlite3_snprintf(127, zErr, "database %s is already in use", zName);      goto attach_error;    }  }  /* Allocate the new entry in the db->aDb[] array and initialise the schema  ** hash tables.  */  if( db->aDb==db->aDbStatic ){    aNew = sqliteMalloc( sizeof(db->aDb[0])*3 );    if( aNew==0 ){      return;    }    memcpy(aNew, db->aDb, sizeof(db->aDb[0])*2);  }else{    aNew = sqliteRealloc(db->aDb, sizeof(db->aDb[0])*(db->nDb+1) );    if( aNew==0 ){      return;    }   }  db->aDb = aNew;  aNew = &db->aDb[db->nDb++];  memset(aNew, 0, sizeof(*aNew));  /* Open the database file. If the btree is successfully opened, use  ** it to obtain the database schema. At this point the schema may  ** or may not be initialised.  */  rc = sqlite3BtreeFactory(db, zFile, 0, MAX_PAGES, &aNew->pBt);  if( rc==SQLITE_OK ){    aNew->pSchema = sqlite3SchemaGet(aNew->pBt);    if( !aNew->pSchema ){      rc = SQLITE_NOMEM;    }else if( aNew->pSchema->file_format && aNew->pSchema->enc!=ENC(db) ){      strcpy(zErr,         "attached databases must use the same text encoding as main database");      goto attach_error;    }  }  aNew->zName = sqliteStrDup(zName);  aNew->safety_level = 3;#if SQLITE_HAS_CODEC  {    extern int sqlite3CodecAttach(sqlite3*, int, void*, int);    extern void sqlite3CodecGetKey(sqlite3*, int, void**, int*);    int nKey;    char *zKey;    int t = sqlite3_value_type(argv[2]);    switch( t ){      case SQLITE_INTEGER:      case SQLITE_FLOAT:        zErrDyn = sqliteStrDup("Invalid key value");        rc = SQLITE_ERROR;        break;              case SQLITE_TEXT:      case SQLITE_BLOB:        nKey = sqlite3_value_bytes(argv[2]);        zKey = (char *)sqlite3_value_blob(argv[2]);        sqlite3CodecAttach(db, db->nDb-1, zKey, nKey);        break;      case SQLITE_NULL:        /* No key specified.  Use the key from the main database */        sqlite3CodecGetKey(db, 0, (void**)&zKey, &nKey);        sqlite3CodecAttach(db, db->nDb-1, zKey, nKey);        break;    }  }#endif  /* If the file was opened successfully, read the schema for the new database.  ** If this fails, or if opening the file failed, then close the file and   ** remove the entry from the db->aDb[] array. i.e. put everything back the way  ** we found it.  */  if( rc==SQLITE_OK ){    sqlite3SafetyOn(db);    rc = sqlite3Init(db, &zErrDyn);    sqlite3SafetyOff(db);  }  if( rc ){    int iDb = db->nDb - 1;    assert( iDb>=2 );    if( db->aDb[iDb].pBt ){      sqlite3BtreeClose(db->aDb[iDb].pBt);      db->aDb[iDb].pBt = 0;      db->aDb[iDb].pSchema = 0;    }    sqlite3ResetInternalSchema(db, 0);    db->nDb = iDb;    if( rc==SQLITE_NOMEM ){      sqlite3MallocFailed();      sqlite3_snprintf(127, zErr, "out of memory");    }else{      sqlite3_snprintf(127, zErr, "unable to open database: %s", zFile);    }    goto attach_error;  }    return;attach_error:  /* Return an error if we get here */  if( zErrDyn ){    sqlite3_result_error(context, zErrDyn, -1);    sqliteFree(zErrDyn);  }else{    zErr[sizeof(zErr)-1] = 0;    sqlite3_result_error(context, zErr, -1);  }}/*** An SQL user-function registered to do the work of an DETACH statement. The** three arguments to the function come directly from a detach statement:****     DETACH DATABASE x****     SELECT sqlite_detach(x)*/static void detachFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  const char *zName = (const char *)sqlite3_value_text(argv[0]);  sqlite3 *db = sqlite3_user_data(context);  int i;  Db *pDb = 0;  char zErr[128];  assert(zName);  for(i=0; i<db->nDb; i++){    pDb = &db->aDb[i];    if( pDb->pBt==0 ) continue;    if( sqlite3StrICmp(pDb->zName, zName)==0 ) break;  }  if( i>=db->nDb ){    sqlite3_snprintf(sizeof(zErr), zErr, "no such database: %s", zName);    goto detach_error;  }  if( i<2 ){    sqlite3_snprintf(sizeof(zErr), zErr, "cannot detach database %s", zName);    goto detach_error;  }  if( !db->autoCommit ){    strcpy(zErr, "cannot DETACH database within transaction");    goto detach_error;  }  sqlite3BtreeClose(pDb->pBt);  pDb->pBt = 0;  pDb->pSchema = 0;  sqlite3ResetInternalSchema(db, 0);  return;detach_error:  sqlite3_result_error(context, zErr, -1);}/*** This procedure generates VDBE code for a single invocation of either the** sqlite_detach() or sqlite_attach() SQL user functions.*/static void codeAttach(  Parse *pParse,       /* The parser context */  int type,            /* Either SQLITE_ATTACH or SQLITE_DETACH */  const char *zFunc,   /* Either "sqlite_attach" or "sqlite_detach */  int nFunc,           /* Number of args to pass to zFunc */  Expr *pAuthArg,      /* Expression to pass to authorization callback */  Expr *pFilename,     /* Name of database file */  Expr *pDbname,       /* Name of the database to use internally */  Expr *pKey           /* Database key for encryption extension */){  int rc;  NameContext sName;  Vdbe *v;  FuncDef *pFunc;  sqlite3* db = pParse->db;#ifndef SQLITE_OMIT_AUTHORIZATION  assert( sqlite3MallocFailed() || pAuthArg );  if( pAuthArg ){    char *zAuthArg = sqlite3NameFromToken(&pAuthArg->span);    if( !zAuthArg ){      goto attach_end;    }    rc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0);    sqliteFree(zAuthArg);    if(rc!=SQLITE_OK ){      goto attach_end;    }  }#endif /* SQLITE_OMIT_AUTHORIZATION */  memset(&sName, 0, sizeof(NameContext));  sName.pParse = pParse;  if(       SQLITE_OK!=(rc = resolveAttachExpr(&sName, pFilename)) ||      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pDbname)) ||      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pKey))  ){    pParse->nErr++;    goto attach_end;  }  v = sqlite3GetVdbe(pParse);  sqlite3ExprCode(pParse, pFilename);  sqlite3ExprCode(pParse, pDbname);  sqlite3ExprCode(pParse, pKey);  assert( v || sqlite3MallocFailed() );  if( v ){    sqlite3VdbeAddOp(v, OP_Function, 0, nFunc);    pFunc = sqlite3FindFunction(db, zFunc, strlen(zFunc), nFunc, SQLITE_UTF8,0);    sqlite3VdbeChangeP3(v, -1, (char *)pFunc, P3_FUNCDEF);    /* Code an OP_Expire. For an ATTACH statement, set P1 to true (expire this    ** statement only). For DETACH, set it to false (expire all existing    ** statements).    */    sqlite3VdbeAddOp(v, OP_Expire, (type==SQLITE_ATTACH), 0);  }  attach_end:  sqlite3ExprDelete(pFilename);  sqlite3ExprDelete(pDbname);  sqlite3ExprDelete(pKey);}/*** Called by the parser to compile a DETACH statement.****     DETACH pDbname*/void sqlite3Detach(Parse *pParse, Expr *pDbname){  codeAttach(pParse, SQLITE_DETACH, "sqlite_detach", 1, pDbname, 0, 0, pDbname);}/*** Called by the parser to compile an ATTACH statement.****     ATTACH p AS pDbname KEY pKey*/void sqlite3Attach(Parse *pParse, Expr *p, Expr *pDbname, Expr *pKey){  codeAttach(pParse, SQLITE_ATTACH, "sqlite_attach", 3, p, p, pDbname, pKey);}/*** Register the functions sqlite_attach and sqlite_detach.*/void sqlite3AttachFunctions(sqlite3 *db){  static const int enc = SQLITE_UTF8;  sqlite3CreateFunc(db, "sqlite_attach", 3, enc, db, attachFunc, 0, 0);  sqlite3CreateFunc(db, "sqlite_detach", 1, enc, db, detachFunc, 0, 0);}/*** Initialize a DbFixer structure.  This routine must be called prior** to passing the structure to one of the sqliteFixAAAA() routines below.**** The return value indicates whether or not fixation is required.  TRUE** means we do need to fix the database references, FALSE means we do not.*/int sqlite3FixInit(  DbFixer *pFix,      /* The fixer to be initialized */  Parse *pParse,      /* Error messages will be written here */  int iDb,            /* This is the database that must be used */  const char *zType,  /* "view", "trigger", or "index" */  const Token *pName  /* Name of the view, trigger, or index */){  sqlite3 *db;  if( iDb<0 || iDb==1 ) return 0;  db = pParse->db;  assert( db->nDb>iDb );  pFix->pParse = pParse;  pFix->zDb = db->aDb[iDb].zName;  pFix->zType = zType;  pFix->pName = pName;  return 1;}/*** The following set of routines walk through the parse tree and assign** a specific database to all table references where the database name** was left unspecified in the original SQL statement.  The pFix structure** must have been initialized by a prior call to sqlite3FixInit().**** These routines are used to make sure that an index, trigger, or** view in one database does not refer to objects in a different database.** (Exception: indices, triggers, and views in the TEMP database are** allowed to refer to anything.)  If a reference is explicitly made** to an object in a different database, an error message is added to** pParse->zErrMsg and these routines return non-zero.  If everything** checks out, these routines return 0.*/int sqlite3FixSrcList(  DbFixer *pFix,       /* Context of the fixation */  SrcList *pList       /* The Source list to check and modify */){  int i;  const char *zDb;  struct SrcList_item *pItem;  if( pList==0 ) return 0;  zDb = pFix->zDb;  for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){    if( pItem->zDatabase==0 ){      pItem->zDatabase = sqliteStrDup(zDb);    }else if( sqlite3StrICmp(pItem->zDatabase,zDb)!=0 ){      sqlite3ErrorMsg(pFix->pParse,         "%s %T cannot reference objects in database %s",         pFix->zType, pFix->pName, pItem->zDatabase);      return 1;    }#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)    if( sqlite3FixSelect(pFix, pItem->pSelect) ) return 1;    if( sqlite3FixExpr(pFix, pItem->pOn) ) return 1;#endif  }  return 0;}#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)int sqlite3FixSelect(  DbFixer *pFix,       /* Context of the fixation */  Select *pSelect      /* The SELECT statement to be fixed to one database */){  while( pSelect ){    if( sqlite3FixExprList(pFix, pSelect->pEList) ){      return 1;    }    if( sqlite3FixSrcList(pFix, pSelect->pSrc) ){      return 1;    }    if( sqlite3FixExpr(pFix, pSelect->pWhere) ){      return 1;    }    if( sqlite3FixExpr(pFix, pSelect->pHaving) ){      return 1;    }    pSelect = pSelect->pPrior;  }  return 0;}int sqlite3FixExpr(  DbFixer *pFix,     /* Context of the fixation */  Expr *pExpr        /* The expression to be fixed to one database */){  while( pExpr ){    if( sqlite3FixSelect(pFix, pExpr->pSelect) ){      return 1;    }    if( sqlite3FixExprList(pFix, pExpr->pList) ){      return 1;    }    if( sqlite3FixExpr(pFix, pExpr->pRight) ){      return 1;    }    pExpr = pExpr->pLeft;  }  return 0;}int sqlite3FixExprList(  DbFixer *pFix,     /* Context of the fixation */  ExprList *pList    /* The expression to be fixed to one database */){  int i;  struct ExprList_item *pItem;  if( pList==0 ) return 0;  for(i=0, pItem=pList->a; i<pList->nExpr; i++, pItem++){    if( sqlite3FixExpr(pFix, pItem->pExpr) ){      return 1;    }  }  return 0;}#endif#ifndef SQLITE_OMIT_TRIGGERint sqlite3FixTriggerStep(  DbFixer *pFix,     /* Context of the fixation */  TriggerStep *pStep /* The trigger step be fixed to one database */){  while( pStep ){    if( sqlite3FixSelect(pFix, pStep->pSelect) ){      return 1;    }    if( sqlite3FixExpr(pFix, pStep->pWhere) ){      return 1;    }    if( sqlite3FixExprList(pFix, pStep->pExprList) ){      return 1;    }    pStep = pStep->pNext;  }  return 0;}#endif
./sqlitebrowser_1.3/sqlitebrowser/sqlite_source/date.c:/*** 2003 October 31**** The author disclaims copyright to this source code.  In place of** a legal notice, here is a blessing:****    May you do good and not evil.**    May you find forgiveness for yourself and forgive others.**    May you share freely, never taking more than you give.***************************************************************************** This file contains the C functions that implement date and time** functions for SQLite.  **** There is only one exported symbol in this file - the function** sqlite3RegisterDateTimeFunctions() found at the bottom of the file.** All other code has file scope.**** $Id: date.c,v 1.5 2006/05/04 13:48:36 tabuleiro Exp $**** NOTES:**** SQLite processes all times and dates as Julian Day numbers.  The** dates and times are stored as the number of days since noon** in Greenwich on November 24, 4714 B.C. according to the Gregorian** calendar system.**** 1970-01-01 00:00:00 is JD 2440587.5** 2000-01-01 00:00:00 is JD 2451544.5**** This implemention requires years to be expressed as a 4-digit number** which means that only dates between 0000-01-01 and 9999-12-31 can** be represented, even though julian day numbers allow a much wider** range of dates.**** The Gregorian calendar system is used for all dates and times,** even those that predate the Gregorian calendar.  Historians usually** use the Julian calendar for dates prior to 1582-10-15 and for some** dates afterwards, depending on locale.  Beware of this difference.**** The conversion algorithms are implemented based on descriptions** in the following text:****      Jean Meeus**      Astronomical Algorithms, 2nd Edition, 1998**      ISBM 0-943396-61-1**      Willmann-Bell, Inc**      Richmond, Virginia (USA)*/#include "sqliteInt.h"#include "os.h"#include <ctype.h>#include <stdlib.h>#include <assert.h>#include <time.h>#ifndef SQLITE_OMIT_DATETIME_FUNCS/*** A structure for holding a single date and time.*/typedef struct DateTime DateTime;struct DateTime {  double rJD;      /* The julian day number */  int Y, M, D;     /* Year, month, and day */  int h, m;        /* Hour and minutes */  int tz;          /* Timezone offset in minutes */  double s;        /* Seconds */  char validYMD;   /* True if Y,M,D are valid */  char validHMS;   /* True if h,m,s are valid */  char validJD;    /* True if rJD is valid */  char validTZ;    /* True if tz is valid */};/*** Convert zDate into one or more integers.  Additional arguments** come in groups of 5 as follows:****       N       number of digits in the integer**       min     minimum allowed value of the integer**       max     maximum allowed value of the integer**       nextC   first character after the integer**       pVal    where to write the integers value.**** Conversions continue until one with nextC==0 is encountered.** The function returns the number of successful conversions.*/static int getDigits(const char *zDate, ...){  va_list ap;  int val;  int N;  int min;  int max;  int nextC;  int *pVal;  int cnt = 0;  va_start(ap, zDate);  do{    N = va_arg(ap, int);    min = va_arg(ap, int);    max = va_arg(ap, int);    nextC = va_arg(ap, int);    pVal = va_arg(ap, int*);    val = 0;    while( N-- ){      if( !isdigit(*(u8*)zDate) ){        goto end_getDigits;      }      val = val*10 + *zDate - '0';      zDate++;    }    if( val<min || val>max || (nextC!=0 && nextC!=*zDate) ){      goto end_getDigits;    }    *pVal = val;    zDate++;    cnt++;  }while( nextC );end_getDigits:  va_end(ap);  return cnt;}/*** Read text from z[] and convert into a floating point number.  Return** the number of digits converted.*/#define getValue sqlite3AtoF/*** Parse a timezone extension on the end of a date-time.** The extension is of the form:****        (+/-)HH:MM**** If the parse is successful, write the number of minutes** of change in *pnMin and return 0.  If a parser error occurs,** return 0.**** A missing specifier is not considered an error.*/static int parseTimezone(const char *zDate, DateTime *p){  int sgn = 0;  int nHr, nMn;  while( isspace(*(u8*)zDate) ){ zDate++; }  p->tz = 0;  if( *zDate=='-' ){    sgn = -1;  }else if( *zDate=='+' ){    sgn = +1;  }else{    return *zDate!=0;  }  zDate++;  if( getDigits(zDate, 2, 0, 14, ':', &nHr, 2, 0, 59, 0, &nMn)!=2 ){    return 1;  }  zDate += 5;  p->tz = sgn*(nMn + nHr*60);  while( isspace(*(u8*)zDate) ){ zDate++; }  return *zDate!=0;}/*** Parse times of the form HH:MM or HH:MM:SS or HH:MM:SS.FFFF.** The HH, MM, and SS must each be exactly 2 digits.  The** fractional seconds FFFF can be one or more digits.**** Return 1 if there is a parsing error and 0 on success.*/static int parseHhMmSs(const char *zDate, DateTime *p){  int h, m, s;  double ms = 0.0;  if( getDigits(zDate, 2, 0, 24, ':', &h, 2, 0, 59, 0, &m)!=2 ){    return 1;  }  zDate += 5;  if( *zDate==':' ){    zDate++;    if( getDigits(zDate, 2, 0, 59, 0, &s)!=1 ){      return 1;    }    zDate += 2;    if( *zDate=='.' && isdigit((u8)zDate[1]) ){      double rScale = 1.0;      zDate++;      while( isdigit(*(u8*)zDate) ){        ms = ms*10.0 + *zDate - '0';        rScale *= 10.0;        zDate++;      }      ms /= rScale;    }  }else{    s = 0;  }  p->validJD = 0;  p->validHMS = 1;  p->h = h;  p->m = m;  p->s = s + ms;  if( parseTimezone(zDate, p) ) return 1;  p->validTZ = p->tz!=0;  return 0;}/*** Convert from YYYY-MM-DD HH:MM:SS to julian day.  We always assume** that the YYYY-MM-DD is according to the Gregorian calendar.**** Reference:  Meeus page 61*/static void computeJD(DateTime *p){  int Y, M, D, A, B, X1, X2;  if( p->validJD ) return;  if( p->validYMD ){    Y = p->Y;    M = p->M;    D = p->D;  }else{    Y = 2000;  /* If no YMD specified, assume 2000-Jan-01 */    M = 1;    D = 1;  }  if( M<=2 ){    Y--;    M += 12;  }  A = Y/100;  B = 2 - A + (A/4);  X1 = 365.25*(Y+4716);  X2 = 30.6001*(M+1);  p->rJD = X1 + X2 + D + B - 1524.5;  p->validJD = 1;  p->validYMD = 0;  if( p->validHMS ){    p->rJD += (p->h*3600.0 + p->m*60.0 + p->s)/86400.0;    if( p->validTZ ){      p->rJD -= p->tz*60/86400.0;      p->validHMS = 0;      p->validTZ = 0;    }  }}/*** Parse dates of the form****     YYYY-MM-DD HH:MM:SS.FFF**     YYYY-MM-DD HH:MM:SS**     YYYY-MM-DD HH:MM**     YYYY-MM-DD**** Write the result into the DateTime structure and return 0** on success and 1 if the input string is not a well-formed** date.*/static int parseYyyyMmDd(const char *zDate, DateTime *p){  int Y, M, D, neg;  if( zDate[0]=='-' ){    zDate++;    neg = 1;  }else{    neg = 0;  }  if( getDigits(zDate,4,0,9999,'-',&Y,2,1,12,'-',&M,2,1,31,0,&D)!=3 ){    return 1;  }  zDate += 10;  while( isspace(*(u8*)zDate) || 'T'==*(u8*)zDate ){ zDate++; }  if( parseHhMmSs(zDate, p)==0 ){    /* We got the time */  }else if( *zDate==0 ){    p->validHMS = 0;  }else{    return 1;  }  p->validJD = 0;  p->validYMD = 1;  p->Y = neg ? -Y : Y;  p->M = M;  p->D = D;  if( p->validTZ ){    computeJD(p);  }  return 0;}/*** Attempt to parse the given string into a Julian Day Number.  Return** the number of errors.**** The following are acceptable forms for the input string:****      YYYY-MM-DD HH:MM:SS.FFF  +/-HH:MM**      DDDD.DD **      now**** In the first form, the +/-HH:MM is always optional.  The fractional** seconds extension (the ".FFF") is optional.  The seconds portion** (":SS.FFF") is option.  The year and date can be omitted as long** as there is a time string.  The time string can be omitted as long** as there is a year and date.*/static int parseDateOrTime(const char *zDate, DateTime *p){  memset(p, 0, sizeof(*p));  if( parseYyyyMmDd(zDate,p)==0 ){    return 0;  }else if( parseHhMmSs(zDate, p)==0 ){    return 0;  }else if( sqlite3StrICmp(zDate,"now")==0){    double r;    sqlite3OsCurrentTime(&r);    p->rJD = r;    p->validJD = 1;    return 0;  }else if( sqlite3IsNumber(zDate, 0, SQLITE_UTF8) ){    getValue(zDate, &p->rJD);    p->validJD = 1;    return 0;  }  return 1;}/*** Compute the Year, Month, and Day from the julian day number.*/static void computeYMD(DateTime *p){  int Z, A, B, C, D, E, X1;  if( p->validYMD ) return;  if( !p->validJD ){    p->Y = 2000;    p->M = 1;    p->D = 1;  }else{    Z = p->rJD + 0.5;    A = (Z - 1867216.25)/36524.25;    A = Z + 1 + A - (A/4);    B = A + 1524;    C = (B - 122.1)/365.25;    D = 365.25*C;    E = (B-D)/30.6001;    X1 = 30.6001*E;    p->D = B - D - X1;    p->M = E<14 ? E-1 : E-13;    p->Y = p->M>2 ? C - 4716 : C - 4715;  }  p->validYMD = 1;}/*** Compute the Hour, Minute, and Seconds from the julian day number.*/static void computeHMS(DateTime *p){  int Z, s;  if( p->validHMS ) return;  Z = p->rJD + 0.5;  s = (p->rJD + 0.5 - Z)*86400000.0 + 0.5;  p->s = 0.001*s;  s = p->s;  p->s -= s;  p->h = s/3600;  s -= p->h*3600;  p->m = s/60;  p->s += s - p->m*60;  p->validHMS = 1;}/*** Compute both YMD and HMS*/static void computeYMD_HMS(DateTime *p){  computeYMD(p);  computeHMS(p);}/*** Clear the YMD and HMS and the TZ*/static void clearYMD_HMS_TZ(DateTime *p){  p->validYMD = 0;  p->validHMS = 0;  p->validTZ = 0;}/*** Compute the difference (in days) between localtime and UTC (a.k.a. GMT)** for the time value p where p is in UTC.*/static double localtimeOffset(DateTime *p){  DateTime x, y;  time_t t;  struct tm *pTm;  x = *p;  computeYMD_HMS(&x);  if( x.Y<1971 || x.Y>=2038 ){    x.Y = 2000;    x.M = 1;    x.D = 1;    x.h = 0;    x.m = 0;    x.s = 0.0;  } else {    int s = x.s + 0.5;    x.s = s;  }  x.tz = 0;  x.validJD = 0;  computeJD(&x);  t = (x.rJD-2440587.5)*86400.0 + 0.5;  sqlite3OsEnterMutex();  pTm = localtime(&t);  y.Y = pTm->tm_year + 1900;  y.M = pTm->tm_mon + 1;  y.D = pTm->tm_mday;  y.h = pTm->tm_hour;  y.m = pTm->tm_min;  y.s = pTm->tm_sec;  sqlite3OsLeaveMutex();  y.validYMD = 1;  y.validHMS = 1;  y.validJD = 0;  y.validTZ = 0;  computeJD(&y);  return y.rJD - x.rJD;}/*** Process a modifier to a date-time stamp.  The modifiers are** as follows:****     NNN days**     NNN hours**     NNN minutes**     NNN.NNNN seconds**     NNN months**     NNN years**     start of month**     start of year**     start of week**     start of day**     weekday N**     unixepoch**     localtime**     utc**** Return 0 on success and 1 if there is any kind of error.*/static int parseModifier(const char *zMod, DateTime *p){  int rc = 1;  int n;  double r;  char *z, zBuf[30];  z = zBuf;  for(n=0; n<sizeof(zBuf)-1 && zMod[n]; n++){    z[n] = tolower(zMod[n]);  }  z[n] = 0;  switch( z[0] ){    case 'l': {      /*    localtime      **      ** Assuming the current time value is UTC (a.k.a. GMT), shift it to      ** show local time.      */      if( strcmp(z, "localtime")==0 ){        computeJD(p);        p->rJD += localtimeOffset(p);        clearYMD_HMS_TZ(p);        rc = 0;      }      break;    }    case 'u': {      /*      **    unixepoch      **      ** Treat the current value of p->rJD as the number of      ** seconds since 1970.  Convert to a real julian day number.      */      if( strcmp(z, "unixepoch")==0 && p->validJD ){        p->rJD = p->rJD/86400.0 + 2440587.5;        clearYMD_HMS_TZ(p);        rc = 0;      }else if( strcmp(z, "utc")==0 ){        double c1;        computeJD(p);        c1 = localtimeOffset(p);        p->rJD -= c1;        clearYMD_HMS_TZ(p);        p->rJD += c1 - localtimeOffset(p);        rc = 0;      }      break;    }    case 'w': {      /*      **    weekday N      **      ** Move the date to the same time on the next occurrence of      ** weekday N where 0==Sunday, 1==Monday, and so forth.  If the      ** date is already on the appropriate weekday, this is a no-op.      */      if( strncmp(z, "weekday ", 8)==0 && getValue(&z[8],&r)>0                 && (n=r)==r && n>=0 && r<7 ){        int Z;        computeYMD_HMS(p);        p->validTZ = 0;        p->validJD = 0;        computeJD(p);        Z = p->rJD + 1.5;        Z %= 7;        if( Z>n ) Z -= 7;        p->rJD += n - Z;        clearYMD_HMS_TZ(p);        rc = 0;      }      break;    }    case 's': {      /*      **    start of TTTTT      **      ** Move the date backwards to the beginning of the current day,      ** or month or year.      */      if( strncmp(z, "start of ", 9)!=0 ) break;      z += 9;      computeYMD(p);      p->validHMS = 1;      p->h = p->m = 0;      p->s = 0.0;      p->validTZ = 0;      p->validJD = 0;      if( strcmp(z,"month")==0 ){        p->D = 1;        rc = 0;      }else if( strcmp(z,"year")==0 ){        computeYMD(p);        p->M = 1;        p->D = 1;        rc = 0;      }else if( strcmp(z,"day")==0 ){        rc = 0;      }      break;    }    case '+':    case '-':    case '0':    case '1':    case '2':    case '3':    case '4':    case '5':    case '6':    case '7':    case '8':    case '9': {      n = getValue(z, &r);      if( n<=0 ) break;      if( z[n]==':' ){        /* A modifier of the form (+|-)HH:MM:SS.FFF adds (or subtracts) the        ** specified number of hours, minutes, seconds, and fractional seconds        ** to the time.  The ".FFF" may be omitted.  The ":SS.FFF" may be        ** omitted.        */        const char *z2 = z;        DateTime tx;        int day;        if( !isdigit(*(u8*)z2) ) z2++;        memset(&tx, 0, sizeof(tx));        if( parseHhMmSs(z2, &tx) ) break;        computeJD(&tx);        tx.rJD -= 0.5;        day = (int)tx.rJD;        tx.rJD -= day;        if( z[0]=='-' ) tx.rJD = -tx.rJD;        computeJD(p);        clearYMD_HMS_TZ(p);       p->rJD += tx.rJD;        rc = 0;        break;      }      z += n;      while( isspace(*(u8*)z) ) z++;      n = strlen(z);      if( n>10 || n<3 ) break;      if( z[n-1]=='s' ){ z[n-1] = 0; n--; }      computeJD(p);      rc = 0;      if( n==3 && strcmp(z,"day")==0 ){        p->rJD += r;      }else if( n==4 && strcmp(z,"hour")==0 ){        p->rJD += r/24.0;      }else if( n==6 && strcmp(z,"minute")==0 ){        p->rJD += r/(24.0*60.0);      }else if( n==6 && strcmp(z,"second")==0 ){        p->rJD += r/(24.0*60.0*60.0);      }else if( n==5 && strcmp(z,"month")==0 ){        int x, y;        computeYMD_HMS(p);        p->M += r;        x = p->M>0 ? (p->M-1)/12 : (p->M-12)/12;        p->Y += x;        p->M -= x*12;        p->validJD = 0;        computeJD(p);        y = r;        if( y!=r ){          p->rJD += (r - y)*30.0;        }      }else if( n==4 && strcmp(z,"year")==0 ){        computeYMD_HMS(p);        p->Y += r;        p->validJD = 0;        computeJD(p);      }else{        rc = 1;      }      clearYMD_HMS_TZ(p);      break;    }    default: {      break;    }  }  return rc;}/*** Process time function arguments.  argv[0] is a date-time stamp.** argv[1] and following are modifiers.  Parse them all and write** the resulting time into the DateTime structure p.  Return 0** on success and 1 if there are any errors.*/static int isDate(int argc, sqlite3_value **argv, DateTime *p){  int i;  if( argc==0 ) return 1;  if( SQLITE_NULL==sqlite3_value_type(argv[0]) ||       parseDateOrTime((char*)sqlite3_value_text(argv[0]), p) ) return 1;  for(i=1; i<argc; i++){    if( SQLITE_NULL==sqlite3_value_type(argv[i]) ||         parseModifier((char*)sqlite3_value_text(argv[i]), p) ) return 1;  }  return 0;}/*** The following routines implement the various date and time functions** of SQLite.*//***    julianday( TIMESTRING, MOD, MOD, ...)**** Return the julian day number of the date specified in the arguments*/static void juliandayFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  DateTime x;  if( isDate(argc, argv, &x)==0 ){    computeJD(&x);    sqlite3_result_double(context, x.rJD);  }}/***    datetime( TIMESTRING, MOD, MOD, ...)**** Return YYYY-MM-DD HH:MM:SS*/static void datetimeFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  DateTime x;  if( isDate(argc, argv, &x)==0 ){    char zBuf[100];    computeYMD_HMS(&x);    sprintf(zBuf, "%04d-%02d-%02d %02d:%02d:%02d",x.Y, x.M, x.D, x.h, x.m,           (int)(x.s));    sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);  }}/***    time( TIMESTRING, MOD, MOD, ...)**** Return HH:MM:SS*/static void timeFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  DateTime x;  if( isDate(argc, argv, &x)==0 ){    char zBuf[100];    computeHMS(&x);    sprintf(zBuf, "%02d:%02d:%02d", x.h, x.m, (int)x.s);    sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);  }}/***    date( TIMESTRING, MOD, MOD, ...)**** Return YYYY-MM-DD*/static void dateFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  DateTime x;  if( isDate(argc, argv, &x)==0 ){    char zBuf[100];    computeYMD(&x);    sprintf(zBuf, "%04d-%02d-%02d", x.Y, x.M, x.D);    sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);  }}/***    strftime( FORMAT, TIMESTRING, MOD, MOD, ...)**** Return a string described by FORMAT.  Conversions as follows:****   %d  day of month**   %f  ** fractional seconds  SS.SSS**   %H  hour 00-24**   %j  day of year 000-366**   %J  ** Julian day number**   %m  month 01-12**   %M  minute 00-59**   %s  seconds since 1970-01-01**   %S  seconds 00-59**   %w  day of week 0-6  sunday==0**   %W  week of year 00-53**   %Y  year 0000-9999**   %%  %*/static void strftimeFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  DateTime x;  int n, i, j;  char *z;  const char *zFmt = (const char*)sqlite3_value_text(argv[0]);  char zBuf[100];  if( zFmt==0 || isDate(argc-1, argv+1, &x) ) return;  for(i=0, n=1; zFmt[i]; i++, n++){    if( zFmt[i]=='%' ){      switch( zFmt[i+1] ){        case 'd':        case 'H':        case 'm':        case 'M':        case 'S':        case 'W':          n++;          /* fall thru */        case 'w':        case '%':          break;        case 'f':          n += 8;          break;        case 'j':          n += 3;          break;        case 'Y':          n += 8;          break;        case 's':        case 'J':          n += 50;          break;        default:          return;  /* ERROR.  return a NULL */      }      i++;    }  }  if( n<sizeof(zBuf) ){    z = zBuf;  }else{    z = sqliteMalloc( n );    if( z==0 ) return;  }  computeJD(&x);  computeYMD_HMS(&x);  for(i=j=0; zFmt[i]; i++){    if( zFmt[i]!='%' ){      z[j++] = zFmt[i];    }else{      i++;      switch( zFmt[i] ){        case 'd':  sprintf(&z[j],"%02d",x.D); j+=2; break;        case 'f': {          int s = x.s;          int ms = (x.s - s)*1000.0;          sprintf(&z[j],"%02d.%03d",s,ms);          j += strlen(&z[j]);          break;        }        case 'H':  sprintf(&z[j],"%02d",x.h); j+=2; break;        case 'W': /* Fall thru */        case 'j': {          int nDay;             /* Number of days since 1st day of year */          DateTime y = x;          y.validJD = 0;          y.M = 1;          y.D = 1;          computeJD(&y);          nDay = x.rJD - y.rJD;          if( zFmt[i]=='W' ){            int wd;   /* 0=Monday, 1=Tuesday, ... 6=Sunday */            wd = ((int)(x.rJD+0.5)) % 7;            sprintf(&z[j],"%02d",(nDay+7-wd)/7);            j += 2;          }else{            sprintf(&z[j],"%03d",nDay+1);            j += 3;          }          break;        }        case 'J':  sprintf(&z[j],"%.16g",x.rJD); j+=strlen(&z[j]); break;        case 'm':  sprintf(&z[j],"%02d",x.M); j+=2; break;        case 'M':  sprintf(&z[j],"%02d",x.m); j+=2; break;        case 's': {          sprintf(&z[j],"%d",(int)((x.rJD-2440587.5)*86400.0 + 0.5));          j += strlen(&z[j]);          break;        }        case 'S':  sprintf(&z[j],"%02d",(int)(x.s+0.5)); j+=2; break;        case 'w':  z[j++] = (((int)(x.rJD+1.5)) % 7) + '0'; break;        case 'Y':  sprintf(&z[j],"%04d",x.Y); j+=strlen(&z[j]); break;        case '%':  z[j++] = '%'; break;      }    }  }  z[j] = 0;  sqlite3_result_text(context, z, -1, SQLITE_TRANSIENT);  if( z!=zBuf ){    sqliteFree(z);  }}/*** current_time()**** This function returns the same value as time('now').*/static void ctimeFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  sqlite3_value *pVal = sqlite3ValueNew();  if( pVal ){    sqlite3ValueSetStr(pVal, -1, "now", SQLITE_UTF8, SQLITE_STATIC);    timeFunc(context, 1, &pVal);    sqlite3ValueFree(pVal);  }}/*** current_date()**** This function returns the same value as date('now').*/static void cdateFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  sqlite3_value *pVal = sqlite3ValueNew();  if( pVal ){    sqlite3ValueSetStr(pVal, -1, "now", SQLITE_UTF8, SQLITE_STATIC);    dateFunc(context, 1, &pVal);    sqlite3ValueFree(pVal);  }}/*** current_timestamp()**** This function returns the same value as datetime('now').*/static void ctimestampFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  sqlite3_value *pVal = sqlite3ValueNew();  if( pVal ){    sqlite3ValueSetStr(pVal, -1, "now", SQLITE_UTF8, SQLITE_STATIC);    datetimeFunc(context, 1, &pVal);    sqlite3ValueFree(pVal);  }}#endif /* !defined(SQLITE_OMIT_DATETIME_FUNCS) */#ifdef SQLITE_OMIT_DATETIME_FUNCS/*** If the library is compiled to omit the full-scale date and time** handling (to get a smaller binary), the following minimal version** of the functions current_time(), current_date() and current_timestamp()** are included instead. This is to support column declarations that** include "DEFAULT CURRENT_TIME" etc.**** This function uses the C-library functions time(), gmtime()** and strftime(). The format string to pass to strftime() is supplied** as the user-data for the function.*/static void currentTimeFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  time_t t;  char *zFormat = (char *)sqlite3_user_data(context);  char zBuf[20];  time(&t);#ifdef SQLITE_TEST  {    extern int sqlite3_current_time;  /* See os_XXX.c */    if( sqlite3_current_time ){      t = sqlite3_current_time;    }  }#endif  sqlite3OsEnterMutex();  strftime(zBuf, 20, zFormat, gmtime(&t));  sqlite3OsLeaveMutex();  sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);}#endif/*** This function registered all of the above C functions as SQL** functions.  This should be the only routine in this file with** external linkage.*/void sqlite3RegisterDateTimeFunctions(sqlite3 *db){#ifndef SQLITE_OMIT_DATETIME_FUNCS  static const struct {     char *zName;     int nArg;     void (*xFunc)(sqlite3_context*,int,sqlite3_value**);  } aFuncs[] = {    { "julianday", -1, juliandayFunc   },    { "date",      -1, dateFunc        },    { "time",      -1, timeFunc        },    { "datetime",  -1, datetimeFunc    },    { "strftime",  -1, strftimeFunc    },    { "current_time",       0, ctimeFunc      },    { "current_timestamp",  0, ctimestampFunc },    { "current_date",       0, cdateFunc      },  };  int i;  for(i=0; i<sizeof(aFuncs)/sizeof(aFuncs[0]); i++){    sqlite3CreateFunc(db, aFuncs[i].zName, aFuncs[i].nArg,        SQLITE_UTF8, 0, aFuncs[i].xFunc, 0, 0);  }#else  static const struct {     char *zName;     char *zFormat;  } aFuncs[] = {    { "current_time", "%H:%M:%S" },    { "current_date", "%Y-%m-%d" },    { "current_timestamp", "%Y-%m-%d %H:%M:%S" }  };  int i;  for(i=0; i<sizeof(aFuncs)/sizeof(aFuncs[0]); i++){    sqlite3CreateFunc(db, aFuncs[i].zName, 0, SQLITE_UTF8,         aFuncs[i].zFormat, currentTimeFunc, 0, 0);  }#endif}
./sqlitebrowser_1.3/sqlitebrowser/sqlite_source/func.c:/*** 2002 February 23**** The author disclaims copyright to this source code.  In place of** a legal notice, here is a blessing:****    May you do good and not evil.**    May you find forgiveness for yourself and forgive others.**    May you share freely, never taking more than you give.***************************************************************************** This file contains the C functions that implement various SQL** functions of SQLite.  **** There is only one exported symbol in this file - the function** sqliteRegisterBuildinFunctions() found at the bottom of the file.** All other code has file scope.**** $Id: func.c,v 1.7 2006/05/04 13:48:36 tabuleiro Exp $*/#include "sqliteInt.h"#include <ctype.h>/* #include <math.h> */#include <stdlib.h>#include <assert.h>#include "vdbeInt.h"#include "os.h"/*** Return the collating function associated with a function.*/static CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context){  return context->pColl;}/*** Implementation of the non-aggregate min() and max() functions*/static void minmaxFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  int i;  int mask;    /* 0 for min() or 0xffffffff for max() */  int iBest;  CollSeq *pColl;  if( argc==0 ) return;  mask = sqlite3_user_data(context)==0 ? 0 : -1;  pColl = sqlite3GetFuncCollSeq(context);  assert( pColl );  assert( mask==-1 || mask==0 );  iBest = 0;  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;  for(i=1; i<argc; i++){    if( sqlite3_value_type(argv[i])==SQLITE_NULL ) return;    if( (sqlite3MemCompare(argv[iBest], argv[i], pColl)^mask)>=0 ){      iBest = i;    }  }  sqlite3_result_value(context, argv[iBest]);}/*** Return the type of the argument.*/static void typeofFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  const char *z = 0;  switch( sqlite3_value_type(argv[0]) ){    case SQLITE_NULL:    z = "null";    break;    case SQLITE_INTEGER: z = "integer"; break;    case SQLITE_TEXT:    z = "text";    break;    case SQLITE_FLOAT:   z = "real";    break;    case SQLITE_BLOB:    z = "blob";    break;  }  sqlite3_result_text(context, z, -1, SQLITE_STATIC);}/*** Implementation of the length() function*/static void lengthFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  int len;  assert( argc==1 );  switch( sqlite3_value_type(argv[0]) ){    case SQLITE_BLOB:    case SQLITE_INTEGER:    case SQLITE_FLOAT: {      sqlite3_result_int(context, sqlite3_value_bytes(argv[0]));      break;    }    case SQLITE_TEXT: {      const unsigned char *z = sqlite3_value_text(argv[0]);      for(len=0; *z; z++){ if( (0xc0&*z)!=0x80 ) len++; }      sqlite3_result_int(context, len);      break;    }    default: {      sqlite3_result_null(context);      break;    }  }}/*** Implementation of the abs() function*/static void absFunc(sqlite3_context *context, int argc, sqlite3_value **argv){  assert( argc==1 );  switch( sqlite3_value_type(argv[0]) ){    case SQLITE_INTEGER: {      i64 iVal = sqlite3_value_int64(argv[0]);      if( iVal<0 ){        if( (iVal<<1)==0 ){          sqlite3_result_error(context, "integer overflow", -1);          return;        }        iVal = -iVal;      }       sqlite3_result_int64(context, iVal);      break;    }    case SQLITE_NULL: {      sqlite3_result_null(context);      break;    }    default: {      double rVal = sqlite3_value_double(argv[0]);      if( rVal<0 ) rVal = -rVal;      sqlite3_result_double(context, rVal);      break;    }  }}/*** Implementation of the substr() function*/static void substrFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  const unsigned char *z;  const unsigned char *z2;  int i;  int p1, p2, len;  assert( argc==3 );  z = sqlite3_value_text(argv[0]);  if( z==0 ) return;  p1 = sqlite3_value_int(argv[1]);  p2 = sqlite3_value_int(argv[2]);  for(len=0, z2=z; *z2; z2++){ if( (0xc0&*z2)!=0x80 ) len++; }  if( p1<0 ){    p1 += len;    if( p1<0 ){      p2 += p1;      p1 = 0;    }  }else if( p1>0 ){    p1--;  }  if( p1+p2>len ){    p2 = len-p1;  }  for(i=0; i<p1 && z[i]; i++){    if( (z[i]&0xc0)==0x80 ) p1++;  }  while( z[i] && (z[i]&0xc0)==0x80 ){ i++; p1++; }  for(; i<p1+p2 && z[i]; i++){    if( (z[i]&0xc0)==0x80 ) p2++;  }  while( z[i] && (z[i]&0xc0)==0x80 ){ i++; p2++; }  if( p2<0 ) p2 = 0;  sqlite3_result_text(context, (char*)&z[p1], p2, SQLITE_TRANSIENT);}/*** Implementation of the round() function*/static void roundFunc(sqlite3_context *context, int argc, sqlite3_value **argv){  int n = 0;  double r;  char zBuf[500];  /* larger than the %f representation of the largest double */  assert( argc==1 || argc==2 );  if( argc==2 ){    if( SQLITE_NULL==sqlite3_value_type(argv[1]) ) return;    n = sqlite3_value_int(argv[1]);    if( n>30 ) n = 30;    if( n<0 ) n = 0;  }  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;  r = sqlite3_value_double(argv[0]);  sqlite3_snprintf(sizeof(zBuf),zBuf,"%.*f",n,r);  sqlite3_result_double(context, atof(zBuf));}/*** Implementation of the upper() and lower() SQL functions.*/static void upperFunc(sqlite3_context *context, int argc, sqlite3_value **argv){  unsigned char *z;  int i;  if( argc<1 || SQLITE_NULL==sqlite3_value_type(argv[0]) ) return;  z = sqliteMalloc(sqlite3_value_bytes(argv[0])+1);  if( z==0 ) return;  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));  for(i=0; z[i]; i++){    z[i] = toupper(z[i]);  }  sqlite3_result_text(context, (char*)z, -1, SQLITE_TRANSIENT);  sqliteFree(z);}static void lowerFunc(sqlite3_context *context, int argc, sqlite3_value **argv){  unsigned char *z;  int i;  if( argc<1 || SQLITE_NULL==sqlite3_value_type(argv[0]) ) return;  z = sqliteMalloc(sqlite3_value_bytes(argv[0])+1);  if( z==0 ) return;  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));  for(i=0; z[i]; i++){    z[i] = tolower(z[i]);  }  sqlite3_result_text(context, (char*)z, -1, SQLITE_TRANSIENT);  sqliteFree(z);}/*** Implementation of the IFNULL(), NVL(), and COALESCE() functions.  ** All three do the same thing.  They return the first non-NULL** argument.*/static void ifnullFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  int i;  for(i=0; i<argc; i++){    if( SQLITE_NULL!=sqlite3_value_type(argv[i]) ){      sqlite3_result_value(context, argv[i]);      break;    }  }}/*** Implementation of random().  Return a random integer.  */static void randomFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  sqlite_int64 r;  sqlite3Randomness(sizeof(r), &r);  if( (r<<1)==0 ) r = 0;  /* Prevent 0x8000.... as the result so that we */                          /* can always do abs() of the result */  sqlite3_result_int64(context, r);}/*** Implementation of the last_insert_rowid() SQL function.  The return** value is the same as the sqlite3_last_insert_rowid() API function.*/static void last_insert_rowid(  sqlite3_context *context,   int arg,   sqlite3_value **argv){  sqlite3 *db = sqlite3_user_data(context);  sqlite3_result_int64(context, sqlite3_last_insert_rowid(db));}/*** Implementation of the changes() SQL function.  The return value is the** same as the sqlite3_changes() API function.*/static void changes(  sqlite3_context *context,  int arg,  sqlite3_value **argv){  sqlite3 *db = sqlite3_user_data(context);  sqlite3_result_int(context, sqlite3_changes(db));}/*** Implementation of the total_changes() SQL function.  The return value is** the same as the sqlite3_total_changes() API function.*/static void total_changes(  sqlite3_context *context,  int arg,  sqlite3_value **argv){  sqlite3 *db = sqlite3_user_data(context);  sqlite3_result_int(context, sqlite3_total_changes(db));}/*** A structure defining how to do GLOB-style comparisons.*/struct compareInfo {  u8 matchAll;  u8 matchOne;  u8 matchSet;  u8 noCase;};static const struct compareInfo globInfo = { '*', '?', '[', 0 };/* The correct SQL-92 behavior is for the LIKE operator to ignore** case.  Thus  'a' LIKE 'A' would be true. */static const struct compareInfo likeInfoNorm = { '%', '_',   0, 1 };/* If SQLITE_CASE_SENSITIVE_LIKE is defined, then the LIKE operator** is case sensitive causing 'a' LIKE 'A' to be false */static const struct compareInfo likeInfoAlt = { '%', '_',   0, 0 };/*** X is a pointer to the first byte of a UTF-8 character.  Increment** X so that it points to the next character.  This only works right** if X points to a well-formed UTF-8 string.*/#define sqliteNextChar(X)  while( (0xc0&*++(X))==0x80 ){}#define sqliteCharVal(X)   sqlite3ReadUtf8(X)/*** Compare two UTF-8 strings for equality where the first string can** potentially be a "glob" expression.  Return true (1) if they** are the same and false (0) if they are different.**** Globbing rules:****      '*'       Matches any sequence of zero or more characters.****      '?'       Matches exactly one character.****     [...]      Matches one character from the enclosed list of**                characters.****     [^...]     Matches one character not in the enclosed list.**** With the [...] and [^...] matching, a ']' character can be included** in the list by making it the first character after '[' or '^'.  A** range of characters can be specified using '-'.  Example:** "[a-z]" matches any single lower-case letter.  To match a '-', make** it the last character in the list.**** This routine is usually quick, but can be N**2 in the worst case.**** Hints: to match '*' or '?', put them in "[]".  Like this:****         abc[*]xyz        Matches "abc*xyz" only*/static int patternCompare(  const u8 *zPattern,              /* The glob pattern */  const u8 *zString,               /* The string to compare against the glob */  const struct compareInfo *pInfo, /* Information about how to do the compare */  const int esc                    /* The escape character */){  register int c;  int invert;  int seen;  int c2;  u8 matchOne = pInfo->matchOne;  u8 matchAll = pInfo->matchAll;  u8 matchSet = pInfo->matchSet;  u8 noCase = pInfo->noCase;   int prevEscape = 0;     /* True if the previous character was 'escape' */  while( (c = *zPattern)!=0 ){    if( !prevEscape && c==matchAll ){      while( (c=zPattern[1]) == matchAll || c == matchOne ){        if( c==matchOne ){          if( *zString==0 ) return 0;          sqliteNextChar(zString);        }        zPattern++;      }      if( c && esc && sqlite3ReadUtf8(&zPattern[1])==esc ){        u8 const *zTemp = &zPattern[1];        sqliteNextChar(zTemp);        c = *zTemp;      }      if( c==0 ) return 1;      if( c==matchSet ){        assert( esc==0 );   /* This is GLOB, not LIKE */        while( *zString && patternCompare(&zPattern[1],zString,pInfo,esc)==0 ){          sqliteNextChar(zString);        }        return *zString!=0;      }else{        while( (c2 = *zString)!=0 ){          if( noCase ){            c2 = sqlite3UpperToLower[c2];            c = sqlite3UpperToLower[c];            while( c2 != 0 && c2 != c ){ c2 = sqlite3UpperToLower[*++zString]; }          }else{            while( c2 != 0 && c2 != c ){ c2 = *++zString; }          }          if( c2==0 ) return 0;          if( patternCompare(&zPattern[1],zString,pInfo,esc) ) return 1;          sqliteNextChar(zString);        }        return 0;      }    }else if( !prevEscape && c==matchOne ){      if( *zString==0 ) return 0;      sqliteNextChar(zString);      zPattern++;    }else if( c==matchSet ){      int prior_c = 0;      assert( esc==0 );    /* This only occurs for GLOB, not LIKE */      seen = 0;      invert = 0;      c = sqliteCharVal(zString);      if( c==0 ) return 0;      c2 = *++zPattern;      if( c2=='^' ){ invert = 1; c2 = *++zPattern; }      if( c2==']' ){        if( c==']' ) seen = 1;        c2 = *++zPattern;      }      while( (c2 = sqliteCharVal(zPattern))!=0 && c2!=']' ){        if( c2=='-' && zPattern[1]!=']' && zPattern[1]!=0 && prior_c>0 ){          zPattern++;          c2 = sqliteCharVal(zPattern);          if( c>=prior_c && c<=c2 ) seen = 1;          prior_c = 0;        }else if( c==c2 ){          seen = 1;          prior_c = c2;        }else{          prior_c = c2;        }        sqliteNextChar(zPattern);      }      if( c2==0 || (seen ^ invert)==0 ) return 0;      sqliteNextChar(zString);      zPattern++;    }else if( esc && !prevEscape && sqlite3ReadUtf8(zPattern)==esc){      prevEscape = 1;      sqliteNextChar(zPattern);    }else{      if( noCase ){        if( sqlite3UpperToLower[c] != sqlite3UpperToLower[*zString] ) return 0;      }else{        if( c != *zString ) return 0;      }      zPattern++;      zString++;      prevEscape = 0;    }  }  return *zString==0;}/*** Count the number of times that the LIKE operator (or GLOB which is** just a variation of LIKE) gets called.  This is used for testing** only.*/#ifdef SQLITE_TESTint sqlite3_like_count = 0;#endif/*** Implementation of the like() SQL function.  This function implements** the build-in LIKE operator.  The first argument to the function is the** pattern and the second argument is the string.  So, the SQL statements:****       A LIKE B**** is implemented as like(B,A).**** This same function (with a different compareInfo structure) computes** the GLOB operator.*/static void likeFunc(  sqlite3_context *context,   int argc,   sqlite3_value **argv){  const unsigned char *zA = sqlite3_value_text(argv[0]);  const unsigned char *zB = sqlite3_value_text(argv[1]);  int escape = 0;  if( argc==3 ){    /* The escape character string must consist of a single UTF-8 character.    ** Otherwise, return an error.    */    const unsigned char *zEsc = sqlite3_value_text(argv[2]);    if( sqlite3utf8CharLen((char*)zEsc, -1)!=1 ){      sqlite3_result_error(context,           "ESCAPE expression must be a single character", -1);      return;    }    escape = sqlite3ReadUtf8(zEsc);  }  if( zA && zB ){    struct compareInfo *pInfo = sqlite3_user_data(context);#ifdef SQLITE_TEST    sqlite3_like_count++;#endif    sqlite3_result_int(context, patternCompare(zA, zB, pInfo, escape));  }}/*** Implementation of the NULLIF(x,y) function.  The result is the first** argument if the arguments are different.  The result is NULL if the** arguments are equal to each other.*/static void nullifFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  CollSeq *pColl = sqlite3GetFuncCollSeq(context);  if( sqlite3MemCompare(argv[0], argv[1], pColl)!=0 ){    sqlite3_result_value(context, argv[0]);  }}/*** Implementation of the VERSION(*) function.  The result is the version** of the SQLite library that is running.*/static void versionFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv){  sqlite3_result_text(context, sqlite3_version, -1, SQLITE_STATIC);}/*** EXPERIMENTAL - This is not an official function.  The interface may** change.  This function may disappear.  Do not write code that depends** on this function.**** Implementation of the QUOTE() function.  This function takes a single** argument.  If the argument is numeric, the return value is the same as** the argument.  If the argument is NULL, the return value is the string** "NULL".  Otherwise, the argument is enclosed in single quotes with** single-quote escapes.*/static void quoteFunc(sqlite3_context *context, int argc, sqlite3_value **argv){  if( argc<1 ) return;  switch( sqlite3_value_type(argv[0]) ){    case SQLITE_NULL: {      sqlite3_result_text(context, "NULL", 4, SQLITE_STATIC);      break;    }    case SQLITE_INTEGER:    case SQLITE_FLOAT: {      sqlite3_result_value(context, argv[0]);      break;    }    case SQLITE_BLOB: {      static const char hexdigits[] = {         '0', '1', '2', '3', '4', '5', '6', '7',        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'       };      char *zText = 0;      int nBlob = sqlite3_value_bytes(argv[0]);      char const *zBlob = sqlite3_value_blob(argv[0]);      zText = (char *)sqliteMalloc((2*nBlob)+4);       if( !zText ){        sqlite3_result_error(context, "out of memory", -1);      }else{        int i;        for(i=0; i<nBlob; i++){          zText[(i*2)+2] = hexdigits[(zBlob[i]>>4)&0x0F];          zText[(i*2)+3] = hexdigits[(zBlob[i])&0x0F];        }        zText[(nBlob*2)+2] = '\'';        zText[(nBlob*2)+3] = '\0';        zText[0] = 'X';        zText[1] = '\'';        sqlite3_result_text(context, zText, -1, SQLITE_TRANSIENT);        sqliteFree(zText);      }      break;    }    case SQLITE_TEXT: {      int i,j,n;      const unsigned char *zArg = sqlite3_value_text(argv[0]);      char *z;      for(i=n=0; zArg[i]; i++){ if( zArg[i]=='\'' ) n++; }      z = sqliteMalloc( i+n+3 );      if( z==0 ) return;      z[0] = '\'';      for(i=0, j=1; zArg[i]; i++){        z[j++] = zArg[i];        if( zArg[i]=='\'' ){          z[j++] = '\'';        }      }      z[j++] = '\'';      z[j] = 0;      sqlite3_result_text(context, z, j, SQLITE_TRANSIENT);      sqliteFree(z);    }  }}#ifdef SQLITE_SOUNDEX/*** Compute the soundex encoding of a word.*/static void soundexFunc(sqlite3_context *context, int argc, sqlite3_value **argv){  char zResult[8];  const u8 *zIn;  int i, j;  static const unsigned char iCode[] = {    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0,    1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0,    0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0,    1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0,  };  assert( argc==1 );  zIn = (u8*)sqlite3_value_text(argv[0]);  for(i=0; zIn[i] && !isalpha(zIn[i]); i++){}  if( zIn[i] ){    zResult[0] = toupper(zIn[i]);    for(j=1; j<4 && zIn[i]; i++){      int code = iCode[zIn[i]&0x7f];      if( code>0 ){        zResult[j++] = code + '0';      }    }    while( j<4 ){      zResult[j++] = '0';    }    zResult[j] = 0;    sqlite3_result_text(context, zResult, 4, SQLITE_TRANSIENT);  }else{    sqlite3_result_text(context, "?000", 4, SQLITE_STATIC);  }}#endif#ifdef SQLITE_TEST/*** This function generates a string of random characters.  Used for** generating test data.*/static void randStr(sqlite3_context *context, int argc, sqlite3_value **argv){  static const unsigned char zSrc[] =      "abcdefghijklmnopqrstuvwxyz"     "ABCDEFGHIJKLMNOPQRSTUVWXYZ"     "0123456789"     ".-!,:*^+=_|?/<> ";  int iMin, iMax, n, r, i;  unsigned char zBuf[1000];  if( argc>=1 ){    iMin = sqlite3_value_int(argv[0]);    if( iMin<0 ) iMin = 0;    if( iMin>=sizeof(zBuf) ) iMin = sizeof(zBuf)-1;  }else{    iMin = 1;  }  if( argc>=2 ){    iMax = sqlite3_value_int(argv[1]);    if( iMax<iMin ) iMax = iMin;    if( iMax>=sizeof(zBuf) ) iMax = sizeof(zBuf)-1;  }else{    iMax = 50;  }  n = iMin;  if( iMax>iMin ){    sqlite3Randomness(sizeof(r), &r);    r &= 0x7fffffff;    n += r%(iMax + 1 - iMin);  }  assert( n<sizeof(zBuf) );  sqlite3Randomness(n, zBuf);  for(i=0; i<n; i++){    zBuf[i] = zSrc[zBuf[i]%(sizeof(zSrc)-1)];  }  zBuf[n] = 0;  sqlite3_result_text(context, (char*)zBuf, n, SQLITE_TRANSIENT);}#endif /* SQLITE_TEST */#ifdef SQLITE_TEST/*** The following two SQL functions are used to test returning a text** result with a destructor. Function 'test_destructor' takes one argument** and returns the same argument interpreted as TEXT. A destructor is** passed with the sqlite3_result_text() call.**** SQL function 'test_destructor_count' returns the number of outstanding ** allocations made by 'test_destructor';**** WARNING: Not threadsafe.*/static int test_destructor_count_var = 0;static void destructor(void *p){  char *zVal = (char *)p;  assert(zVal);  zVal--;  sqliteFree(zVal);  test_destructor_count_var--;}static void test_destructor(  sqlite3_context *pCtx,   int nArg,  sqlite3_value **argv){  char *zVal;  int len;  sqlite3 *db = sqlite3_user_data(pCtx);   test_destructor_count_var++;  assert( nArg==1 );  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;  len = sqlite3ValueBytes(argv[0], ENC(db));   zVal = sqliteMalloc(len+3);  zVal[len] = 0;  zVal[len-1] = 0;  assert( zVal );  zVal++;  memcpy(zVal, sqlite3ValueText(argv[0], ENC(db)), len);  if( ENC(db)==SQLITE_UTF8 ){    sqlite3_result_text(pCtx, zVal, -1, destructor);#ifndef SQLITE_OMIT_UTF16  }else if( ENC(db)==SQLITE_UTF16LE ){    sqlite3_result_text16le(pCtx, zVal, -1, destructor);  }else{    sqlite3_result_text16be(pCtx, zVal, -1, destructor);#endif /* SQLITE_OMIT_UTF16 */  }}static void test_destructor_count(  sqlite3_context *pCtx,   int nArg,  sqlite3_value **argv){  sqlite3_result_int(pCtx, test_destructor_count_var);}#endif /* SQLITE_TEST */#ifdef SQLITE_TEST/*** Routines for testing the sqlite3_get_auxdata() and sqlite3_set_auxdata()** interface.**** The test_auxdata() SQL function attempts to register each of its arguments** as auxiliary data.  If there are no prior registrations of aux data for** that argument (meaning the argument is not a constant or this is its first** call) then the result for that argument is 0.  If there is a prior** registration, the result for that argument is 1.  The overall result** is the individual argument results separated by spaces.*/static void free_test_auxdata(void *p) {sqliteFree(p);}static void test_auxdata(  sqlite3_context *pCtx,   int nArg,  sqlite3_value **argv){  int i;  char *zRet = sqliteMalloc(nArg*2);  if( !zRet ) return;  for(i=0; i<nArg; i++){    char const *z = (char*)sqlite3_value_text(argv[i]);    if( z ){      char *zAux = sqlite3_get_auxdata(pCtx, i);      if( zAux ){        zRet[i*2] = '1';        if( strcmp(zAux, z) ){          sqlite3_result_error(pCtx, "Auxilary data corruption", -1);          return;        }      }else{        zRet[i*2] = '0';        zAux = sqliteStrDup(z);        sqlite3_set_auxdata(pCtx, i, zAux, free_test_auxdata);      }      zRet[i*2+1] = ' ';    }  }  sqlite3_result_text(pCtx, zRet, 2*nArg-1, free_test_auxdata);}#endif /* SQLITE_TEST */#ifdef SQLITE_TEST/*** A function to test error reporting from user functions. This function** returns a copy of it's first argument as an error.*/static void test_error(  sqlite3_context *pCtx,   int nArg,  sqlite3_value **argv){  sqlite3_result_error(pCtx, (char*)sqlite3_value_text(argv[0]), 0);}#endif /* SQLITE_TEST *//*** An instance of the following structure holds the context of a** sum() or avg() aggregate computation.*/typedef struct SumCtx SumCtx;struct SumCtx {  double rSum;      /* Floating point sum */  i64 iSum;         /* Integer sum */     i64 cnt;          /* Number of elements summed */  u8 overflow;      /* True if integer overflow seen */  u8 approx;        /* True if non-integer value was input to the sum */};/*** Routines used to compute the sum, average, and total.**** The SUM() function follows the (broken) SQL standard which means** that it returns NULL if it sums over no inputs.  TOTAL returns** 0.0 in that case.  In addition, TOTAL always returns a float where** SUM might return an integer if it never encounters a floating point** value.**** I am told that SUM() should raise an exception if it encounters** a integer overflow.  But after pondering this, I decided that ** behavior leads to brittle programs.  So instead, I have coded** SUM() to revert to using floating point if it encounters an** integer overflow.  The answer may not be exact, but it will be** close.  If the SUM() function returns an integer, the value is** exact.  If SUM() returns a floating point value, it means the** value might be approximated.*/static void sumStep(sqlite3_context *context, int argc, sqlite3_value **argv){  SumCtx *p;  int type;  assert( argc==1 );  p = sqlite3_aggregate_context(context, sizeof(*p));  type = sqlite3_value_numeric_type(argv[0]);  if( p && type!=SQLITE_NULL ){    p->cnt++;    if( type==SQLITE_INTEGER ){      i64 v = sqlite3_value_int64(argv[0]);      p->rSum += v;      if( (p->approx|p->overflow)==0 ){        i64 iNewSum = p->iSum + v;        int s1 = p->iSum >> (sizeof(i64)*8-1);        int s2 = v       >> (sizeof(i64)*8-1);        int s3 = iNewSum >> (sizeof(i64)*8-1);        p->overflow = (s1&s2&~s3) | (~s1&~s2&s3);        p->iSum = iNewSum;      }    }else{      p->rSum += sqlite3_value_double(argv[0]);      p->approx = 1;    }  }}static void sumFinalize(sqlite3_context *context){  SumCtx *p;  p = sqlite3_aggregate_context(context, 0);  if( p && p->cnt>0 ){    if( p->overflow ){      sqlite3_result_error(context,"integer overflow",-1);    }else if( p->approx ){      sqlite3_result_double(context, p->rSum);    }else{      sqlite3_result_int64(context, p->iSum);    }  }}static void avgFinalize(sqlite3_context *context){  SumCtx *p;  p = sqlite3_aggregate_context(context, 0);  if( p && p->cnt>0 ){    sqlite3_result_double(context, p->rSum/(double)p->cnt);  }}static void totalFinalize(sqlite3_context *context){  SumCtx *p;  p = sqlite3_aggregate_context(context, 0);  sqlite3_result_double(context, p ? p->rSum : 0.0);}/*** The following structure keeps track of state information for the** count() aggregate function.*/typedef struct CountCtx CountCtx;struct CountCtx {  i64 n;};/*** Routines to implement the count() aggregate function.*/static void countStep(sqlite3_context *context, int argc, sqlite3_value **argv){  CountCtx *p;  p = sqlite3_aggregate_context(context, sizeof(*p));  if( (argc==0 || SQLITE_NULL!=sqlite3_value_type(argv[0])) && p ){    p->n++;  }}   static void countFinalize(sqlite3_context *context){  CountCtx *p;  p = sqlite3_aggregate_context(context, 0);  sqlite3_result_int64(context, p ? p->n : 0);}/*** Routines to implement min() and max() aggregate functions.*/static void minmaxStep(sqlite3_context *context, int argc, sqlite3_value **argv){  Mem *pArg  = (Mem *)argv[0];  Mem *pBest;  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;  pBest = (Mem *)sqlite3_aggregate_context(context, sizeof(*pBest));  if( !pBest ) return;  if( pBest->flags ){    int max;    int cmp;    CollSeq *pColl = sqlite3GetFuncCollSeq(context);    /* This step function is used for both the min() and max() aggregates,    ** the only difference between the two being that the sense of the    ** comparison is inverted. For the max() aggregate, the    ** sqlite3_user_data() function returns (void *)-1. For min() it    ** returns (void *)db, where db is the sqlite3* database pointer.    ** Therefore the next statement sets variable 'max' to 1 for the max()    ** aggregate, or 0 for min().    */    max = ((sqlite3_user_data(context)==(void *)-1)?1:0);    cmp = sqlite3MemCompare(pBest, pArg, pColl);    if( (max && cmp<0) || (!max && cmp>0) ){      sqlite3VdbeMemCopy(pBest, pArg);    }  }else{    sqlite3VdbeMemCopy(pBest, pArg);  }}static void minMaxFinalize(sqlite3_context *context){  sqlite3_value *pRes;  pRes = (sqlite3_value *)sqlite3_aggregate_context(context, 0);  if( pRes ){    if( pRes->flags ){      sqlite3_result_value(context, pRes);    }    sqlite3VdbeMemRelease(pRes);  }}/*** This function registered all of the above C functions as SQL** functions.  This should be the only routine in this file with** external linkage.*/void sqlite3RegisterBuiltinFunctions(sqlite3 *db){  static const struct {     char *zName;     signed char nArg;     u8 argType;           /* 0: none.  1: db  2: (-1) */     u8 eTextRep;          /* 1: UTF-16.  0: UTF-8 */     u8 needCollSeq;     void (*xFunc)(sqlite3_context*,int,sqlite3_value **);  } aFuncs[] = {    { "min",               -1, 0, SQLITE_UTF8,    1, minmaxFunc },    { "min",                0, 0, SQLITE_UTF8,    1, 0          },    { "max",               -1, 2, SQLITE_UTF8,    1, minmaxFunc },    { "max",                0, 2, SQLITE_UTF8,    1, 0          },    { "typeof",             1, 0, SQLITE_UTF8,    0, typeofFunc },    { "length",             1, 0, SQLITE_UTF8,    0, lengthFunc },    { "substr",             3, 0, SQLITE_UTF8,    0, substrFunc },#ifndef SQLITE_OMIT_UTF16    { "substr",             3, 0, SQLITE_UTF16LE, 0, sqlite3utf16Substr },#endif    { "abs",                1, 0, SQLITE_UTF8,    0, absFunc    },    { "round",              1, 0, SQLITE_UTF8,    0, roundFunc  },    { "round",              2, 0, SQLITE_UTF8,    0, roundFunc  },    { "upper",              1, 0, SQLITE_UTF8,    0, upperFunc  },    { "lower",              1, 0, SQLITE_UTF8,    0, lowerFunc  },    { "coalesce",          -1, 0, SQLITE_UTF8,    0, ifnullFunc },    { "coalesce",           0, 0, SQLITE_UTF8,    0, 0          },    { "coalesce",           1, 0, SQLITE_UTF8,    0, 0          },    { "ifnull",             2, 0, SQLITE_UTF8,    1, ifnullFunc },    { "random",            -1, 0, SQLITE_UTF8,    0, randomFunc },    { "nullif",             2, 0, SQLITE_UTF8,    1, nullifFunc },    { "sqlite_version",     0, 0, SQLITE_UTF8,    0, versionFunc},    { "quote",              1, 0, SQLITE_UTF8,    0, quoteFunc  },    { "last_insert_rowid",  0, 1, SQLITE_UTF8,    0, last_insert_rowid },    { "changes",            0, 1, SQLITE_UTF8,    0, changes    },    { "total_changes",      0, 1, SQLITE_UTF8,    0, total_changes },#ifdef SQLITE_SOUNDEX    { "soundex",            1, 0, SQLITE_UTF8, 0, soundexFunc},#endif#ifdef SQLITE_TEST    { "randstr",               2, 0, SQLITE_UTF8, 0, randStr    },    { "test_destructor",       1, 1, SQLITE_UTF8, 0, test_destructor},    { "test_destructor_count", 0, 0, SQLITE_UTF8, 0, test_destructor_count},    { "test_auxdata",         -1, 0, SQLITE_UTF8, 0, test_auxdata},    { "test_error",            1, 0, SQLITE_UTF8, 0, test_error},#endif  };  static const struct {    char *zName;    signed char nArg;    u8 argType;    u8 needCollSeq;    void (*xStep)(sqlite3_context*,int,sqlite3_value**);    void (*xFinalize)(sqlite3_context*);  } aAggs[] = {    { "min",    1, 0, 1, minmaxStep,   minMaxFinalize },    { "max",    1, 2, 1, minmaxStep,   minMaxFinalize },    { "sum",    1, 0, 0, sumStep,      sumFinalize    },    { "total",  1, 0, 0, sumStep,      totalFinalize    },    { "avg",    1, 0, 0, sumStep,      avgFinalize    },    { "count",  0, 0, 0, countStep,    countFinalize  },    { "count",  1, 0, 0, countStep,    countFinalize  },  };  int i;  for(i=0; i<sizeof(aFuncs)/sizeof(aFuncs[0]); i++){    void *pArg = 0;    switch( aFuncs[i].argType ){      case 1: pArg = db; break;      case 2: pArg = (void *)(-1); break;    }    sqlite3CreateFunc(db, aFuncs[i].zName, aFuncs[i].nArg,        aFuncs[i].eTextRep, pArg, aFuncs[i].xFunc, 0, 0);    if( aFuncs[i].needCollSeq ){      FuncDef *pFunc = sqlite3FindFunction(db, aFuncs[i].zName,           strlen(aFuncs[i].zName), aFuncs[i].nArg, aFuncs[i].eTextRep, 0);      if( pFunc && aFuncs[i].needCollSeq ){        pFunc->needCollSeq = 1;      }    }  }#ifndef SQLITE_OMIT_ALTERTABLE  sqlite3AlterFunctions(db);#endif#ifndef SQLITE_OMIT_PARSER  sqlite3AttachFunctions(db);#endif  for(i=0; i<sizeof(aAggs)/sizeof(aAggs[0]); i++){    void *pArg = 0;    switch( aAggs[i].argType ){      case 1: pArg = db; break;      case 2: pArg = (void *)(-1); break;    }    sqlite3CreateFunc(db, aAggs[i].zName, aAggs[i].nArg, SQLITE_UTF8,         pArg, 0, aAggs[i].xStep, aAggs[i].xFinalize);    if( aAggs[i].needCollSeq ){      FuncDef *pFunc = sqlite3FindFunction( db, aAggs[i].zName,          strlen(aAggs[i].zName), aAggs[i].nArg, SQLITE_UTF8, 0);      if( pFunc && aAggs[i].needCollSeq ){        pFunc->needCollSeq = 1;      }    }  }  sqlite3RegisterDateTimeFunctions(db);#ifdef SQLITE_SSE  (void)sqlite3SseFunctions(db);#endif#ifdef SQLITE_CASE_SENSITIVE_LIKE  sqlite3RegisterLikeFunctions(db, 1);#else  sqlite3RegisterLikeFunctions(db, 0);#endif}/*** Set the LIKEOPT flag on the 2-argument function with the given name.*/static void setLikeOptFlag(sqlite3 *db, const char *zName, int flagVal){  FuncDef *pDef;  pDef = sqlite3FindFunction(db, zName, strlen(zName), 2, SQLITE_UTF8, 0);  if( pDef ){    pDef->flags = flagVal;  }}/*** Register the built-in LIKE and GLOB functions.  The caseSensitive** parameter determines whether or not the LIKE operator is case** sensitive.  GLOB is always case sensitive.*/void sqlite3RegisterLikeFunctions(sqlite3 *db, int caseSensitive){  struct compareInfo *pInfo;  if( caseSensitive ){    pInfo = (struct compareInfo*)&likeInfoAlt;  }else{    pInfo = (struct compareInfo*)&likeInfoNorm;  }  sqlite3CreateFunc(db, "like", 2, SQLITE_UTF8, pInfo, likeFunc, 0, 0);  sqlite3CreateFunc(db, "like", 3, SQLITE_UTF8, pInfo, likeFunc, 0, 0);  sqlite3CreateFunc(db, "glob", 2, SQLITE_UTF8,       (struct compareInfo*)&globInfo, likeFunc, 0,0);  setLikeOptFlag(db, "glob", SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE);  setLikeOptFlag(db, "like",       caseSensitive ? (SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE) : SQLITE_FUNC_LIKE);}/*** pExpr points to an expression which implements a function.  If** it is appropriate to apply the LIKE optimization to that function** then set aWc[0] through aWc[2] to the wildcard characters and** return TRUE.  If the function is not a LIKE-style function then** return FALSE.*/int sqlite3IsLikeFunction(sqlite3 *db, Expr *pExpr, int *pIsNocase, char *aWc){  FuncDef *pDef;  if( pExpr->op!=TK_FUNCTION ){    return 0;  }  if( pExpr->pList->nExpr!=2 ){    return 0;  }  pDef = sqlite3FindFunction(db, (char*)pExpr->token.z, pExpr->token.n, 2,                             SQLITE_UTF8, 0);  if( pDef==0 || (pDef->flags & SQLITE_FUNC_LIKE)==0 ){    return 0;  }  /* The memcpy() statement assumes that the wildcard characters are  ** the first three statements in the compareInfo structure.  The  ** asserts() that follow verify that assumption  */  memcpy(aWc, pDef->pUserData, 3);  assert( (char*)&likeInfoAlt == (char*)&likeInfoAlt.matchAll );  assert( &((char*)&likeInfoAlt)[1] == (char*)&likeInfoAlt.matchOne );  assert( &((char*)&likeInfoAlt)[2] == (char*)&likeInfoAlt.matchSet );  *pIsNocase = (pDef->flags & SQLITE_FUNC_CASE)==0;  return 1;}
./sqlitebrowser_1.3/sqlitebrowser/sqlite_source/table.c:/*** 2001 September 15**** The author disclaims copyright to this source code.  In place of** a legal notice, here is a blessing:****    May you do good and not evil.**    May you find forgiveness for yourself and forgive others.**    May you share freely, never taking more than you give.***************************************************************************** This file contains the sqlite3_get_table() and sqlite3_free_table()** interface routines.  These are just wrappers around the main** interface routine of sqlite3_exec().**** These routines are in a separate files so that they will not be linked** if they are not used.*/#include "sqliteInt.h"#include <stdlib.h>#include <string.h>#ifndef SQLITE_OMIT_GET_TABLE/*** This structure is used to pass data from sqlite3_get_table() through** to the callback function is uses to build the result.*/typedef struct TabResult {  char **azResult;  char *zErrMsg;  int nResult;  int nAlloc;  int nRow;  int nColumn;  int nData;  int rc;} TabResult;/*** This routine is called once for each row in the result table.  Its job** is to fill in the TabResult structure appropriately, allocating new** memory as necessary.*/static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){  TabResult *p = (TabResult*)pArg;  int need;  int i;  char *z;  /* Make sure there is enough space in p->azResult to hold everything  ** we need to remember from this invocation of the callback.  */  if( p->nRow==0 && argv!=0 ){    need = nCol*2;  }else{    need = nCol;  }  if( p->nData + need >= p->nAlloc ){    char **azNew;    p->nAlloc = p->nAlloc*2 + need + 1;    azNew = realloc( p->azResult, sizeof(char*)*p->nAlloc );    if( azNew==0 ) goto malloc_failed;    p->azResult = azNew;  }  /* If this is the first row, then generate an extra row containing  ** the names of all columns.  */  if( p->nRow==0 ){    p->nColumn = nCol;    for(i=0; i<nCol; i++){      if( colv[i]==0 ){        z = 0;      }else{        z = malloc( strlen(colv[i])+1 );        if( z==0 ) goto malloc_failed;        strcpy(z, colv[i]);      }      p->azResult[p->nData++] = z;    }  }else if( p->nColumn!=nCol ){    sqlite3SetString(&p->zErrMsg,       "sqlite3_get_table() called with two or more incompatible queries",       (char*)0);    p->rc = SQLITE_ERROR;    return 1;  }  /* Copy over the row data  */  if( argv!=0 ){    for(i=0; i<nCol; i++){      if( argv[i]==0 ){        z = 0;      }else{        z = malloc( strlen(argv[i])+1 );        if( z==0 ) goto malloc_failed;        strcpy(z, argv[i]);      }      p->azResult[p->nData++] = z;    }    p->nRow++;  }  return 0;malloc_failed:  p->rc = SQLITE_NOMEM;  return 1;}/*** Query the database.  But instead of invoking a callback for each row,** malloc() for space to hold the result and return the entire results** at the conclusion of the call.**** The result that is written to ***pazResult is held in memory obtained** from malloc().  But the caller cannot free this memory directly.  ** Instead, the entire table should be passed to sqlite3_free_table() when** the calling procedure is finished using it.*/int sqlite3_get_table(  sqlite3 *db,                /* The database on which the SQL executes */  const char *zSql,           /* The SQL to be executed */  char ***pazResult,          /* Write the result table here */  int *pnRow,                 /* Write the number of rows in the result here */  int *pnColumn,              /* Write the number of columns of result here */  char **pzErrMsg             /* Write error messages here */){  int rc;  TabResult res;  if( pazResult==0 ){ return SQLITE_ERROR; }  *pazResult = 0;  if( pnColumn ) *pnColumn = 0;  if( pnRow ) *pnRow = 0;  res.zErrMsg = 0;  res.nResult = 0;  res.nRow = 0;  res.nColumn = 0;  res.nData = 1;  res.nAlloc = 20;  res.rc = SQLITE_OK;  res.azResult = malloc( sizeof(char*)*res.nAlloc );  if( res.azResult==0 ) return SQLITE_NOMEM;  res.azResult[0] = 0;  rc = sqlite3_exec(db, zSql, sqlite3_get_table_cb, &res, pzErrMsg);  if( res.azResult ){    assert( sizeof(res.azResult[0])>= sizeof(res.nData) );    res.azResult[0] = (char*)res.nData;  }  if( rc==SQLITE_ABORT ){    sqlite3_free_table(&res.azResult[1]);    if( res.zErrMsg ){      if( pzErrMsg ){        free(*pzErrMsg);        *pzErrMsg = sqlite3_mprintf("%s",res.zErrMsg);      }      sqliteFree(res.zErrMsg);    }    db->errCode = res.rc;    return res.rc;  }  sqliteFree(res.zErrMsg);  if( rc!=SQLITE_OK ){    sqlite3_free_table(&res.azResult[1]);    return rc;  }  if( res.nAlloc>res.nData ){    char **azNew;    azNew = realloc( res.azResult, sizeof(char*)*(res.nData+1) );    if( azNew==0 ){      sqlite3_free_table(&res.azResult[1]);      return SQLITE_NOMEM;    }    res.nAlloc = res.nData+1;    res.azResult = azNew;  }  *pazResult = &res.azResult[1];  if( pnColumn ) *pnColumn = res.nColumn;  if( pnRow ) *pnRow = res.nRow;  return rc;}/*** This routine frees the space the sqlite3_get_table() malloced.*/void sqlite3_free_table(  char **azResult            /* Result returned from from sqlite3_get_table() */){  if( azResult ){    int i, n;    azResult--;    if( azResult==0 ) return;    n = (int)azResult[0];    for(i=1; i<n; i++){ if( azResult[i] ) free(azResult[i]); }    free(azResult);  }}#endif /* SQLITE_OMIT_GET_TABLE */
./sqsh_2.1/src/cmd_help.c:		sprintf( help_file, "%s/%s.1", help_dir, argv[1] ) ;
./sqsh_2.1/src/cmd_shell.c:			if ((r = varbuf_strcat( shell_cmd, argv[i] )) == -1)
./sqsh_2.1/src/sqsh_expand.c:				varbuf_strcat( buf, g_func_args[g_func_nargs-1].argv[i] );
./sqsh_2.1/src/sqsh_expand.c:		varbuf_strcat( buf, g_func_args[g_func_nargs-1].argv[arg_nbr] );
./squid3_3.0.STABLE8/helpers/ntlm_auth/SMB/ntlm_auth.c:	strcpy(d, argv[j]);
./sufary_2.1.1/array/array-main.c:	strcpy(Init_file_base,argv[2]);
./sufary_2.1.1/array/array-main.c:      sprintf(cmd, "%s %s", argv[1], argv[2]);
./sufary_2.1.1/mkary/mkary.c:	      strcpy(ary_fname,argv[2]);
./sufary_2.1.1/mkary/mkary.c:	    strcpy(in_fname, argv[1]); /* テキストファイル名 */
./sufary_2.1.1/mkdid/mkdid.c:        strcpy(ofname,argv[2]);
./sufary_2.1.1/tools/af.c:  sprintf(didfile,"%s.did",argv[2]);
./sufary_2.1.1/tools/tfidf.c:  sprintf(didfile,"%s.did",argv[2]);
./sunclock_3.56/editkit/termcap.c:			strcpy(ewin.name, argv[i]);
./sunclock_3.56/editkit/x11.c:				strcpy(ewin.name, argv[i]);
./survex_1.0.39.1/src/xcaverot.c:   sprintf(title, "%s - [%s]", hello, argv[optind]);
./sympa_5.3.4/src/bouncequeue.c:     strcpy(listname, argv[1]);
./sympa_5.3.4/src/familyqueue.c:      strcpy(listname, argv[1]);
./sympa_5.3.4/src/familyqueue.c:      strcpy(familyname, argv[2]);
./sympa_5.3.4/src/familyqueue.c:     sprintf(buffer,"%s: while changing dir to '%s'",argv[0],queuedir);
./sympa_5.3.4/src/familyqueue.c:     sprintf(buffer,"%s: while opening queue file '%s'",argv[0],qfile);
./sympa_5.3.4/src/queue.c:         strcpy(listname, argv[1]);
./sympa_5.3.4/src/queue.c:         strcpy(listname, argv[2]);
./sympa_5.3.4/src/queue.c:     sprintf(buffer,"%s: while changing dir to '%s'",argv[0],queuedir);
./sympa_5.3.4/src/queue.c:     sprintf(buffer,"%s: while opening queue file '%s'",argv[0],qfile);
./sympow_1.019/main.c:  {strcpy(INSTRING,argv[i+1]); i+=2;}
./sympow_1.019/main.c:  else if (!strcmp(argv[i],"-curve")) {strcpy(CSTR,argv[i+1]); i+=2;}
./sympow_1.019/main.c:  else if (!strcmp(argv[i],"-label")) {strcpy(LSTR,argv[i+1]); i+=2;}
./sysvinit_2.86.ds1/src/killall5.c:				strcpy(p->argv0, buf);
./sysvinit_2.86.ds1/src/killall5.c:				strcpy(p->argv1, buf);
./sysvinit_2.86.ds1/src/shutdown.c:  		strcat(message, argv[c]);
./sysvinit_2.86.ds1/src/wall.c:		strcat(buf, argv[f]);
./tachyon_0.98~beta.dfsg/demosrc/getargs.c:      strcpy(opt->filenames[opt->numfiles], argv[i]);        
./tachyon_0.98~beta.dfsg/demosrc/tgatoyuv.c:    sprintf(tganame, "%s.%04d.tga", argv[1], i);
./tachyon_0.98~beta.dfsg/demosrc/tgatoyuv.c:    sprintf(yuvname, "%s.%04d.yuv", argv[1], i);
./tcc_0.9.24/win32/tools/tiny_impdef.c:                strcpy(outfile, argv[n]);
./tcc_0.9.24/win32/tools/tiny_libmaker.c:                strcpy(afile, argv[i]);
./tcc_0.9.24/win32/tools/tiny_libmaker.c:        strcpy(arhdro.ar_name, argv[iarg]);
./tcl8.3_8.3.5/generic/tclCkalloc.c:	strcpy(curTagPtr->string, argv[2]);
./tcl8.3_8.3.5/generic/tclCkalloc.c:    strcpy(tclMemDumpFileName, argv[1]);
./tcl8.3_8.3.5/generic/tclPkg.c:		strcpy(availPtr->version, argv3);
./tcl8.3_8.3.5/generic/tclPkg.c:	    strcpy(availPtr->script, argv4);
./tcl8.3_8.3.5/generic/tclPkg.c:		    strcpy(iPtr->packageUnknown, argv2);
./tcl8.3_8.3.5/generic/tclTest.c:	strcpy(asyncPtr->command, argv[2]);
./tcl8.3_8.3.5/generic/tclTest.c:    strcpy(dPtr->deleteCmd, argv[3]);
./tcl8.3_8.3.5/generic/tclTest.c:		strcpy(stringVar, argv[5]);
./tcl8.3_8.3.5/generic/tclTest.c:		strcpy(stringVar, argv[5]);
./tcl8.3_8.3.5/generic/tclTest.c:    strcpy(buf, argv[2]);
./tcl8.3_8.3.5/mac/tclMacBOAMain.c:    strcpy(dumpFile, argv[1]);
./tcl8.3_8.3.5/unix/tclUnixPipe.c:	sprintf(errSpace, "%dcouldn't execute \"%.150s\": ", errno, argv[0]);
./tcl8.3_8.3.5/unix/tclUnixTest.c:	strcpy(tclDefaultEncodingDir, argv[1]);
./tcl8.4_8.4.19/generic/tclCkalloc.c:	strcpy(curTagPtr->string, argv[2]);
./tcl8.4_8.4.19/generic/tclCkalloc.c:    strcpy(tclMemDumpFileName, argv[1]);
./tcl8.4_8.4.19/generic/tclTest.c:	strcpy(asyncPtr->command, argv[2]);
./tcl8.4_8.4.19/generic/tclTest.c:    strcpy(dPtr->deleteCmd, argv[3]);
./tcl8.4_8.4.19/generic/tclTest.c:		strcpy(stringVar, argv[5]);
./tcl8.4_8.4.19/generic/tclTest.c:		strcpy(stringVar, argv[5]);
./tcl8.4_8.4.19/generic/tclTest.c:    strcpy(buf, argv[2]);
./tcl8.4_8.4.19/unix/tclUnixPipe.c:	sprintf(errSpace, "%dcouldn't execute \"%.150s\": ", errno, argv[0]);
./tcl8.4_8.4.19/unix/tclUnixTest.c:	strcpy(tclDefaultEncodingDir, argv[1]);
./tcl8.5_8.5.3/generic/tclCkalloc.c:	strcpy(curTagPtr->string, argv[2]);
./tcl8.5_8.5.3/generic/tclCkalloc.c:    strcpy(tclMemDumpFileName, argv[1]);
./tcl8.5_8.5.3/generic/tclTest.c:	strcpy(asyncPtr->command, argv[2]);
./tcl8.5_8.5.3/generic/tclTest.c:    strcpy(dPtr->deleteCmd, argv[3]);
./tcl8.5_8.5.3/generic/tclTest.c:		strcpy(stringVar, argv[5]);
./tcl8.5_8.5.3/generic/tclTest.c:		strcpy(stringVar, argv[5]);
./tcl8.5_8.5.3/generic/tclTest.c:    strcpy(buf, argv[2]);
./tcl8.5_8.5.3/unix/tclUnixPipe.c:	sprintf(errSpace, "%dcouldn't execute \"%.150s\": ", errno, argv[0]);
./tcludp_1.0.8/generic/udp_tcl.c:                strcpy(statePtr->remotehost, argv[2]);
./tennix_0.6.1/data/data2csrc.c:    strcpy( filename, argv[1]);
./tennix_0.6.1/data/data2csrc.c:        strcpy( varname, argv[1]);
./tennix_0.6.1/data/data2csrc.c:        strcpy( varname, argv[2]);
./testdisk_6.9/src/photorec.c:        strcpy(new_recup_dir,argv[i+1]);
./tk8.4_8.4.19/generic/tkTest.c:	    strcpy((char *) ckalloc(strlen(argv[3]) + 1), argv[3]);
./tk8.4_8.4.19/generic/tkTest.c:		strcpy((char *) ckalloc(strlen(argv[4]) + 1), argv[4]);
./tk8.4_8.4.19/mac/tkMacWm.c:    strcpy(wmPtr->clientMachine, argv3);
./tk8.4_8.4.19/mac/tkMacWm.c:	strcpy(wmPtr->leaderName, argv3);
./tk8.4_8.4.19/mac/tkMacWm.c:	strcpy(wmPtr->iconName, argv3);
./tk8.4_8.4.19/mac/tkMacWm.c:	strcpy(wmPtr->title, argv3);
./tk8.4_8.4.19/mac/tkMacWm.c:	strcpy(wmPtr->masterWindowName, argv3);
./tk8.4_8.4.19/macosx/tkMacOSXWm.c:    strcpy(wmPtr->clientMachine, argv3);
./tk8.4_8.4.19/macosx/tkMacOSXWm.c:	strcpy(wmPtr->leaderName, argv3);
./tk8.4_8.4.19/macosx/tkMacOSXWm.c:	strcpy(wmPtr->iconName, argv3);
./tk8.4_8.4.19/macosx/tkMacOSXWm.c:	strcpy(wmPtr->masterWindowName, argv3);
./tk8.4_8.4.19/unix/tkUnixWm.c:    strcpy(wmPtr->clientMachine, argv3);
./tk8.4_8.4.19/unix/tkUnixWm.c:	strcpy(wmPtr->leaderName, argv3);
./tk8.4_8.4.19/unix/tkUnixWm.c:	strcpy(wmPtr->iconName, argv3);
./tk8.4_8.4.19/unix/tkUnixWm.c:	strcpy(wmPtr->title, argv3);
./tk8.4_8.4.19/win/tkWinWm.c:    strcpy(wmPtr->clientMachine, argv3);
./tk8.4_8.4.19/win/tkWinWm.c:	strcpy(wmPtr->leaderName, argv3);
./tk8.4_8.4.19/win/tkWinWm.c:	strcpy(wmPtr->iconName, argv3);
./tk8.4_8.4.19/win/tkWinWm.c:	strcpy(wmPtr->title, argv3);
./tk8.5_8.5.3/generic/tkTest.c:	    strcpy((char *) ckalloc(strlen(argv[3]) + 1), argv[3]);
./tk8.5_8.5.3/generic/tkTest.c:		strcpy((char *) ckalloc(strlen(argv[4]) + 1), argv[4]);
./tk8.5_8.5.3/macosx/tkMacOSXWm.c:    strcpy(wmPtr->clientMachine, argv3);
./tk8.5_8.5.3/macosx/tkMacOSXWm.c:	strcpy(wmPtr->leaderName, argv3);
./tk8.5_8.5.3/macosx/tkMacOSXWm.c:	strcpy(wmPtr->iconName, argv3);
./tk8.5_8.5.3/macosx/tkMacOSXWm.c:	strcpy(wmPtr->masterWindowName, argv3);
./tk8.5_8.5.3/unix/tkUnixWm.c:    strcpy(wmPtr->clientMachine, argv3);
./tk8.5_8.5.3/unix/tkUnixWm.c:	strcpy(wmPtr->leaderName, argv3);
./tk8.5_8.5.3/unix/tkUnixWm.c:	strcpy(wmPtr->iconName, argv3);
./tk8.5_8.5.3/unix/tkUnixWm.c:	strcpy(wmPtr->title, argv3);
./tk8.5_8.5.3/win/tkWinWm.c:    strcpy(wmPtr->clientMachine, argv3);
./tk8.5_8.5.3/win/tkWinWm.c:	strcpy(wmPtr->leaderName, argv3);
./tk8.5_8.5.3/win/tkWinWm.c:	strcpy(wmPtr->iconName, argv3);
./tk8.5_8.5.3/win/tkWinWm.c:	strcpy(wmPtr->title, argv3);
./tolua_5.1b/src/bin/tolua.c:  strcpy(path,argv[0]);
./tome_2.3.5/src/lua/tolua.c:  strcpy(path,argv[0]);
./tome_2.3.5/src/main.c:				strcpy(player_name, &argv[i][2]);
./tome_2.3.5/src/main.c:				strcpy(player_base, &argv[i][2]);
./tree-puzzle_5.2/src/puzzle1.c:            strcpy(INFILE, (*argv)[n]);
./tree-puzzle_5.2/src/puzzle1.c:               strcpy(INTREE, (*argv)[n]);
./tremulous_1.1.0/src/qcommon/cmd.c:		strcat( cmd_args, cmd.argv[i] );
./tremulous_1.1.0/src/qcommon/cmd.c:		strcat( cmd_args, cmd.argv[i] );
./tremulous_1.1.0/src/unix/unix_main.c:    strcat(cmdline, argv[i]);
./tth_3.67/tth.c:      strcpy(tth_latex_file,argv[i]);
./tth_3.67/tth.c:      case 'k': strcpy(tth_latex_file,argv[i]+2);break;
./tth_3.67/tth.c:	strcpy(tth_latex_file,argv[i]+2);
./tth_3.67/tth.c:      case 'x':strcpy(tth_index_cmd,argv[i]+2);break;
./tuxpaint_0.9.20/src/tuxpaint.c:        strcpy(colorfile, argv[i + 1]);
./tuxpuck_0.8.2/utils/anim.c:    sprintf(buffer2, "%s%s", argv[1], buffer1);
./tuxpuck_0.8.2/utils/data2c.c:  sprintf(buffer, "%s.c", argv[2]);
./uml-utilities_20070815/mconsole/uml_mconsole.c:    strcat(command, argv[i]);
./unace_1.2b/unace.c:      strcpy(aname, argv[arg_cnt]);              // get archive name
./unpaper_0.3/src/unpaper.c:        strcpy(s1, argv[*i]); // argv[*i] -> s1
./uqwk_2.21/options.c:					                strcpy(auth_user,&argv[i][2]);
./uqwk_2.21/options.c:			case 'I':	strcpy(inews_path,&argv[i][2]);
./util-linux_2.13.1.1/getopt/getopt.c:		strcpy(optstr,argv[1]+strspn(argv[1],"-+"));
./util-linux_2.13.1.1/getopt/getopt.c:			strcpy(optstr,argv[optind]);
./util-linux_2.13.1.1/misc-utils/setterm.c:		strcpy((char *)opt_all, argv[0]);
./util-vserver_0.30.216~r2772/src/save_ctxinfo.c:  strcpy(runfile,      argv[1]);
./uucp_1.07/contrib/uurate.c:      strcpy(Pgm_name,argv[0]);
./uucp_1.07/contrib/xchat.c:  strcat(sfname, argv[1]);	/* Add the script file name */
./uucpsend_1.1/uucpsend.c:      strcat(arg_sites, argv[optind++]);
./vbpp_1.1.0/vpp.c:				strcpy(lname, argv[i]+8);
./vbpp_1.1.0/vpp.c:				sprintf(dname, "`define %s", argv[i]+2);
./vbpp_1.1.0/vpp.c:			strcpy(t->name, argv[i]);
./viewmol_2.4.1/source/bio.c:  strcpy(hessian, argv[1]);
./viewmol_2.4.1/source/input.c:            sprintf(command, options[i].command, argv[n+1]);
./viewmol_2.4.1/source/input.c:          sprintf(line, word, --argv[n]);
./viewmol_2.4.1/source/readmopac.c:  strcpy(f, argv[1]);
./vlc_0.8.6.h/src/extras/getopt.c:		sprintf(var, "_%d_GNU_nonoption_argv_flags_", getpid());
./vnc4_4.1.1+X4.3.0/unix/xc/config/util/checktree.c:	    strcpy(buf, *argv++);
./vnc4_4.1.1+X4.3.0/unix/xc/extras/FreeType/contrib/ftos2/ifi/test.c:         strcpy(fname, argv[1]);
./vnc4_4.1.1+X4.3.0/unix/xc/extras/FreeType/contrib/ftos2/ifi/test.c:         strcpy(fname, argv[1]);
./vnc4_4.1.1+X4.3.0/unix/xc/extras/FreeType/contrib/ttf2pk/ttf2tfm.c:  sprintf(fnt->titlebuf, "%s %s", progname, argv[1]);
./vnc4_4.1.1+X4.3.0/unix/xc/extras/FreeType/contrib/ttf2pk/ttf2tfm.c:  sprintf(fnt->titlebuf, "%s %s", argv[0], argv[1]);
./vnc4_4.1.1+X4.3.0/unix/xc/extras/FreeType/contrib/ttf2pk/ttf2tfm.c:      sprintf(fnt->titlebuf + strlen(fnt->titlebuf), " %s", argv[2]);
./vnc4_4.1.1+X4.3.0/unix/xc/extras/FreeType/contrib/ttf2pk/ttf2tfm.c:    sprintf(fnt->titlebuf + strlen(fnt->titlebuf), " %s", argv[2]);
./vnc4_4.1.1+X4.3.0/unix/xc/extras/regex/split.c:			(void) strcpy(buf, argv[1]);
./vnc4_4.1.1+X4.3.0/unix/xc/extras/regex/split.c:			(void) strcpy(buf, argv[1]);
./vnc4_4.1.1+X4.3.0/unix/xc/extras/rman/rman.c:		strcpy(plain,argvch[optind]);
./vnc4_4.1.1+X4.3.0/unix/xc/lib/font/Speedo/htest.c:sprintf(pathname, argv[1]);
./vnc4_4.1.1+X4.3.0/unix/xc/lib/font/Speedo/nsample.c:sprintf(pathname, argv[1]);
./vnc4_4.1.1+X4.3.0/unix/xc/lib/X11/SetHints.c:		    (void) strcpy(bp, argv[i]);
./vnc4_4.1.1+X4.3.0/unix/xc/programs/luit/luit.c:        strcpy(path, argv[0]);
./vnc4_4.1.1+X4.3.0/unix/xc/programs/xfwp/misc.c:	strcpy(config_info->pm_listen_port, argv[arg_counter + 1]);
./vnc4_4.1.1+X4.3.0/unix/xc/programs/xfwp/misc.c:	strcpy(config_info->config_file_path, argv[arg_counter + 1]);
./vnc4_4.1.1+X4.3.0/unix/xc/programs/xfwp/misc.c:        strcpy(config_info->log_file_path, argv[arg_counter + 1]);
./vnc4_4.1.1+X4.3.0/unix/xc/programs/xmessage/xmessage.c:	    strcpy(cp, argv[i]);
./vnc4_4.1.1+X4.3.0/unix/xc/programs/xrx/plugin/Main.c:	strcpy(value, argv2[i]);
./vnc4_4.1.1+X4.3.0/unix/xc/programs/xrx/xnest-plugin/SetWin.c:		sprintf(argv[2], ":%d", This->display_num);
./vnc4_4.1.1+X4.3.0/unix/xc/programs/xrx/xnest-plugin/SetWin.c:		sprintf(argv[4], "%ld", This->window);
./vnc4_4.1.1+X4.3.0/unix/xc/programs/Xserver/hw/xfree86/common/xf86Init.c:      strcpy(mp, argv[i + 1]);
./vnc4_4.1.1+X4.3.0/unix/xc/programs/Xserver/hw/xfree86/common/xf86Init.c:      strcpy(lf, argv[i + 1]);
./vnc4_4.1.1+X4.3.0/unix/xc/programs/xterm/resize.c:	sprintf(buf, setsize[emu], argv[0], argv[1]);
./vobcopy_1.1.0/vobcopy.c:      strcpy( vobcopy_call, argv[0] );
./vobcopy_1.1.0/vobcopy.c:          strcat( vobcopy_call, argv[argc_i] );
./vpb-driver_4.2.38.1/src/libpri/pritest-s.c:        strcpy((char *)sa.sll_device,(char *)argv[2]);
./vpb-driver_4.2.38.1/src/libpri/pritest-s.c:        strcpy((char *)sa.sll_card,(char *)argv[1]);
./vzctl_3.0.22/src/vzctl-actions.c:				sprintf(buf + totallen, "%s ", argv[i]);
./wackamole_2.1.1/ife.c:    strcpy(req.ifname, argv[i++]);
./wackamole_2.1.1/ife.c:    strcpy(req.ifname, argv[i++]);
./wackamole_2.1.1/wackamole.c:	  strcpy( User, argv[1] );
./wackamole_2.1.1/wackamole.c:	  strcpy( Spread_name, argv[1] );
./wackamole_2.1.1/wackamole.c:	    strcpy(File_name, argv[1]);
./wackamole_2.1.1/wackamole.c:	    strcat(File_name, argv[1] );
./wap-wml-tools_0.0.4/wbmp/wbmp2xpm.c:	strcpy(of, argv[1]);
./warsow_0.42.dfsg1/warsow_0.42_src/source/qcommon/cmd.c:			strcpy( cmd_argv[cmd_argc], com_token );
./watchdog_5.4/src/mount.c:    strcpy(argv0[0], PROC_NAME);
./wcd_3.2.0/wcd.c:               strcat(tmp,argv[i]);
./wcd_3.2.0/wcd.c:               strcat(tmp,argv[i]);
./wcd_3.2.0/wfixpath.c:	  strcpy(fixed,argv[1]);
./whois_4.7.30/whois.c:	    strcat(qstring, *argv++);
./wiggle_0.6/wiggle.c:			strcpy(replacename, argv[optind]);
./wiggle_0.6/wiggle.c:			strcpy(orignew, argv[optind]);
./wings3d_0.99.03/win32/wings3d.c:    sprintf(cmd_line+strlen(cmd_line), " \"%s\"", argv[1]);
./wininfo_0.7/src/ewmhview.c:            data += sprintf( data, "%s ", argv[ i ] );
./wip_2p3/src/plot/wedge.c:      (void)strcpy(device, argv[1]);
./wireshark_1.0.2/tools/lemon/lemon.c:    if( path ) sprintf(path,"%s/%s",argv0,name);
./wise_2.4.1/src/dyc/dyc.c:	sprintf(buffer,"%s.c",argv[i]);
./wise_2.4.1/src/dyc/dyc.c:	sprintf(buffer,"%s.h",argv[i]);
./wise_2.4.1/src/HMMer2/plan7.c:      strcat(hmm->comlog, argv[i]);
./wmgrabimage_0.72/wmGrabImage/wmGrabImage.c:            strcpy(ImageURL, argv[++i]);
./wmgrabimage_0.72/wmGrabImage/wmGrabImage.c:            strcpy(HttpURL, argv[++i]);
./wmmatrix_0.2/wmMatrix.c:            strcpy(TimeColor, argv[++i]);
./wmmatrix_0.2/wmMatrix.c:            strcpy(BackgroundColor, argv[++i]);
./wmmatrix_0.2/wmMatrix.c:	    strcpy(ExecuteCommand, argv[++i]);
./wmmoonclock_1.27/Src/wmMoonClock.c:            strcpy(BackColor, argv[++i]);
./wmmoonclock_1.27/Src/wmMoonClock.c:            strcpy(LabelColor, argv[++i]);
./wmmoonclock_1.27/Src/wmMoonClock.c:            strcpy(DataColor, argv[++i]);
./wmpinboard_1.0/src/getopt.c:		sprintf(var, "_%d_GNU_nonoption_argv_flags_", getpid());
./wmsensors_1.0.4/wmsensors.c:        strcpy(&Execute2[0], argv[i]);
./wmsensors_1.0.4/wmsensors.c:        strcpy(&config_file_name[0], argv[i]);
./wmspaceweather_1.04/wmSpaceWeather/wmSpaceWeather.c:            strcpy(URL, argv[++i]);
./wsola_4.9/examples/old/sox/fade.c:    strcpy(fade->in_stop_str,argv[0]);
./wsola_4.9/examples/old/sox/fade.c:             strcpy(fade->out_stop_str,argv[t_argno]);
./wsola_4.9/examples/old/sox/fade.c:             strcpy(fade->out_start_str,argv[t_argno]);
./wsola_4.9/examples/old/sox/silence.c:        strcpy(silence->start_duration_str,argv[0]);
./wsola_4.9/examples/old/sox/silence.c:        strcpy(silence->stop_duration_str,argv[0]);
./wsola_4.9/examples/old/sox/synth.c:        strcpy(synth->length_str,argv[argn]);
./wsola_4.9/examples/old/sox/trim.c:            strcpy(trim->length_str,argv[1]);
./wsola_4.9/examples/old/sox/trim.c:            strcpy(trim->start_str,argv[0]);
./wu-ftpd_2.6.2/src/private.c:		    strcpy(aptr->gname, (char *) argv[0]);
./wu-ftpd_2.6.2/src/private.c:			strcpy(aptr->gpass, (char *) argv[1]);
./wu-ftpd_2.6.2/src/private.c:		    strcpy(aptr->gname, (char *) argv[0]);
./wu-ftpd_2.6.2/src/private.c:			strcpy(aptr->gpass, (char *) argv[1]);
./wu-ftpd_2.6.2/src/private.c:		    strcpy(aptr->gr_name, (char *) argv[2]);
./wu-ftpd_2.6.2/util/privatepw/privatepw.c:    strcpy(accessgroup, argv[optind]);
./wxwidgets2.8_2.8.7.1/src/msw/winestub.c:  if (argc > 1) strcpy(lpszCmdParam, argv[1]);
./wxwidgets2.8_2.8.7.1/src/msw/winestub.c:  for (i = 2; i < argc; i++) strcat(strcat(lpszCmdParam, " "), argv[i]);
./xbindkeys-config_0.1.3/xbindkeys_config.c:       if(i+1<argc) strcpy(buf,argv[++i]);
./xbl_1.1.5/initwin.c:#define ADDARG(X) { sprintf(pc,"%s",X) ; argv[i++] = pc ; pc += strlen(pc)+1 ; }
./xcin_2.5.2.99.pre2+cvs20030224/src/Cinput/chewing/sort_dic.c:    strcpy( in_file, argv[1]);
./xcin_2.5.2.99.pre2+cvs20030224/src/lib/siod/slibu.c: sprintf(nargv[j],"%s%c%s",offbuff,VLOAD_OFFSET_HACK_CHAR,argv[0]);
./xcircuit_3.6.135.dfsg/tclxcircuit.c:	       strcat(_STR2, argv);
./xcircuit_3.6.135.dfsg/xtgui.c:      strcpy(_STR2, argv[(k == 1) ? 2 : 1]);
./xen-3_3.2.1/tools/misc/lomount/lomount.c:			strcat(argv2, argv[i]);
./xen-3_3.2.1/tools/misc/lomount/lomount.c:			strcat(argv2, " ");
./xenomai_2.4.4/examples/rtdm/driver-api/tut02-skeleton-app.c:		sprintf(buf, "%s", argv[1]);
./xfig_3.2.5-rel/f_util.c:	strcpy(file,argv[i]);
./xfig_3.2.5-rel/main.c:		    safe_strcpy(argv[i+1],p);
./xfishtank_2.2/fishtogif/fishtogif.c:		strcpy(outname, argv[2]);
./xfishtank_2.2/gofish/gofish.c:		strcpy(Head, argv[1]);
./xfonts-utils_7.4+1/font-util/ucs2any.c:		zstrcpy(&fmap, argv[ai]);
./xfonts-utils_7.4+1/mkfontscale/mkfontscale.c:            encodingPrefix = dsprintf("%s", argv[argn + 1]);
./xfractint_20.4.00/cmdfiles.c:      strcpy(curarg,argv[i]);
./xfractint_20.4.00/help.c:      strcpy(path, _argv[0]);
./xfractint_20.4.00/help.c:      strcpy(path, __argv[0]);   /* note: __argv may be undocumented in MSC */
./xfsdump_2.2.48/common/main.c:	sprintf( p, "%s ", ( * argvp )[ i ] );
./xfsdump_2.2.48/common/main.c:		sprintf( p, "%s ", ( * argvp )[ i ] );
./xindy_2.3/rte/clisp-2.43/src/_clisp.c:      strcat(linkingsetdir, argv_linkingset);
./xindy_2.3/rte/clisp-2.43/src/_clisp.c:        strcpy(argv_memfile, linkingsetdir);
./xindy_2.3/rte/clisp-2.43/src/_clisp.c:        strcat(argv_memfile, "/");
./xindy_2.3/rte/clisp-2.43/src/_clisp.c:        strcat(argv_memfile, filename);
./xine-ui_0.99.5+cvs20070914/src/xitk/main.c:	  sprintf(session_argv[session_argv_num], "mrl=%s", p);
./xjdic_24/xjdfrontend.c:			strcpy(xap,argv[i]);
./xjdic_24/xjdfrontend.c:					strcpy(xap,argv[i]);
./xjdic_24/xjdfrontend.c:					strcpy(xap,argv[i]);
./xjdic_24/xjdfrontend.c:					strcpy(xap,argv[i]);
./xjdic_24/xjdfrontend.c:					strcpy(xap,argv[i]);
./xjdic_24/xjdfrontend.c:					strcpy(xap,argv[i]);
./xjdic_24/xjdfrontend.c:					strcpy(xap,argv[i]);
./xjdic_24/xjdfrontend.c:					strcpy(xap,argv[i]);
./xjdic_24/xjdserver.c:			strcpy(xap,argv[i]);
./xjdic_24/xjdserver.c:					strcpy(xap,argv[i]);
./xjdic_24/xjdserver.c:					strcpy(xap,argv[i]);
./xjdic_24/xjdserver.c:					strcpy(xap,argv[i]);
./xjdic_24/xjdserver.c:					strcpy(xap,argv[i]);
./xlife_5.0/collect.c:       strcpy(outbuf,checktilda(argv[1]));
./xorg-server_1.4.2/hw/dmx/examples/ev.c:        sprintf(name, "/dev/input/event%d", atoi(argv[1]));
./xorg-server_1.4.2/hw/xfree86/common/xf86Init.c:      strcpy(mp, argv[i + 1]);
./xorg-server_1.4.2/hw/xfree86/common/xf86Init.c:      strcpy(lf, argv[i + 1]);
./xotcl_1.6.1/library/store/XOTclSdbm/xotclsdbm.c:            sprintf(buf, BAD_MODE, argv[0], argv[2]);
./xsok_1.02/src/combine.c:	sprintf(s, "%s.def", argv[c]);
./xsok_1.02/src/combine.c:	sprintf(s, "%s/definitions", argv[c]);
./xsok_1.02/src/combine.c:	    sprintf(s, "%s/screen.%02d", argv[c], i);
./xtermset_0.5.2/src/xtermset.c:                    strcpy(fn[code],argv[++i]);
./xtrkcad_4.0.2/app/bin/ctodesgn.c:	strcpy( newTurnManufacturer, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnRightDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnRightPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnRightDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnRightPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnRightDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnRightPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnRightDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnRightPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnRightDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnRightPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftPartno, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftDesc, *argv++ );
./xtrkcad_4.0.2/app/bin/ctodesgn.c:		strcpy( newTurnLeftPartno, *argv++ );
./xtrkcad_4.0.2/app/tools/bin2c.c:    strcpy(Dummy,argv[2]);     
./xtrkcad_4.0.2/app/tools/bin2c.c:    strcpy(Dummy,argv[3]);     
./xtrkcad_4.0.2/dxf/dxf.c:	strcpy(inname, argv[1]);	/* make copy we can mess with */
./xtrkcad_4.0.2/dxf/dxf.c:		strcpy(outname, argv[2]);
./yagiuda_1.19/src/getfiles.c:	strcpy(input, argv[optind]);
./yagiuda_1.19/src/getfiles.c:	strcpy(output, argv[optind]);
./yagiuda_1.19/src/optimise.c:	strcpy(update_filename,argv[optind]); 
./yagiuda_1.19/src/optimise.c:	strcpy(input_filename,argv[optind]);
./yagiuda_1.19/src/output.c:	strcpy(input_filename, argv[optind]);
./yagiuda_1.19/src/output.c:	strcpy(original_filename, argv[optind]);
./yagiuda_1.19/src/output.c:	strcpy(output_filename, *(argv+optind));
./yagiuda_1.19/src/output.c:	strcpy(gain_filename, *(argv+optind));
./yasm_0.7.0/libyasm/genmodule.c:    strcpy(inc->filename, argv[2]);
./yaz_3.0.34/src/test.c:    sprintf(logfilename,"%s.log", progname(argv0) );
./yeahconsole_0.3.4/yeahconsole.c:	pos += sprintf(pos, "%s ", argv[i]);
./yorick_2.1.05+dfsg/play/unix/umain.c:      argv[0] = p_strcpy(u_track_link(u_find_exe(argv[0])));
./yorick_2.1.05+dfsg/play/win/wspawn.c:      strcpy(cmdline+cmdlen+1, argv[nargs]);
./yorick_2.1.05+dfsg/play/win/wspawn.c:      strcpy(cmdline+cmdlen, argv[nargs]);
./yorick_2.1.05+dfsg/yorick/spawn.c:  proc->argv0 = p_strcpy(argv[0]);
./yorick_2.1.05+dfsg/yorick/std0.c:  yLaunchDir = p_strcpy(ym_argc>0? ym_argv[0] : 0);
./yorick_2.1.05+dfsg/yorick/std0.c:    for (i=0 ; i<ym_argc ; i++) result->value.q[i]= p_strcpy(ym_argv[i]);
./ysmv7_2.9.9/src/YSM_os2.c:		strcat(os2_cmd,argv[x]);
./yudit_2.8.1/doc/notinstalled/ttf2pfa.c:		sprintf(filename, "%s.pfa", argv[2]) ;
./yudit_2.8.1/doc/notinstalled/ttf2pfa.c:		sprintf(filename, "%s.afm", argv[2]) ;
./z88dk_1.8.ds1/src/cpp/cpp1.c:		strcpy(work, argv[1]);	/* Remember input filename	*/
./z88dk_1.8.ds1/support/oz/makewzd.c:    strcpy(name,argv[1]);
./z88dk_1.8.ds1/support/oz/makewzd.c:    strcpy(name,argv[1]);
./z88dk_1.8.ds1/support/zx/tapmaker.c:		strcpy(name,argv[1]);
./zangband_2.7.5pre1/src/lua/tolua.c:  strcpy(path,argv[0]);
./zapping_0.10~cvs6/src/zapping_remote.c:        strcpy(pass + len, argv[i]),
./zephyr_2.1.20070719.SNAPSHOT/clients/zaway/zaway.c:		(void) strcpy(awayfile,argv[optind]);
./zephyr_2.1.20070719.SNAPSHOT/clients/zctl/zctl.c:			(void) sprintf(ssline+strlen(ssline),"%s ",argv[i]);
./zephyr_2.1.20070719.SNAPSHOT/clients/zctl/zctl.c:		(void) strcpy(subsname,argv[1]);
./zephyr_2.1.20070719.SNAPSHOT/clients/zctl/zctl.c:		(void) strcpy(varcat,argv[2]);
./zephyr_2.1.20070719.SNAPSHOT/clients/zctl/zctl.c:			(void) strcat(varcat,argv[i]);
./zephyr_2.1.20070719.SNAPSHOT/clients/znol/znol.c:				(void) strcpy(anyonename,argv[++arg]);
./zephyr_2.1.20070719.SNAPSHOT/clients/znol/znol.c:				(void) strcpy(cleanname,argv[++arg]);
./zephyr_2.1.20070719.SNAPSHOT/clients/zwrite/zwrite.c:	    (void) strcpy(message+msgsize, argv[arg]);
./zip_2.32/windll/example.c:    lstrcpy(sz, argv[i+2]);
./zip_2.32/zip.c:          strcpy(tempath, argv[i]);
./zip_2.32/zip.c:          strcpy(key, argv[i]);
./zip_2.32/zip.c:        strcat(strcat(errbuf, argv[i]), "\" ");
./zip_2.32/zip.c:      strcat(strcat(errbuf, argv[i]), " *.* -i");
./zip_2.32/zip.c:        strcat(strcat(errbuf, " "), argv[i]);
./zip_2.32/zip.c:        strcat(strcat(errbuf, " "), argv[i]);
./zsh_4.3.6/Src/builtin.c:	strcpy(d + len3, argv[1]);
./zsh_4.3.6/Src/exec.c:		    strcpy(s, exec_argv0);
./zsh-beta_4.3.6-dev-0+20080723/Src/builtin.c:	strcpy(d + len3, argv[1]);
./zsh-beta_4.3.6-dev-0+20080723/Src/exec.c:		    strcpy(s, exec_argv0);
./zsnes_1.510/src/zloader.c:            strcpy(libAoDriver, argv[i]);
./zziplib_0.13.49/bins/zzobfuscated.c:            sprintf(name, "obfuscated/%s", argv[argn]);
./zzuf_0.12/src/zzuf.c:    strcpy(libpath, opts->oldargv[0]);
./9menu_1.8/9menu.c:			strcpy(f_argv[nlabels], s);
./aolserver4_4.5.0/nsext/nsext.c:            sprintf(interp->result, "Trace is on, using file: %s", argv[3]);
./aolserver4_4.5.0/nsext/nsext.c:            sprintf(interp->result, "Max rows set to %s", argv[3]);
./apbs_1.0.0/contrib/maloc/src/vsh/vpars.c:        strcpy(inbuf_argv,inbuf);
./apbs_1.0.0/contrib/maloc/src/vsh/vsh.c:    sprintf(PR_TMP,"%s: %s",PR,argv[0]);
./apbs_1.0.0/contrib/maloc/src/vsh/vsh.c:                strcat(buf,argv[i]);
./apbs_1.0.0/tools/mesh/mergedx.c:                    sprintf(outname,"%s",argv[i]);
./apbs_1.0.0/tools/mesh/mergedx2.c:			strcpy(fnams[numfnams],argv[optind++]);
./argtable2_9/src/getopt.c:		sprintf(var, "_%d_GNU_nonoption_argv_flags_", getpid());
./argus_2.0.6.fixes.1/server/argus.c:      strcpy(path, argv[0]);
./ascdc_0.3/ascdc.c:				strcpy(&device[0], argv[i]);
./ascdc_0.3/ascdc.c:				strcpy(mountdir, argv[i]);
./ascdc_0.3/ascdc.c:				strcpy(cdplayer, argv[i]);
./atlc_4.6.0/src/non_gui/atlc.c:    (void) strcpy(inputfile_name, argv[my_optind]);
./atlc_4.6.0/src/non_gui/find_optimal_dimensions_for_microstrip_coupler.c:    (void) strcpy(outfile_name, argv[my_optind+6]);
./atlc_4.6.0/tests/benchmark.c:  sprintf(str,"%s -s -S -t0 %s > /dev/null 2> /dev/null \n", argv[1], argv[2]);
./atlc_4.6.0/tests/benchmark.c:  sprintf(str,"%s -s -S %s > /dev/null\n", argv[1], argv[2]);
./atmel-firmware_1.3/atmel_fwl.c:	strcpy(ifr.ifr_ifrn.ifrn_name, argv[1]);
./audacity_1.3.5/lib-src/libnyquist/cmt/cmdline.c:            strcpy(argv[i], arg);
./audacity_1.3.5/lib-src/libnyquist/misc/cmdline.c:            strcpy((*argvp)[i], arg);
./autofs_4.1.4+debian/modules/parse_sun.c:				strcpy(noptstr + optlen + 1, argv[i] + offset);
./autofs_4.1.4+debian/modules/parse_sun.c:				strcpy(noptstr, argv[i] + offset);
./bacula_2.4.4/src/dird/ua_label.c:      pm_strcpy(ua->cmd, ua->argv[i]);
./bacula_2.4.4/src/dird/ua_restore.c:         pm_strcat(rx->JobIds, ua->argv[i]);
./bacula_2.4.4/src/dird/ua_restore.c:         pm_strcpy(ua->cmd, ua->argv[i]);
./bibcursed_2.0.0/bibcursed.c:   strcpy(bibfile, argv[1]);
./bibindex_2.10/bibindex.c:    (void)sprintf(infile, "%s.bib", argv[1]);
./bibindex_2.10/bibindex.c:    (void)sprintf(outfile, "%s.bix", argv[1]);
./bibindex_2.10/biblook.c:	(void)sprintf(bibfile, "%s.bib", argv[1]);
./bibindex_2.10/biblook.c:	(void)sprintf(bixfile, "%s.bix", argv[1]);
./bibindex_2.10/biblook.c:		(void)sprintf(bibfile, "%s/%s.bib", path, argv[1]);
./bibindex_2.10/biblook.c:		(void)sprintf(bixfile, "%s/%s.bix", path, argv[1]);
./bibindex_2.10/biblook.c:		(void)sprintf(bibfile, "%s.bib", argv[1]);
./bibindex_2.10/biblook.c:		(void)sprintf(bixfile, "%s.bix", argv[1]);
./bibindex_2.10/biblook.c:	    (void)sprintf(bibfile, "%s.bib", argv[1]);
./bochs_2.3.7/misc/bximage.c:      strcpy(bx_filename, argv[arg]);
./boxshade_3.3.1/box.c:    strcat(cl, argv[idx]);
./boxshade_3.3.1/bx_misc.c:      strcat(cl, P_argv[i]);
./canna_3.7p3/ccustom/ccustom.c:	  strcpy(initFileSpecified, argv[i]);
./canna_3.7p3/cmd/cannastat/cannastat.c:	    strcpy( cannahostname, argv[i] ) ;
./canna_3.7p3/cmd/catdic/can.c:	(void)strcat(init,argv[1]);
./canna_3.7p3/cmd/crfreq/crfreq.c:	strcpy(freq, argv[i]);
./canna_3.7p3/cmd/crxdic/crxdic.c:	strcpy(outfile, argv[i]);
./canna_3.7p3/cmd/crxdic/crxdic.c:	strcpy(dicname, argv[i]);
./canna_3.7p3/cmd/crxdic/crxdic.c:      strcpy(textfile, argv[i]);
./canna_3.7p3/cmd/dpxdic/dpxdic.c:  (void)strcpy(bn, argv[i]);
./canna_3.7p3/server/misc.c:    strcpy( Name, argv[ 0 ] );
./canna_3.7p3/server/misc.c:		strcpy( (char *)ddname, argv[ i ] );
./cdebconf_0.138lenny3/src/commands.c:        asprintf(&out, "%u %s doesn't exist", CMDSTATUS_BADQUESTION, argv[0]);
./cdebconf_0.138lenny3/src/commands.c:        asprintf(&out, "%u %s doesn't exist", CMDSTATUS_BADQUESTION, argv[0]);
./cdebconf_0.138lenny3/src/commands.c:        asprintf(&out, "%u No such template, \"%s\"", CMDSTATUS_BADQUESTION, argv[0]);
./cdebconf_0.138lenny3/src/commands.c:        asprintf(&out, "%u %s doesn't exist", CMDSTATUS_BADQUESTION, argv[0]);
./cdebconf_0.138lenny3/src/commands.c:        asprintf(&out, "%u %s doesn't exist", CMDSTATUS_BADQUESTION, argv[0]);
./cdebconf_0.138lenny3/src/commands.c:        asprintf(&out, "%u %s does not exist", CMDSTATUS_BADQUESTION, argv[1]);
./cdebconf_0.138lenny3/src/commands.c:        asprintf(&out, "%u %s doesn't exist", CMDSTATUS_BADQUESTION, argv[0]);
./cdebconf_0.138lenny3/src/commands.c:        asprintf(&out, "%u %s doesn't exist", CMDSTATUS_BADQUESTION, argv[0]);
./cdebconf_0.138lenny3/src/commands.c:    asprintf(&out, "%u %s", CMDSTATUS_SUCCESS, argv[2]);
./cfitsio3_3.080/cphead.c:        strcpy(filename, argv[1] );   /* name of file to list */
./cfitsio3_3.080/cphead.c:    strcpy(outfilename, argv[2] );   
./cfitsio3_3.080/windumpexts.c:		strcpy(&cmdline[pos], argv[i]);
./chemtool_1.6.11/src-cht/cht-1.7.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-v") ||
./chemtool_1.6.11/src-cht/cht-1.7.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--verbose"))
./chemtool_1.6.11/src-cht/cht-1.7.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-d") ||
./chemtool_1.6.11/src-cht/cht-1.7.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--debug"))
./chemtool_1.6.11/src-cht/cht-1.7.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-h") ||
./chemtool_1.6.11/src-cht/cht-1.7.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--help")) {
./chemtool_1.6.11/src-cht/cht-1.7.c:    if (strcpy(STR2, P_argv[rep])[0] != '-') {
./chemtool_1.6.11/src-cht/cht-1.7.c:      strcpy(STR1, P_argv[rep]);
./chemtool_1.6.11/src-cht/cht-2.4.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-v") ||
./chemtool_1.6.11/src-cht/cht-2.4.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--verbose"))
./chemtool_1.6.11/src-cht/cht-2.4.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-d") ||
./chemtool_1.6.11/src-cht/cht-2.4.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--debug"))
./chemtool_1.6.11/src-cht/cht-2.4.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-i") ||
./chemtool_1.6.11/src-cht/cht-2.4.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--interpret"))
./chemtool_1.6.11/src-cht/cht-2.4.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-h") ||
./chemtool_1.6.11/src-cht/cht-2.4.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--help")) {
./chemtool_1.6.11/src-cht/cht-2.4.c:    if (strcpy(STR2, P_argv[rep])[0] != '-') {
./chemtool_1.6.11/src-cht/cht-2.4.c:      strcpy(STR1, P_argv[rep]);
./chemtool_1.6.11/src-cht/cht-2.5.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-v") ||
./chemtool_1.6.11/src-cht/cht-2.5.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--verbose"))
./chemtool_1.6.11/src-cht/cht-2.5.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-d") ||
./chemtool_1.6.11/src-cht/cht-2.5.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--debug"))
./chemtool_1.6.11/src-cht/cht-2.5.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-i") ||
./chemtool_1.6.11/src-cht/cht-2.5.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--interpret"))
./chemtool_1.6.11/src-cht/cht-2.5.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-h") ||
./chemtool_1.6.11/src-cht/cht-2.5.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--help")) {
./chemtool_1.6.11/src-cht/cht-2.5.c:    if (strcpy(STR2, P_argv[rep])[0] != '-') {
./chemtool_1.6.11/src-cht/cht-2.5.c:      strcpy(STR1, P_argv[rep]);
./chemtool_1.6.11/src-cht/cht-2.6.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-v") ||
./chemtool_1.6.11/src-cht/cht-2.6.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--verbose"))
./chemtool_1.6.11/src-cht/cht-2.6.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-d") ||
./chemtool_1.6.11/src-cht/cht-2.6.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--debug"))
./chemtool_1.6.11/src-cht/cht-2.6.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-i") ||
./chemtool_1.6.11/src-cht/cht-2.6.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--interpret"))
./chemtool_1.6.11/src-cht/cht-2.6.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-h") ||
./chemtool_1.6.11/src-cht/cht-2.6.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--help")) {
./chemtool_1.6.11/src-cht/cht-2.6.c:    if (strcpy(STR2, P_argv[rep])[0] != '-') {
./chemtool_1.6.11/src-cht/cht-2.6.c:      strcpy(STR1, P_argv[rep]);
./chemtool_1.6.11/src-cht/cht.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-v") ||
./chemtool_1.6.11/src-cht/cht.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--verbose"))
./chemtool_1.6.11/src-cht/cht.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-d") ||
./chemtool_1.6.11/src-cht/cht.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--debug"))
./chemtool_1.6.11/src-cht/cht.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-i") ||
./chemtool_1.6.11/src-cht/cht.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--interpret"))
./chemtool_1.6.11/src-cht/cht.c:    if (!strcmp(strcpy(STR2, P_argv[rep]), "-h") ||
./chemtool_1.6.11/src-cht/cht.c:	!strcmp(strcpy(STR1, P_argv[rep]), "--help")) {
./chemtool_1.6.11/src-cht/cht.c:    if (strcpy(STR2, P_argv[rep])[0] != '-') {
./chemtool_1.6.11/src-cht/cht.c:      strcpy(STR1, P_argv[rep]);
./chemtool_1.6.11/templ.c:  if (argc==2) strcpy(filename,argv[1]);
./citadel_7.37/citadel_ipc.c:			strcpy(cithost, argv[a]);
./citadel_7.37/citadel_ipc.c:			strcpy(citport, argv[a]);
./citadel_7.37/getmail.c:			strcpy(cmd[n++], argv[a]);
./citadel_7.37/sendcommand.c:			strcat(cmd, argv[a]);
./citadel_7.37/setup.c:			strcpy(aaa, argv[a]);
./clisp_2.44.1/src/_clisp.c:      strcat(linkingsetdir, argv_linkingset);
./clisp_2.44.1/src/_clisp.c:        strcpy(argv_memfile, linkingsetdir);
./clisp_2.44.1/src/_clisp.c:        strcat(argv_memfile, "/");
./clisp_2.44.1/src/_clisp.c:        strcat(argv_memfile, filename);
./cnews_cr.g7/libc/split.c:			(void) strcpy(buf, argv[1]);
./cnews_cr.g7/libc/split.c:			(void) strcpy(buf, argv[1]);
./cpmtools_2.7/cpmcp.c:            strcpy(dest,argv[argc-1]);
./cpmtools_2.7/cpmcp.c:          else strcpy(dest,argv[argc-1]);
./cpmtools_2.7/cpmcp.c:          strcpy(dest,argv[argc-1]);
./cpmtools_2.7/cpmcp.c:        else strcpy(dest,argv[argc-1]);
./cpmtools_2.7/cpmcp.c:          sprintf(cpmname,"%02d%s",userNumber(argv[argc-1]),dest);
./cpmtools_2.7/cpmcp.c:          sprintf(cpmname,"%02d%s",userNumber(argv[argc-1]),strchr(argv[argc-1],':')+1);
./cproto_4.7f/cproto.c:	    char *s = strcpy(temp, argv[i]);
./cproto_4.7f/cproto.c:		    (void)strcpy(temp, argv[i]);
./crossfire_1.11.0/crossedit/CrEdit.c:	    sprintf(buf,"bad argument %s",argv[0]);
./crossfire_1.11.0/crossedit/CrEdit.c:	    sprintf(buf,"bad argument %s",argv[0]);
./crossfire_1.11.0/random_maps/standalone.c:  strcpy(InFileName,argv[1]);
./crossfire_1.11.0/random_maps/standalone.c:  strcpy(OutFileName,argv[2]);
./cssc_1.0.1/testutils/yes.c:    strcat(buf, argv[i]);
./cwebx_3.04/common.c:{if(dot_pos==NULL)sprintf(web_file_name,"%s.w",*argv);
./cwebx_3.04/common.c:{sprintf(web_file_name,"%s",*argv);
./cwebx_3.04/common.c:sprintf(alt_web_file_name,"%s.web",*argv);
./cwebx_3.04/common.c:sprintf(change_file_name,"%s.ch",*argv);
./cwebx_3.04/common.c:sprintf(C_file_name,"%s.%s",*argv,C_plus_plus?CPPEXT:"c");
./cwebx_3.04/common.c:{sprintf(tex_file_name,"%s.tex",*argv);
./cwebx_3.04/common.c:sprintf(idx_file_name,"%s.idx",*argv);
./cwebx_3.04/common.c:sprintf(scn_file_name,"%s.scn",*argv);
./cwebx_3.04/common.c:sprintf(change_file_name,dot_pos==NULL?"%s.ch":"%s",*argv);
./cwebx_3.04/common.c:if(dot_pos!=NULL)sprintf(C_file_name,"%s",*argv);
./cwebx_3.04/common.c:else sprintf(C_file_name,"%s.%s",*argv,C_plus_plus?CPPEXT:"c");
./cwebx_3.04/common.c:{sprintf(tex_file_name,"%s",*argv);*dot_pos='\0';}
./cwebx_3.04/common.c:else sprintf(tex_file_name,"%s.tex",*argv);
./cwebx_3.04/common.c:sprintf(idx_file_name,"%s.idx",*argv);
./cwebx_3.04/common.c:sprintf(scn_file_name,"%s.scn",*argv);
./dadadodo_1.04/dadadodo.c:		  sprintf(buf, "%s: opening input file %s", argv[0], input[i]);
./dadadodo_1.04/dadadodo.c:	      sprintf(buf, "%s: opening %s", argv[0], b);
./dadadodo_1.04/dadadodo.c:	      sprintf(buf, "%s: opening output file %s", argv[0], output);
./dadadodo_1.04/dadadodo.c:	  sprintf(buf, "%s: writing output file %s", argv[0], output);
./dia_0.96.1/app/dia-win-remote.c:        strcpy(((LPSTR)(pDropFiles) + iCurBytePos), __argv[i]);
./diald_0.99.4/parse.c:    strcpy(errstr,argv[0]);
./diald_0.99.4/parse.c:    for (i = 1; i < argc; i++) { strcat(errstr," "); strcat(errstr,argv[i]); }
./diald_0.99.4/ppp.c:	    strcat(argv_buf, argv[i]);
./diald_0.99.4/ppp.c:	    strcat(argv_buf, " ");
./distcc_2.18.3/popt/findme.c:	sprintf(buf, "%s/%s", start, argv0);
./distcc_2.18.3/popt/popt.c:	sprintf(s, "%s/%s", con->execPath, item->argv[0]);
./distcc_2.18.3/popt/poptparse.c:	dst += strlen(strcpy(dst, argv[i])) + 1;
./dnprogs_2.43.2/dapfs/dapfs.c:	strcpy(prefix, argv[1]);
./dnprogs_2.43.2/dapfs/dapfs.c:	strcpy(mountdir, argv[2]);
./dosemu_1.4.0+svn.1828/src/arch/linux/debugger/mhpdbgc.c:      strcpy(lastd, argv[1]);
./dosemu_1.4.0+svn.1828/src/arch/linux/debugger/mhpdbgc.c:      strcpy(lastu, argv[1]);
./dosemu_1.4.0+svn.1828/src/arch/linux/debugger/mhpdbgc.c:       strcpy(lastldt, argv[1]);
./dosemu_1.4.0+svn.1828/src/commands/lredir.c:    strcpy(deviceStr, argv[1]);
./dosemu_1.4.0+svn.1828/src/commands/lredir.c:    strcpy(resourceStr, argv[2]);
./dosemu_1.4.0+svn.1828/src/commands/unix.c:	strcat(command_line, *argv);
./dosemu_1.4.0+svn.1828/src/plugin/commands/commands.c:	strcat(c, argv[1]);
./dosemu_1.4.0+svn.1828/src/plugin/commands/commands.c:		strcat(c, argv[i]);
./dosemu_1.4.0+svn.1828/src/plugin/commands/lredir.c:      strcpy(deviceStr, argv[1]);
./dosemu_1.4.0+svn.1828/src/plugin/commands/lredir.c:        strcpy(resourceStr, argv[1]);
./dosemu_1.4.0+svn.1828/src/plugin/commands/lredir.c:        strcpy(deviceStr, argv[1]);
./dosemu_1.4.0+svn.1828/src/plugin/commands/lredir.c:        strcpy(resourceStr, argv[2]);
./dosemu_1.4.0+svn.1828/src/plugin/commands/mkcomstub.c:       { strcpy(buf,argv[4]);
./dosemu_1.4.0+svn.1828/src/plugin/commands/mkcomstub.c:       strcat(buf,argv[5]);
./dosemu_1.4.0+svn.1828/src/plugin/commands/mkcomstub.c:       strcat(buf,argv[6]);
./dosemu_1.4.0+svn.1828/src/plugin/commands/mkcomstub.c:       strcat(buf,argv[3]);
./dosemu_1.4.0+svn.1828/src/plugin/commands/unix.c:        strcat(command_line, *argv);
./dvi2dvi_2.0alpha/run.c:	    (void)strcpy(dvidirpath, argv[argind]);
./dvipdfmx_20080607/src/dvipdfmx.c:        strcpy(pdf_filename, argv[1]);
./dvipdfmx_20080607/src/dvipdfmx.c:      strcpy(dvi_filename, argv[0]);
./dvipdfmx_20080607/src/dvipdfmx.c:      strcpy(dvi_filename, argv[0]);
./dvipsk-ja_5.96+jp1.7a/dvipsk/afm2tfm.c:   (void)sprintf(titlebuf, "afm2tfm %s", argv[1]) ;
./dvipsk-ja_5.96+jp1.7a/dvipsk/afm2tfm.c:   (void)sprintf(titlebuf, "afm2tfm %s", argv[1]) ;
./dvipsk-ja_5.96+jp1.7a/dvipsk/afm2tfm.c:   (void)sprintf(titlebuf, "%s %s", argv[0], argv[1]) ;
./dvipsk-ja_5.96+jp1.7a/dvipsk/afm2tfm.c:   (void)strcpy(inname, argv[1]) ;
./dvipsk-ja_5.96+jp1.7a/dvipsk/afm2tfm.c:         (void)strcpy(outname, argv[3]) ;
./dvipsk-ja_5.96+jp1.7a/dvipsk/afm2tfm.c:         (void)sprintf(titlebuf + strlen(titlebuf), " %s", argv[2]) ;
./dvipsk-ja_5.96+jp1.7a/dvipsk/afm2tfm.c:   else (void)strcpy(outname, argv[2]) ;
./dxsamples_4.2.0/data/externalfilter.c:   strcpy(datafile,argv[1]);
./dxsamples_4.2.0/program_guide/simpleimportfilter.c:  strcpy(filename, argv[1]);
./dxsamples_4.2.0/util/dxf/dxf.c:	strcpy(out_filename, argv[i]);
./dxsamples_4.2.0/util/fluent/Fluent2DX.c:    strcpy(unvfile,argv[argc - 1]);
./ecartis_1.0.0+cvs.20030911/src/modules/base/base.c:    sprintf(result, "%d", !(!(LMAPI->get_var(argv[0]))));
./elvis-tiny_1.4/main.c:			strcat(args, argv[i++]);
./elvis-tiny_1.4/shell.c:			strcat(buf, argv[i]);
./elvis-tiny_1.4/virec.c:		strcpy(o_directory, argv[2]);
./etherboot_5.4.3+dfsg/contrib/tftp/main.c:		strcpy(hostname, argv[1]);
./etherboot_5.4.3+dfsg/contrib/tftp/main.c:		strcpy(cp, tail(argv[n]));
./faad2_2.6.1/frontend/main.c:    strcpy(aacFileName, argv[optind]);
./fceu_0.98.12/src/drivers/common/args.c:	      strcpy(*(char **)argsps[y].subs,argv[x+1]);
./fgetty_0.6/login2.c:      strcpy(argv0+1,tmp);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api1.c:        strcpy(new_dbname, argv[1]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api10.c:        strcpy(empdb, argv[1]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api11.c:        strcpy(empdb, argv[1]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api12.c:        strcpy(empdb, argv[1]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api13.c:        strcpy(empdb, argv[1]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api13.c:        strcpy(empdb2, argv[2]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api15.c:        strcpy(dbname, argv[1]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api15.c:        strcpy(user_name, argv[2]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api15.c:        strcpy(password, argv[3]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api16.c:                strcpy(dbname, argv[1]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api16t.c:        strcpy(empdb, argv[1]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api2.c:        strcpy(Db_name, argv[1]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api3.c:        strcpy(empdb, argv[1]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api4.c:        strcpy(empdb, argv[1]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api5.c:         strcpy(empdb, argv[1]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api6.c:        strcpy(empdb, argv[1]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api7.c:        strcpy(empdb, argv[1]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api8.c:        strcpy(empdb, argv[1]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/api9.c:        strcpy(empdb, argv[1]);
./firebird2.0_2.0.4.13130-1.ds1/examples/api/apifull.c:        strcpy(db_name, argv[1]);
./floater_1.4.15/common/main.c:    sprintf(s, "TCL_LIBRARY=%s", argv0);
./floater_1.4.15/common/main.c:    sprintf(s, "TK_LIBRARY=%s", argv0);
./fondu_0.0.20050825/dfont2res.c:	strcpy(buffer,argv[i]);
./fortune-mod_1.99.1/util/strfile.c:	    (void) strcpy(Outfile, *argv);
./frotz_2.43/src/curses/ux_init.c:    strcpy(story_name, argv[optind]); 
./gabedit_2.1.8/utils/Molcas/molcaslib.c:		sprintf(symb,argv[1]);
./gaby_2.0.2/src/gabyscript.c:			strcat(cmdline, argv[i]);
./gaby_2.0.2/src/gabyscript.c:			strcat(cmdline, argv[i]);
./gaby_2.0.2/src/gabyscript.c:	strcpy(file, fake_argv[5]);
./gaby_2.0.2/src/print_plg.c:	else		 strcpy(filename, argv[1]);
./gaby_2.0.2/src/test.c:		strcpy(name, argv[1]);
./gcc-h8300-hms_3.4.6/gcc/fixinc/fixfixes.c:  strcpy( pz_tmptmp, argv[4] );
./gcom_0.3/gcom.c:    strcpy(scriptfile,argv[optind++]);
./gcom_0.3/gcom.c:      sprintf(msg,"argv[%d]=%s",aa,argv[aa]);
./ghc6_6.8.2dfsg1/rts/parallel/Parallel.c:  sprintf(gr_filename, GR_FILENAME_FMT, prog_argv[0], extension);
./ghc6_6.8.2dfsg1/rts/parallel/Parallel.c:  sprintf(gr_filename, GR_FILENAME_FMT_GUM, prog_argv[0], thisPE, extension);
./ghc6_6.8.2dfsg1/rts/parallel/SysMan.c:      sprintf(argv[2],"%d",nPEs); /* ToCheck: does this work on all archs */
./ghc6_6.8.2dfsg1/rts/parallel/SysMan.c:      sprintf(argv[0],"-%08X",sysman_id);  /*flag that its the Main Thread PE and include sysman's id*/
./ghc6_6.8.2dfsg1/rts/RtsFlags.c:	    sprintf(stats_filename, FILENAME_FMT, argv[0]);
./ghc6_6.8.2dfsg1/rts/RtsFlags.c:        strcpy(full_prog_argv[i], argv[i]);
./ghc6_6.8.2dfsg1/utils/unlit/unlit.c:	      strcpy(prefix_str, *argv);
./ghdl_0.26+svn98+gcc4.1.2~dfsg/gcc/fixincludes/fixfixes.c:  strcpy( pz_tmptmp, argv[4] );
./gif2png_2.5.1/gif2png.c:	    strcpy(name, argv[i]);
./giftrans_1.12.2/giftrans.c:				(void)sprintf(error,"%s: cannot open %s",image,argv[optind]);
./gimp_2.4.7/plug-ins/script-fu/re/split.c:			(void) strcpy(buf, argv[1]);
./gimp_2.4.7/plug-ins/script-fu/re/split.c:			(void) strcpy(buf, argv[1]);
./gimp-gap_2.4.0/libwavplayclient/client.c:	sprintf(buf,"WAVSVR=%d",svrIPC);	/* Pass this as argv[0] */
./gnat-gps_4.0.1/kernel/src_info/sn/snsrc/snavigator/db/dbimp.c:		sprintf(lock_file,"%s.lck",argv[optind]);
./gnat-gps_4.0.1/kernel/src_info/sn/snsrc/snavigator/dbutils/dbutils.c:			sprintf(incl_file,"%s/%s",path_argv[0],bfn);
./gnupg_1.4.9/g10/gpg.c:      strcat(str,argv[i]);
./gnupg_1.4.9/tools/shmtest.c:	strcat(p, argv[i] );
./gpp_2.24/src/gpp.c:      strcat(C->buf,argv[i]);
./gpx2shp_0.69/src/main.c:    strcpy(prop->sourcefile, argv[optind]);
./grace_5.1.22/src/main.c:			strcpy(batchfile, argv[i]);
./grace_5.1.22/src/main.c:			strcpy(netcdf_name, argv[i]);
./grace_5.1.22/src/main.c:			strcpy(xvar_name, argv[i]);
./grace_5.1.22/src/main.c:			strcpy(yvar_name, argv[i]);
./grace_5.1.22/src/main.c:                        strcpy(print_file, argv[i]);
./grun_0.9.3/grun.c:				strcat(cmd, argv[c]);
./gsoap_2.7.9l/soapcpp2/src/soapcpp2.c:							strcpy(dirpath, argv[i]);
./gsoap_2.7.9l/soapcpp2/src/soapcpp2.c:		{	sprintf(errbuf, "Cannot open file \"%s\" for reading", argv[i]);
./gsoap_2.7.9l/soapcpp2/src/soapcpp2.c:			strcpy(filename, argv[i]);
./gsoap_2.7.9l/soapcpp2/VisualStudio2005/soapcpp2/soapcpp2/soapcpp2.c:							strcpy(dirpath, argv[i]);
./gsoap_2.7.9l/soapcpp2/VisualStudio2005/soapcpp2/soapcpp2/soapcpp2.c:		{	sprintf(errbuf, "Cannot open file \"%s\" for reading", argv[i]);
./gsoap_2.7.9l/soapcpp2/VisualStudio2005/soapcpp2/soapcpp2/soapcpp2.c:			strcpy(filename, argv[i]);
./gwp_0.4.0/src/vp_unpack.c:      sprintf(gamedir, "%s%c", argv[1], '/');
./gwp_0.4.0/src/vp_unpack.c:      sprintf(gamedir, "%s", argv[1]);
./heartbeat_2.1.3/lib/clplumbing/cl_log.c:		sprintf(arg_string + existing_len, "%s ", argv[lpc]);
./heimdal_1.2.dfsg.1/lib/sqlite/sqlite3.c:    strcpy(z, argv[i]);
./i2c-tools_3.0.1/eepromer/eepromer.c:			 strcpy(device,argv[i+1]);	 
./ibm-3270_3.3.7p7/c3270/glue.c:		(void) strcat(strcat(command_string, " "), argv[i]);
./ibm-3270_3.3.7p7/c3270/glue.c:			(void) strcat(strcat(cmds_buf, " "), argv[j]);
./ibm-3270_3.3.7p7/s3270/glue.c:		(void) strcat(strcat(command_string, " "), argv[i]);
./ibm-3270_3.3.7p7/s3270/glue.c:			(void) strcat(strcat(cmds_buf, " "), argv[j]);
./ibm-3270_3.3.7p7/tcl3270/glue.c:		(void) strcat(strcat(command_string, " "), argv[i]);
./ibm-3270_3.3.7p7/tcl3270/glue.c:			(void) strcat(strcat(cmds_buf, " "), argv[j]);
./ibm-3270_3.3.7p7/wc3270/glue.c:		(void) strcat(strcat(command_string, " "), argv[i]);
./ibm-3270_3.3.7p7/wc3270/glue.c:			(void) strcat(strcat(cmds_buf, " "), argv[j]);
./ibm-3270_3.3.7p7/x3270/main.c:			(void) strcat(strcat(*cmds, " "), argv[j]);
./ibm-3270_3.3.7p7/x3270/save.c:		(void) strcpy(xcmd + len, argv[i]);
./iceape_1.1.14/db/sqlite3/src/func.c:  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));
./iceape_1.1.14/db/sqlite3/src/func.c:  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));
./iceape_1.1.14/db/sqlite3/src/shell.c:      sprintf(data.separator,"%.*s",(int)sizeof(data.separator)-1,argv[i]);
./iceape_1.1.14/db/sqlite3/src/shell.c:      sprintf(data.nullvalue,"%.*s",(int)sizeof(data.nullvalue)-1,argv[i]);
./iceape_1.1.14/db/sqlite3/src/table.c:        strcpy(z, argv[i]);
./iceape_1.1.14/xpinstall/wizard/os2/setup/extra.c:      strcpy(sgProduct.szAlternateArchiveSearchPath, argv[i]);
./iceape_1.1.14/xpinstall/wizard/os2/setup/extra.c:      strcpy(sgProduct.szParentProcessFilename, argv[i]);
./iceape_1.1.14/xpinstall/wizard/os2/setup/extra.c:    strcat(szOutputStr, argv[i]);
./iceape_1.1.14/xpinstall/wizard/os2/uninstall/extra.c:        strcpy(ugUninstall.szUserAgent, argv[i]);
./iceape_1.1.14/xpinstall/wizard/os2/uninstall/extra.c:        strcpy(ugUninstall.szAppID, argv[i]);
./iceape_1.1.14/xpinstall/wizard/os2/uninstall/extra.c:        strcpy(ugUninstall.szOIMainApp, argv[i]);
./inn_1.7.2q/innd/cc.c:    (void)strcpy(client.sun_path, argv[0]);
./ipmitool_1.8.9/lib/ipmi_fru.c:				strcpy(fileName, argv[2]);
./ipmitool_1.8.9/lib/ipmi_fru.c:				strcpy(fileName, argv[2]);
./ipmitool_1.8.9/lib/ipmi_fru.c:			strcpy(fileName, argv[2]);
./ipmitool_1.8.9/lib/ipmi_fwum.c:               strcpy((char *)fileName, argv[1]);
./ipmitool_1.8.9/lib/ipmi_fwum.c:               strcpy((char *)fileName, argv[1]);
./irssi_0.8.12/src/lib-popt/findme.c:	sprintf(buf, "%s/%s", start, argv0);
./itrans_5.3/src/utils.c:		    strcpy(tmp, argv[optind]);
./ivtv_1.2.0/utils/ivtv-radio.c:	strcpy(cfg.prog_name, argv[0]);
./jamvm_1.5.1/src/jam.c:            char *pntr, *key = strcpy(sysMalloc(strlen(argv[i]+2) + 1), argv[i]+2);
./jfsutils_1.1.12/mkfs/mkfs.c:		strcpy(logdev, argv[optind]);
./jumpnbump_1.50+dfsg1/main.c:						strcpy(datfile_name, argv[c1 + 1]);
./jumpnbump_1.50+dfsg1/modify/gobpack.c:		strcpy(filename, argv[2]);
./jumpnbump_1.50+dfsg1/modify/gobpack.c:		strcpy(filename, argv[2]);
./jumpnbump_1.50+dfsg1/modify/gobpack.c:		strcpy(filename, argv[2]);
./jumpnbump_1.50+dfsg1/modify/gobpack.c:		strcpy(filename, argv[1]);
./jumpnbump_1.50+dfsg1/modify/gobpack.c:		strcpy(filename, argv[1]);
./jumpnbump_1.50+dfsg1/modify/gobpack.c:		strcpy(filename, argv[1]);
./kakasi_2.3.4/lib/libkakasi.c:	    sprintf(cr_eat_string, "\011\012\015 %s", (*argv)+2);
./kakasi_2.3.4/lib/libkakasi.c:	    sprintf(cr_eat_string, "\011\012\015 %s", (*argv)+2);
./kakasi_2.3.4/src/kakasi.c:	    sprintf(cr_eat_string, "\011\012\015 %s", (*argv)+2);
./kakasi_2.3.4/src/kakasi.c:	    sprintf(cr_eat_string, "\011\012\015 %s", (*argv)+2);
./kdegames_3.5.10/kpat/freecell-solver/cmd_line.c:                sprintf(errstr, "Unknown game \"%s\"!\n\n", argv[arg]);
./kdegames_3.5.10/kpat/freecell-solver/cmd_line.c:                sprintf(errstr, "Unknown scans' synergy type \"%s\"!\n", argv[arg]);
./kdegames_3.5.10/kpat/freecell-solver/cmd_line.c:                    sprintf(err_str, "Unable to load the \"%s\" configuration!\n", argv[arg]);
./komi_1.04/komi.c:            sprintf(filepath, "%s", argv[n + 1]);
./koules_1.4/koules.sndsrv.sgi.c:	strcat(s, argv[1]);
./lacheck_1.26/lacheck.c:	strcpy(file_name, argv[1]);
./lcab_1.0b12/main.c:	strcpy( outputfile, argv[argc - 1]);
./libcap2_2.11/progs/capsh.c:	    sprintf(ptr, "%s %s+i", text, argv[i]+6);
./libfreebasic_0.18.2b/src/rtlib/libfb_sys_cmd.c:			strcat( dst->data, __fb_ctx.argv[i] );
./libfreebasic_0.18.2b/src/rtlib/libfb_sys_cmd.c:	strcpy( dst->data, __fb_ctx.argv[arg] );
./libpam-mount_0.44/src/misc.c:		hmc_strcat(&str, argv[i]);
./libvirt_0.4.6/src/iptables.c:        strcpy(p, argv[i]);
./libvirt_0.4.6/src/qemu_conf.c:        if ((asprintf((char **)&(qargv[qargc++]), "disk:%s", thisarg)) == -1) {    \
./libvirt_0.4.6/tests/qemuxml2argvtest.c:            strcat(actualargv, " ");
./libvirt_0.4.6/tests/qemuxml2argvtest.c:        strcat(actualargv, *tmp);
./libvirt_0.4.6/tests/qemuxml2argvtest.c:    strcat(actualargv, "\n");
./lie_2.2.2+dfsg/main.c:        strcpy(initfil,argv[nr++]);
./lie_2.2.2+dfsg/main.c:        strcpy(infofil,argv[nr++]);
./lighttpd_1.4.19/src/lemon.c:    if( path ) sprintf(path,"%s/%s",argv0,name);
./linuxdoc-tools_0.9.56/sgmls-1.1/main.c:	  strcpy(ptr, argv[i]);
./linux-wlan-ng_0.2.9+dfsg/src/prism2/ridlist/mkmiblist.c:	sprintf( ifname, "%s", argv[1] );
./linux-wlan-ng_0.2.9+dfsg/src/prism2/ridlist/mkmiblist.c:	sprintf( ofname1, "%s.txt", argv[2] );
./linux-wlan-ng_0.2.9+dfsg/src/prism2/ridlist/mkridlist.c:	sprintf( ifname, "%s", argv[1] );
./linux-wlan-ng_0.2.9+dfsg/src/prism2/ridlist/mkridlist.c:	sprintf( ofname1, "%s.html", argv[2] );
./linux-wlan-ng_0.2.9+dfsg/src/prism2/ridlist/mkridlist.c:	sprintf( ofname2, "%s.txt", argv[2] );
./liquidwar_5.6.3/utils/lwmapgen/main.c:               strcpy(filename, argv[i]);
./liquidwar_5.6.3/utils/snprintf/test.c:      len2 = sprintf(str2,                  argv[1], j, 3);
./liquidwar_5.6.3/utils/snprintf/test.c:      len2 = sprintf(str2,                  argv[1], argv[2], 3);
./lirc_0.8.3/tools/irw.c:		strcpy(addr.sun_path,argv[optind]);
./lletters_0.1.95+gtk2/wav_rec.c:			strcpy(file_info->name, argv[i + 1]);
./llvm_2.2/test/CFrontend/2002-05-24-Alloca.c:  strcpy(C, argv[0]);
./llvm_2.2/tools/llvm-stub/llvm-stub.c:  argv[0] = strcat(strcpy((char*)malloc(strlen(argv[0])+5), argv[0]), ".exe");
./llvm_2.2/tools/llvm-stub/llvm-stub.c:  Args[1] = strcat(strcpy((char*)malloc(strlen(argv[0])+4), argv[0]), ".bc");
./loop-aes-utils_2.13.1/getopt/getopt.c:		strcpy(optstr,argv[1]+strspn(argv[1],"-+"));
./loop-aes-utils_2.13.1/getopt/getopt.c:			strcpy(optstr,argv[optind]);
./loop-aes-utils_2.13.1/misc-utils/setterm.c:		strcpy((char *)opt_all, argv[0]);
./lopster_1.2.2/src/getopt.c:    sprintf(var, "_%d_GNU_nonoption_argv_flags_", getpid());
./lsat_0.9.7.1/lsatmain.c:			  strcpy(man_distro, argv[i]+3);
./lsat_0.9.7.1/lsatmain.c:			  strcpy(out_file, argv[i]+3);
./lsat_0.9.7.1/lsatmain.c:		case 'x': strcpy(xlist,argv[i]+3);
./makejvf_1.1a+0/main.c:	strcpy(atfmname,*argv);
./makejvf_1.1a+0/main.c:	strcpy(vfname,*argv);
./mapserver_5.0.3/sortshp.c:  sprintf(buffer,"%s.dbf",argv[1]);
./mapserver_5.0.3/sortshp.c:  sprintf(buffer,"%s.dbf",argv[2]);
./mc_4.6.2~git20080311/src/findme.c:	sprintf(buf, "%s/%s", start, argv0);
./mc_4.6.2~git20080311/src/popt.c:	sprintf(argv[pos], "%s/%s", con->execPath, script);
./mendexk_2.6e/main.c:					strcpy(dicfile,argv[i]);
./mendexk_2.6e/main.c:					strcpy(dicfile,&argv[i][2]);
./mendexk_2.6e/main.c:					strcpy(indfile,argv[++i]);
./mendexk_2.6e/main.c:					strcpy(indfile,&argv[i][2]);
./mendexk_2.6e/main.c:					strcpy(logfile,argv[++i]);
./mendexk_2.6e/main.c:					strcpy(logfile,&argv[i][2]);
./mendexk_2.6e/main.c:					strcpy(styfile,argv[i]);
./mendexk_2.6e/main.c:					strcpy(styfile,&argv[i][2]);
./mendexk_2.6e/main.c:			strcpy(idxfile[j++],argv[i]);
./ming_0.3.0/util/makeswf.c:			sprintf(ppfile, "%s.pp", argv[i]);
./mlterm_2.9.4/xwindow/x_term_manager.c:			sprintf( cmd_argv[0] , "-%s" , cmd_file) ;
./mlterm_2.9.4/xwindow/x_term_manager.c:			strcpy( cmd_argv[0] , cmd_file) ;
./mod-ruby_1.2.6/request.c:    request_write(out, rb_f_sprintf(argc, argv));
./mod-ruby_1.2.6/server.c:    s = rb_f_sprintf(argc, argv);
./most_5.0.0a/src/most.c:	     strcat(file, most_unix2vms(argv[i++]));
./mp3rename_0.6/mp3rename.c:  sprintf(dirsource,"%s",*argv);
./mtx_1.3.11/mtxl.c:	sprintf(TargetPointer,"%s: ",argv0);
./multipath-tools_0.4.8/path_priority/pp_alua/main.c:			sprintf(devicepath, "%s", argv[c]);
./multipath-tools_0.4.8/path_priority/pp_alua/main.c:			sprintf(devicepath, "%s/%s", devicedir, argv[c]);
./ncftp_3.2.1/Strn/Strntok.c:	strcpy(buf, argv[1]);
./ncftp_3.2.1/Strn/Strntok.c:	strcpy(buf, argv[1]);
./ncftp_3.2.1/Strn/Strntok.c:	strcpy(buf, argv[1]);
./ncftp_3.2.1/Strn/strtokc.c:	strcpy(buf, argv[1]);
./ncftp_3.2.1/Strn/strtokc.c:	strcpy(buf, argv[1]);
./ncftp_3.2.1/Strn/strtokc.c:	strcpy(buf, argv[1]);
./netdiag_1.0/netwatch-1.0c/bump.c:	strcpy(version,argv[1]);
./netkit-rsh_0.17/rexec/rexec.c:    (void) strcat(*command, argv[ind]);
./netkit-tftp_0.17/tftp/main.c:		strcpy(hostname, argv[1]);
./netkit-tftp_0.17/tftp/main.c:		strcpy(ccp, tail(argv[n]));
./net-snmp_5.4.1~dfsg/agent/mibgroup/host/hr_swrun.c:            strcat(string, *argv);
./net-snmp_5.4.1~dfsg/agent/mibgroup/ip-mib/ipv4InterfaceTable/ipv4InterfaceTable_subagent.c:                sprintf(astring, "%s,%s", c, argv[i]);
./net-snmp_5.4.1~dfsg/agent/mibgroup/ucd-snmp/proxy.c:    strcpy(argv[0] = args[0], "snmpd-proxy");   /* bogus entry for getopt() */
./net-snmp_5.4.1~dfsg/agent/snmpd.c:                sprintf(astring, "%s,%s", c, argv[i]);
./net-snmp_5.4.1~dfsg/agent/snmpd.c:    strcpy(argvrestartname, argv[0]);
./net-snmp_5.4.1~dfsg/agent/snmpd.c:        strcpy(cptr, argv[i]);
./net-snmp_5.4.1~dfsg/apps/snmptrapd.c:                sprintf(astring, "%s,%s", listen_ports, argv[i]);
./nifticlib_1.0.0/utils/nifti_tool.c:   len = sprintf( opts->command, "\n  command: %s", argv[0] );
./nifticlib_1.0.0/utils/nifti_tool.c:      if( has_space ) len = sprintf(cp, " '%s'", argv[ac]);
./nifticlib_1.0.0/utils/nifti_tool.c:      else            len = sprintf(cp, " %s",   argv[ac]);
./njplot_2.2/unrooted-vib.c:        strcpy(fname,argv[1]);
./nn_6.7.3/answer.c:	strcpy(newsgroups, argv[1]);
./nn_6.7.3/answer.c:	    strcat(newsgroups, argv[i]);
./nn_6.7.3/split.c:	    (void) strcpy(buf, argv[1]);
./nn_6.7.3/split.c:	    (void) strcpy(buf, argv[1]);
./node_0.3.2/cmdparse.c:			safe_strcpy(buf, argv[n]);
./node_0.3.2/config.c:		len += sprintf(&buf[len], "\"%s\" ", argv[i + 5]);
./op_1.32/main.c:				strcat(cp, argv[i]);
./op_1.32/main.c:								strcat(buffer, argv[j]);
./op_1.32/main.c:/*	sprintf(retbuf,"%s",argv[0]);*/
./op_1.32/main.c:			sprintf(buf," %s",argv[i]);
./opencv_1.0.0/samples/c/convert_cascade.c:    sprintf( comment, "Automatically converted from %s, window size = %dx%d", argv[2], size.width, size.height );
./openldap_2.4.11/servers/slapd/bconfig.c:					strcpy( si->si_url.bv_val, c->argv[2] );
./openmpi_1.2.7~rc2/orte/mca/pls/gridengine/pls_gridengine_module.c:            asprintf(&argv[node_name_index1], "%s@%s",
./openmpi_1.2.7~rc2/orte/mca/pls/gridengine/pls_gridengine_module.c:            asprintf(&argv[orted_index], orted_path);
./openmpi_1.2.7~rc2/orte/mca/rmgr/base/data_type_support/rmgr_data_type_print_fns.c:        asprintf(&tmp2, "%s\n%s\tArgv[%d]: %s", tmp, pfx2, i, src->argv[i]);
./openmpi_1.2.7~rc2/orte/tools/orterun/totalview.c:            asprintf(&tmp, "%s%s%s", line, argv[0], line + i + 8);
./openmpi_1.2.7~rc2/orte/tools/orterun/totalview.c:            asprintf(&tmp, "%s%s%s", line, argv[0], line + i + 9);
./openmpi_1.2.7~rc2/orte/tools/orterun/totalview.c:            asprintf(&tmp, "%s%s%s", line, user_argv, line + i + 13);
./openmpi_1.2.7~rc2/orte/tools/orterun/totalview.c:            asprintf(&tmp, "%s%s%s", line, user_argv, line + i + 14);
./openmx_3.2.4.dfsg/source/bandgnu13.c:    strcpy(fnamedat1[spin],argv[1]);
./openmx_3.2.4.dfsg/source/bandgnu13.c:  strcpy(fname,argv[1]);
./openmx_3.2.4.dfsg/source/check_lead.c:  sprintf(fname2,"%s_NEGF1",argv[1]);
./openmx_3.2.4.dfsg/source/diff_geo.c:  sprintf(file1,"%s",argv[1]);  
./openmx_3.2.4.dfsg/source/diff_geo.c:  sprintf(file2,"%s",argv[2]);  
./openmx_3.2.4.dfsg/source/esp.c:    sprintf(file[1],"%s.vhart.cube",argv[1]);  
./openmx_3.2.4.dfsg/source/esp.c:    sprintf(file[2],"%s.LESP",argv[1]);
./openmx_3.2.4.dfsg/source/esp.c:  sprintf(file[0],"%s.out",argv[1]);  
./openmx_3.2.4.dfsg/source/esp.c:  sprintf(file[1],"%s.vhart.cube",argv[1]);  
./openmx_3.2.4.dfsg/source/Force_test.c:        sprintf(operate,"%s %s -forcetest2 %i ",argv[3],fname_dat,force_flag);
./openmx_3.2.4.dfsg/source/Maketest.c:      else if (argc==3)  sprintf(operate,"%s %s",argv[2],fname_dat);
./openmx_3.2.4.dfsg/source/Maketest.c:      else if (argc==3)  sprintf(operate,"%s %s",argv[2],fname_dat);
./openmx_3.2.4.dfsg/source/Memory_Leak_test.c:      else if (argc==3)  sprintf(operate,"%s %s -mltest2",argv[2],fname_dat);
./openser_1.3.2/modules/perl/perl.c:		sprintf(argv[argc], "-I%s", modpath);
./openslp-dfsg_1.2.1/test/SLPDereg/SLPDereg.c:		sprintf(reg_string,"%s://%s",argv[1], argv[2]);
./openslp-dfsg_1.2.1/test/SLPDereg/SLPDereg.c:		sprintf(dereg_string,"%s://%s",argv[3], argv[4]);
./openslp-dfsg_1.2.1/test/SLPDereg/SLPDereg.c:		sprintf(dereg_string,"%s://%s",argv[1], argv[2]);
./openslp-dfsg_1.2.1/test/SLPFindAttrs/SLPFindAttrs.c:		sprintf(reg_string, "%s://%s", argv[1], argv[2]);
./openslp-dfsg_1.2.1/test/SLPFindAttrs/SLPFindAttrs.c:	sprintf(server_url, "%s://%s", argv[1], argv[2]);
./openslp-dfsg_1.2.1/test/SLPReg/SLPReg.c:	sprintf(reg_string,"%s://%s",argv[1], argv[2]);
./outguess_0.2/jpeg-6b-steg/wrjpgcom.c:	strcpy(comment_arg, argv[argn]+1);
./outguess_0.2/jpeg-6b-steg/wrjpgcom.c:	  strcat(comment_arg, argv[argn]);
./pacman4console_1.2/pacmanedit.c:		strcpy(filename, argv[1]);
./palo_1.16+nmu1/ipl/ipl.c:	chk_strcat(tmpbuf, argv[i], sizeof tmpbuf, ok);
./palo_1.16+nmu1/ipl/ipl.c:	    strcpy(fieldbuf, argv[editfield]);
./pdsh_2.16/src/pdsh/opt.c:  xstrcat(&abspath, argv0);
./pdsh_2.16/src/pdsh/opt.c:        xstrcat(&abspath, argv0);
./pdsh_2.16/src/pdsh/opt.c:            xstrcat(&opt->cmd, argv[optind]);
./pdsh_2.16/src/pdsh/opt.c:                xstrcat(&opt->pcp_client_host, argv[optind]);
./pdsh_2.16/src/pdsh/opt.c:                xstrcat(&opt->outfile_name, argv[optind]);
./perl-tk_804.028/JPEG/jpeg/wrjpgcom.c:	strcpy(comment_arg, argv[argn]+1);
./perl-tk_804.028/JPEG/jpeg/wrjpgcom.c:	  strcat(comment_arg, argv[argn]);
./perl-tk_804.028/pTk/mTk/generic/tkTest.c:	    strcpy((char *) ckalloc(strlen(argv[3]) + 1), argv[3]);
./perl-tk_804.028/pTk/mTk/generic/tkTest.c:		strcpy((char *) ckalloc(strlen(argv[4]) + 1), argv[4]);
./perl-tk_804.028/pTk/mTk/tclGeneric/tclCkalloc.c:	strcpy(curTagPtr->string, argv[2]);
./perl-tk_804.028/pTk/mTk/tclGeneric/tclCkalloc.c:    strcpy(tclMemDumpFileName, argv[1]);
./perl-tk_804.028/pTk/mTk/tclGeneric/tclPkg.c:		strcpy(availPtr->version, argv3);
./perl-tk_804.028/pTk/mTk/tclGeneric/tclPkg.c:	    strcpy(availPtr->script, argv4);
./perl-tk_804.028/pTk/mTk/tclGeneric/tclPkg.c:		    strcpy(iPtr->packageUnknown, argv2);
./perl-tk_804.028/pTk/mTk/tclGeneric/tclTest.c:	strcpy(asyncPtr->command, argv[2]);
./perl-tk_804.028/pTk/mTk/tclGeneric/tclTest.c:    strcpy(dPtr->deleteCmd, argv[3]);
./perl-tk_804.028/pTk/mTk/tclGeneric/tclTest.c:		strcpy(stringVar, argv[5]);
./perl-tk_804.028/pTk/mTk/tclGeneric/tclTest.c:		strcpy(stringVar, argv[5]);
./perl-tk_804.028/pTk/mTk/tclGeneric/tclTest.c:    strcpy(buf, argv[2]);
./perl-tk_804.028/pTk/mTk/tclUnix/tclUnixPipe.c:	sprintf(errSpace, "%dcouldn't execute \"%.150s\": ", errno, argv[0]);
./perl-tk_804.028/pTk/mTk/tclUnix/tclUnixTest.c:	strcpy(tclDefaultEncodingDir, argv[1]);
./perl-tk_804.028/pTk/mTk/tixGeneric/tixClass.c:	    sprintf(buff, "w:%s", argv[2]);
./perl-tk_804.028/pTk/mTk/tixGeneric/tixGrRC.c:	    sprintf(errorMsg, "%s %s ?option value ...?", argv[-2], argv[-1]);
./perl-tk_804.028/pTk/mTk/tixGeneric/tixGrRC.c:	sprintf(errorMsg, "%s %s ?option value ...?", argv[-2], argv[-1]);
./perl-tk_804.028/pTk/mTk/tixGeneric/tixOption.c:    sprintf(method, "config%s", spec->argvName);
./perl-tk_804.028/pTk/mTk/tixWin/winDumpExts.c:		strcpy(&cmdline[pos], argv[i]);
./perl-tk_804.028/pTk/mTk/unix/tkUnixWm.c:    strcpy(wmPtr->clientMachine, argv3);
./perl-tk_804.028/pTk/mTk/unix/tkUnixWm.c:	strcpy(wmPtr->leaderName, argv3);
./perl-tk_804.028/pTk/mTk/unix/tkUnixWm.c:	strcpy(wmPtr->iconName, argv3);
./perl-tk_804.028/pTk/mTk/unix/tkUnixWm.c:	strcpy(wmPtr->title, argv3);
./perl-tk_804.028/pTk/mTk/win/tkWinWm.c:    strcpy(wmPtr->clientMachine, argv3);
./perl-tk_804.028/pTk/mTk/win/tkWinWm.c:	strcpy(wmPtr->leaderName, argv3);
./perl-tk_804.028/pTk/mTk/win/tkWinWm.c:	strcpy(wmPtr->iconName, argv3);
./perl-tk_804.028/pTk/mTk/win/tkWinWm.c:	strcpy(wmPtr->title, argv3);
./pic2fig_1.4/main.c:				(void) sprintf(TEXfilename, "%s.pic", *argv);
./picasm_1.14/picasm.c:		p_strcpy(out_filename, &argv[1][2], sizeof out_filename);
./picasm_1.14/picasm.c:		p_strcpy(out_filename, argv[2], sizeof out_filename);
./picasm_1.14/picasm.c:		p_strcpy(list_filename, &argv[1][2], sizeof list_filename);
./pine_4.64/pine/args.c:    sprintf(tmp_20k_buf, "%.*s", pine_state->pine_name - argv[0], argv[0]);
./pine_4.64/pine/pine.c:	    sprintf(p, "%s\"%s\"", i ? " " : "", argv[i] ? argv[i] : "");
./plotmtv_1.4.4t/Lib/parser.c:         (void) strcpy(value,argv[i]);
./plotmtv_1.4.4t/Lib/parser.c:      (void) strcpy(value,argv[i]);
./plotmtv_1.4.4t/Plot/test_plotmtv.c:         (void) strcpy(printer,argv[i]+2);
./plotmtv_1.4.4t/Plot/test_plotmtv.c:         (void) strcpy(printCmd, argv[i]);
./plotmtv_1.4.4t/Plot/test_plotmtv.c:         (void) strcpy(psfile, argv[i]);
./plotmtv_1.4.4t/Plot/test_plotmtv.c:         (void) strcpy(title, argv[i]);
./plotmtv_1.4.4t/Plot/test_plotmtv.c:         (void) strcpy(datafile,argv[i]);
./plotmtv_1.4.4t/Plot/test_plotmtv_orig.c:         (void) strcpy(printer,argv[i]+2);
./plotmtv_1.4.4t/Plot/test_plotmtv_orig.c:         (void) strcpy(printCmd, argv[i]);
./plotmtv_1.4.4t/Plot/test_plotmtv_orig.c:         (void) strcpy(psfile, argv[i]);
./plotmtv_1.4.4t/Plot/test_plotmtv_orig.c:         (void) strcpy(datafile,argv[i]);
./plotmtv_1.4.4t/Utils/ctr2mtv.c:   (void) strcpy(progname,argv[0]);
./plotmtv_1.4.4t/Utils/ctr2mtv.c:         (void) strcpy(outfile,argv[i]);
./plotmtv_1.4.4t/Utils/ctr2mtv.c:         (void) strcpy(datafile,argv[i]);
./plotmtv_1.4.4t/Utils/drawplot2mtv.c:   (void) strcpy(progname,argv[0]);
./plotmtv_1.4.4t/Utils/drawplot2mtv.c:         (void) strcpy(outfile,argv[i]);
./plotmtv_1.4.4t/Utils/drawplot2mtv.c:         (void) strcpy(datafile,argv[i]);
./plotmtv_1.4.4t/Utils/mtv2mtv.c:   (void) strcpy(progname,argv[0]);
./plotmtv_1.4.4t/Utils/mtv2mtv.c:         (void) strcpy(outfile,argv[i]);
./plotmtv_1.4.4t/Utils/mtv2mtv.c:         (void) strcpy(datafile,argv[i]);
./plotmtv_1.4.4t/Utils/pdraw2mtv.c:   (void) strcpy(progname,argv[0]);
./plotmtv_1.4.4t/Utils/pdraw2mtv.c:         (void) strcpy(outfile,argv[i]);
./plotmtv_1.4.4t/Utils/pdraw2mtv.c:         (void) strcpy(datafile,argv[i]);
./plplot_5.9.0/bindings/tcl/tclMain.c:    sprintf(usage, "\nUsage:\n        %s [filename] [options]\n", argv[0]);
./plplot_5.9.0/bindings/tcl/tclMatrix.c:    strcpy(matPtr->name, argv[0]);
./plplot_5.9.0/bindings/tk/plframe.c:        strcpy(tmpstring,argv[2]);
./plplot_5.9.0/bindings/tk/plframe.c:        strcpy(tmpstring,argv[2]);
./plplot_5.9.0/lib/csa/csa.c:                strcpy(prmstr, argv[i]);
./poco_1.3.2+dfsg1/Data/SQLite/src/sqlite3.c:    strcpy(z, argv[i]);
./prboom_2.4.7+dfsg/src/d_main.c:      strcpy(basesavegame,myargv[i+1]);  //jff 3/24/98 use that for savegame
./prboom_2.4.7+dfsg/src/d_main.c:        strcpy(fname,&myargv[i][1]);
./prboom_2.4.7+dfsg/src/d_main.c:          strcat(strcpy(fname,I_DoomExeDir()),&myargv[i][1]);
./prboom_2.4.7+dfsg/src/d_main.c:          AddDefaultExtension(strcpy(file, myargv[p]), ".bex");
./prboom_2.4.7+dfsg/src/d_main.c:              AddDefaultExtension(strcpy(file, myargv[p]), ".deh");
./prboom_2.4.7+dfsg/src/d_main.c:      strcpy(file,myargv[p+1]);
./prboom_2.4.7+dfsg/src/mmus2mid.c:    strcpy(musfile,argv[i]);
./prboom_2.4.7+dfsg/src/SDL/i_system.c:      strcpy(base,*myargv);
./procmail_3.22/src/manconf.c:   { sprintf(filebuf,"%s.%04d",*gargv,filecount++);freopen(filebuf,"w",stdout);
./procps_3.2.7/vmstat.c:		strcpy(szDataUnit, *argv);
./proftpd-dfsg_1.3.1/contrib/mod_ban.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "unknown ", cmd->argv[0], " name: '",
./proftpd-dfsg_1.3.1/contrib/mod_ifsession.c:        CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, ": '", cmd->argv[2], "' failed "
./proftpd-dfsg_1.3.1/contrib/mod_quotatab.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "'", cmd->argv[1], "' failed regex "
./proftpd-dfsg_1.3.1/contrib/mod_radius.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, ": vendor id '", cmd->argv[2],
./proftpd-dfsg_1.3.1/contrib/mod_rewrite.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, cmd->argv[0], ": multiple "     
./proftpd-dfsg_1.3.1/contrib/mod_rewrite.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, cmd->argv[0], ": absolute path "
./proftpd-dfsg_1.3.1/contrib/mod_rewrite.c:      CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, cmd->argv[0],
./proftpd-dfsg_1.3.1/contrib/mod_rewrite.c:      CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, cmd->argv[0],
./proftpd-dfsg_1.3.1/contrib/mod_rewrite.c:      CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, cmd->argv[0],
./proftpd-dfsg_1.3.1/contrib/mod_rewrite.c:      CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, cmd->argv[0],
./proftpd-dfsg_1.3.1/contrib/mod_site_misc.c:      path = pstrcat(cmd->tmp_pool, path, *path ? " " : "", cmd->argv[i], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_site_misc.c:      path = pstrcat(cmd->tmp_pool, path, *path ? " " : "", cmd->argv[i], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_site_misc.c:      path = pstrcat(cmd->tmp_pool, path, *path ? " " : "", cmd->argv[i], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql.c:      query = pstrcat(cmd->tmp_pool, c->argv[2], " SET ", outs, NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql.c:      query = pstrcat(cmd->tmp_pool, "INTO ", c->argv[2], " VALUES (",
./proftpd-dfsg_1.3.1/contrib/mod_sql.c:  name = pstrcat(cmd->tmp_pool, "SQLLog_", cmd->argv[0], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql.c:  name = pstrcat(cmd->tmp_pool, "SQLLog_ERR_", cmd->argv[0], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql.c:  name = pstrcat(cmd->tmp_pool, "SQLShowInfo_", cmd->argv[0], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql.c:  name = pstrcat(cmd->tmp_pool, "SQLShowInfo_ERR_", cmd->argv[0], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql.c:  name = pstrcat(cmd->tmp_pool, "SQLNamedQuery_", cmd->argv[1], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql_mysql.c:    query = pstrcat(cmd->tmp_pool, "SELECT ", cmd->argv[1], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql_mysql.c:    query = pstrcat(cmd->tmp_pool, cmd->argv[2], " FROM ", cmd->argv[1], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql_mysql.c:      query = pstrcat(cmd->tmp_pool, query, " WHERE ", cmd->argv[3], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql_mysql.c:      query = pstrcat(cmd->tmp_pool, query, " LIMIT ", cmd->argv[4], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql_mysql.c:    query = pstrcat(cmd->tmp_pool, "INSERT ", cmd->argv[1], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql_mysql.c:    query = pstrcat( cmd->tmp_pool, "INSERT INTO ", cmd->argv[1], " (",
./proftpd-dfsg_1.3.1/contrib/mod_sql_mysql.c:    query = pstrcat(cmd->tmp_pool, "UPDATE ", cmd->argv[1], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql_mysql.c:    query = pstrcat( cmd->tmp_pool, "UPDATE ", cmd->argv[1], " SET ",
./proftpd-dfsg_1.3.1/contrib/mod_sql_mysql.c:      query = pstrcat( cmd->tmp_pool, query, " WHERE ", cmd->argv[3], NULL );
./proftpd-dfsg_1.3.1/contrib/mod_sql_mysql.c:  query = pstrcat(cmd->tmp_pool, cmd->argv[1], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql_postgres.c:    query = pstrcat(cmd->tmp_pool, "SELECT ", cmd->argv[1], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql_postgres.c:    query = pstrcat( cmd->tmp_pool, cmd->argv[2], " FROM ", 
./proftpd-dfsg_1.3.1/contrib/mod_sql_postgres.c:      query = pstrcat( cmd->tmp_pool, query, " WHERE ", cmd->argv[3], NULL );
./proftpd-dfsg_1.3.1/contrib/mod_sql_postgres.c:      query = pstrcat( cmd->tmp_pool, query, " LIMIT ", cmd->argv[4], NULL );
./proftpd-dfsg_1.3.1/contrib/mod_sql_postgres.c:    query = pstrcat(cmd->tmp_pool, "INSERT ", cmd->argv[1], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql_postgres.c:    query = pstrcat( cmd->tmp_pool, "INSERT INTO ", cmd->argv[1], " (",
./proftpd-dfsg_1.3.1/contrib/mod_sql_postgres.c:    query = pstrcat(cmd->tmp_pool, "UPDATE ", cmd->argv[1], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_sql_postgres.c:    query = pstrcat( cmd->tmp_pool, "UPDATE ", cmd->argv[1], " SET ",
./proftpd-dfsg_1.3.1/contrib/mod_sql_postgres.c:      query = pstrcat( cmd->tmp_pool, query, " WHERE ", cmd->argv[3], NULL );
./proftpd-dfsg_1.3.1/contrib/mod_sql_postgres.c:  query = pstrcat(cmd->tmp_pool, cmd->argv[1], NULL);
./proftpd-dfsg_1.3.1/contrib/mod_tls.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "'", cmd->argv[1],
./proftpd-dfsg_1.3.1/contrib/mod_tls.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "'", cmd->argv[1],
./proftpd-dfsg_1.3.1/contrib/mod_tls.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "'", cmd->argv[1],
./proftpd-dfsg_1.3.1/contrib/mod_tls.c:  CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "The ", cmd->argv[0],
./proftpd-dfsg_1.3.1/contrib/mod_tls.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "'", cmd->argv[1],
./proftpd-dfsg_1.3.1/contrib/mod_tls.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "'", cmd->argv[1],
./proftpd-dfsg_1.3.1/contrib/mod_tls.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "'", cmd->argv[1],
./proftpd-dfsg_1.3.1/contrib/mod_tls.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "'", cmd->argv[1],
./proftpd-dfsg_1.3.1/contrib/mod_tls.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "'", cmd->argv[1],
./proftpd-dfsg_1.3.1/modules/mod_auth.c:  CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "The ", cmd->argv[0], " directive "
./proftpd-dfsg_1.3.1/modules/mod_auth.c:       CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, cmd->argv[0],
./proftpd-dfsg_1.3.1/modules/mod_core.c:      CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "error including '", cmd->argv[1],
./proftpd-dfsg_1.3.1/modules/mod_core.c:    return PR_ERROR_MSG(cmd, NULL, pstrcat(cmd->tmp_pool, cmd->argv[0],
./proftpd-dfsg_1.3.1/modules/mod_core.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "'", cmd->argv[1],
./proftpd-dfsg_1.3.1/modules/mod_core.c:      CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "'", cmd->argv[2],
./proftpd-dfsg_1.3.1/modules/mod_core.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "'", cmd->argv[1], "' failed regex "
./proftpd-dfsg_1.3.1/modules/mod_core.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "'", cmd->argv[1],
./proftpd-dfsg_1.3.1/modules/mod_core.c:      return PR_ERROR_MSG(cmd, NULL, pstrcat(cmd->tmp_pool, cmd->argv[0],
./proftpd-dfsg_1.3.1/modules/mod_core.c:      return PR_ERROR_MSG(cmd, NULL, pstrcat(cmd->tmp_pool, cmd->argv[0],
./proftpd-dfsg_1.3.1/modules/mod_core.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, cmd->argv[1], ": ",
./proftpd-dfsg_1.3.1/modules/mod_core.c:    arg = pstrcat(cmd->tmp_pool, arg, *argv++, NULL);
./proftpd-dfsg_1.3.1/modules/mod_core.c:        CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "'", cmd->argv[2], "' failed "
./proftpd-dfsg_1.3.1/modules/mod_core.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "syntax: ", cmd->argv[0],
./proftpd-dfsg_1.3.1/modules/mod_core.c:  subcmd->argv[0] = pstrcat(cmd->tmp_pool, "OPTS_", cmd->argv[1], NULL);
./proftpd-dfsg_1.3.1/modules/mod_ctrls.c:          request = pstrcat(cl->cl_pool, request, " ", *reqargv++, NULL);
./proftpd-dfsg_1.3.1/modules/mod_dso.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "error loading '", cmd->argv[1],
./proftpd-dfsg_1.3.1/modules/mod_dso.c:      CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "no such module '", cmd->argv[i],
./proftpd-dfsg_1.3.1/modules/mod_dso.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, cmd->argv[1], " is not a directory",
./proftpd-dfsg_1.3.1/modules/mod_dso.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, cmd->argv[1], " is world-writable",
./proftpd-dfsg_1.3.1/modules/mod_ls.c:    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, "syntax: ", cmd->argv[0],
./proftpd-dfsg_1.3.1/modules/mod_site.c:    res = pstrcat(cmd->tmp_pool, res, cmd->argv[i], " ", NULL);
./proftpd-dfsg_1.3.1/modules/mod_site.c:    tmp = pstrcat(cmd->tmp_pool, "0", cmd->argv[1], NULL);
./proftpd-dfsg_1.3.1/src/dirtree.c:    res = pstrcat(p, cmd->argv[0], " ", cmd->arg, NULL);
./proftpd-dfsg_1.3.1/src/dirtree.c:      res = pstrcat(p, res, cmd->argv[i], " ", NULL);
./proftpd-dfsg_1.3.1/src/support.c:      res = pstrcat(p, res, " ", *argv++, NULL);
./proftpd-dfsg_1.3.1/src/support.c:      res = pstrcat(p, res, *argv++, NULL);
./psicode_3.3.0/src/bin/geom/geom.c:	strcpy(geom_file, argv[i+1]) ;
./psicode_3.3.0/src/bin/geom/geom.c:	strcpy(geom_file, argv[i+1]) ;
./psicode_3.3.0/src/bin/geom/geom.c:	strcpy(geom_file, argv[i+1]) ;
./psicode_3.3.0/src/bin/geom/geom.c:	strcpy(geom_file, argv[i+1]);
./pwlib-titan_1.11.2/src/ptlib/common/regex/split.c:			(void) strcpy(buf, argv[1]);
./pwlib-titan_1.11.2/src/ptlib/common/regex/split.c:			(void) strcpy(buf, argv[1]);
./rccp_0.9/cccp.c:							strcat(dctc_command, argv[i]);	
./rccp_0.9/cccp.c:							strcat(dctc_command, argv[i]);
./rccp_0.9/cccp.c:						strcat(dctc_command, argv[i]);	
./rccp_0.9/cccp.c:					strcat(dctc_command, argv[i]);	
./rccp_0.9/cccp.c:				sprintf(dctc_command, "/PRIV *%s*",argv[++i]);
./rccp_0.9/cccp.c:					strcat(dctc_command, argv[i]);	
./rott_1.0+dfsg/rt_crc.c:	if(argc==2) strcpy(filename,argv[1]);
./rott_1.0+dfsg/rt_main.c:        strcpy(path, argv[0]);
./rp-pppoe_3.8/gui/wrapper.c:    sprintf(fname, "/etc/ppp/rp-pppoe-gui/conf.%s", argv[2]);
./rrdtool_1.3.1/src/rrd_getopt.c:        sprintf(var, "_%d_GNU_nonoption_argv_flags_", getpid());
./saods9_4.0b7/funtools-1.3.0b9/doc/evcol.c:    sprintf(tbuf, "%s[%d]", argv[1], ext);
./saods9_4.0b7/funtools-1.3.0b9/doc/evmerge.c:    sprintf(tbuf, "merge=%s", argv[3]);
./saods9_4.0b7/funtools-1.3.0b9/funhead.c:  strcpy(iname, argv[optind+0]);
./saods9_4.0b7/funtools-1.3.0b9/funmerge.c:    strcat(tname, argv[i]);
./saods9_4.0b7/funtools-1.3.0b9/funtest/evcol.c:    sprintf(tbuf, "%s[%d]", argv[1], ext);
./saods9_4.0b7/funtools-1.3.0b9/funtest/evmerge.c:    sprintf(tbuf, "merge=%s", argv[3]);
./saods9_4.0b7/funtools-1.3.0b9/funtest/evmerge2.c:  strcpy(tbuf, argv[1]);
./saods9_4.0b7/funtools-1.3.0b9/funtest/evmerge2.c:  strcpy(tbuf, argv[2]);
./saods9_4.0b7/funtools-1.3.0b9/funtest/evmerge2.c:  strcpy(tbuf, argv[1]);
./saods9_4.0b7/funtools-1.3.0b9/funtest/funsky.c:  strcpy(iname, argv[optind+0]);
./saods9_4.0b7/htmlwidget/src/htmlcmd.c:      strcpy(htmlPtr->zHandler[type],argv[4]);
./saods9_4.0b7/htmlwidget/src/htmlparse.c:          sprintf(pElem->markup.argv[j-1],"%.*s",arglen[j],argv[j]);
./saods9_4.0b7/htmlwidget/src/htmlparse.c:      strcpy(pElem->markup.argv[i-1],argv[i]);
./saods9_4.0b7/htmlwidget/src/htmlwidget.c:    sprintf(zClipwin,"%s.x",argv[1]);
./saods9_4.0b7/htmlwidget/src/htmlwidget.c:    strcpy(htmlPtr->zCmdName, argv[1]);
./saods9_4.0b7/htmlwidget/tools/getpage.c:      sprintf(baseUrl,"%.*s", sizeof(baseUrl), argv[i+1]);
./saods9_4.0b7/htmlwidget/tools/mktclapp.c:"    strcpy(zData, argv[2]);\n"
./saods9_4.0b7/htmlwidget/tools/mktclapp.c:"      sprintf(msg, \"\\n    (file \\\"%.150s\\\" line %d)\", argv[1],\n"
./saods9_4.0b7/mktclapp/mktclapp.c:"    strcpy(zData, argv[2]);\n"
./saods9_4.0b7/mktclapp/mktclapp.c:"      sprintf(msg, \"\\n    (file \\\"%.150s\\\" line %d)\", argv[1],\n"
./saods9_4.0b7/xpa-2.1.6/dns.c:    strcpy(host, argv[1]);
./saods9_4.0b7/xpa-2.1.6/rtest.c:  strcpy(xname, argv[optind++]);
./saods9_4.0b7/xpa-2.1.6/stest.c:    strcpy(name, argv[optind]);
./saods9_4.0b7/xpa-2.1.6/xpa.c:    strcat(paramlist, argv[i]);
./scanmem_0.07/handlers.c:        strcat(command, argv[i]);
./scrollkeeper_0.3.14/cl/src/preinstall.c:	strcat(url, argv[argc - 3]); 
./secure-delete_3.1/sfill.c:       strcpy(newname, argv[loop]); // can not overflow
./secure-delete_3.1/srm.c:        strcpy(rmfile, argv[loop]);
./sextractor_2.4.4/src/main.c:              strcpy(prefs.prefs_name, argv[++a]);
./sextractor_2.4.4/src/prefs.c:        sprintf(str, "%s %s", argkey[argi], argval[argi]);
./shapetools_1.4pl6/src/vc/atfsit/atfsit.c:		sprintf(tmp, "...file (*++argv) = %s...", file);
./simh_3.7.0/TOOLS/crossassemblers/macro11/macro11.c:					strcat(temp, argv[arg+1]);
./socat_1.6.0.1/xio-exec.c:	 strcpy(tmp+1, pargv[0]);
./socat_1.6.0.1/xio-exec.c:	 strcpy(tmp, pargv[0]);
./squid_2.7.STABLE3/helpers/ntlm_auth/SMB/ntlm_auth.c:	strcpy(d, argv[j]);
./squid_2.7.STABLE3/src/win32.c:	strcpy(stderr_path, argv[0]);
./swi-prolog_5.6.58/man/calc.c:    strcpy(e, argv[n]);
./swi-prolog_5.6.58/packages/jpl/src/c/jpl.c:	strcpy( argv[i], cp);
./sysstat_8.1.2/sa_common.c:		strcpy(timestamp, argv[(*opt)++]);
./tads_3.0.8/tads2/err.c:                sprintf(buf, "%d", argv[argi].erraint);
./tads_3.0.8/tads2/glk/os_glk.c:        strcpy(buf, argv0);
./tads_3.0.8/tads2/ler.c:                sprintf(buf, "%d", argv[argi].erraint);
./tads_3.0.8/tads2/ler.c:                sprintf(buf, "%u", argv[argi].erraint);
./tads_3.0.8/tads2/tcd.c:        strcpy(buf, argv[1].errastr);
./tex-guy_1.3.2/spwg-1.2/spawg.c:      strcpy(paper, argv[1]);
./tinyirc_1.1.dfsg.1/tinyirc.c:		strcpy(hostname, argv[i]);
./tinyirc_1.1.dfsg.1/tinyircd.c:		strcpy(hostname, argv[i]);
./tinymux_2.6.5.27/src/tools/dbpuller.c:    sprintf(s_filename, "muxout_%d.txt", atoi(argv[2]));
./tk8.3_8.3.5/generic/tkClipboard.c:	sprintf(buf, "bad option \"%.50s\": must be clear or append", argv[1]);
./tk8.3_8.3.5/generic/tkTest.c:	    strcpy((char *) ckalloc(strlen(argv[3]) + 1), argv[3]);
./tk8.3_8.3.5/generic/tkTest.c:		strcpy((char *) ckalloc(strlen(argv[4]) + 1), argv[4]);
./tk8.3_8.3.5/mac/tkMacWm.c:	strcpy(wmPtr->clientMachine, argv[3]);
./tk8.3_8.3.5/mac/tkMacWm.c:	    strcpy(wmPtr->leaderName, argv[3]);
./tk8.3_8.3.5/mac/tkMacWm.c:	    strcpy(protPtr->command, argv[4]);
./tk8.3_8.3.5/mac/tkMacWm.c:	    strcpy(wmPtr->masterWindowName, argv[3]);
./tk8.3_8.3.5/unix/tkUnixWm.c:	strcpy(wmPtr->clientMachine, argv[3]);
./tk8.3_8.3.5/unix/tkUnixWm.c:	    strcpy(wmPtr->leaderName, argv[3]);
./tk8.3_8.3.5/unix/tkUnixWm.c:	    strcpy(wmPtr->iconName, argv[3]);
./tk8.3_8.3.5/unix/tkUnixWm.c:	    strcpy(protPtr->command, argv[4]);
./tk8.3_8.3.5/unix/tkUnixWm.c:	    strcpy(wmPtr->title, argv[3]);
./tk8.3_8.3.5/unix/tkUnixWm.c:	    strcpy(wmPtr->masterWindowName, argv[3]);
./tk8.3_8.3.5/win/tkWinWm.c:	strcpy(wmPtr->clientMachine, argv[3]);
./tk8.3_8.3.5/win/tkWinWm.c:	    strcpy(wmPtr->leaderName, argv[3]);
./tk8.3_8.3.5/win/tkWinWm.c:	    strcpy(protPtr->command, argv[4]);
./tleds_1.05beta10/tleds.c:    strcat(pidFileName, MYNAME);	/* Was argv[0]. Probs coz/if path. */
./tn5250_0.17.3/win32/lp5250d-win.c:                            strcpy(my_argv[argcnt], arg);
./tn5250_0.17.3/win32/lp5250d-win.c:            strcpy(my_argv[argcnt], arg);
./tn5250_0.17.3/win32/tn5250-win.c:                            strcpy(my_argv[argcnt], arg);
./tn5250_0.17.3/win32/tn5250-win.c:            strcpy(my_argv[argcnt], arg);
./uae_0.8.28/amiga/source/transdisk.c:	    sprintf(devicebuf, "%s.device", argv[i+1]);
./udftools_1.0.0b3/mkudffs/options.c:	strcpy(device, argv[optind]);
./uutraf_1.1-13/uutraf.c:    strcpy(logfilename, argv[optind]);
./uutraf_1.1-13/uutraf.c:    strcpy(statsfilename, argv[optind]);
./vde2_2.2.2/src/unixcmd.c:	if (!rcfile) asprintf(&rcfile,"%s/%s",STD_RC_DIR,basename(argv[0]));
./vde2_2.2.2/src/unixcmd.c:	if (!sockname) asprintf(&sockname,"%s/%s",STD_SOCK_DIR,basename(argv[0]));
./vice_1.22.dfsg1/src/arch/os2/archdep.c:        strcat(strcat(res," "), argv[i]);
./vice_1.22.dfsg1/src/initcmdline.c:                strcat(strcat(txt, " "), argv[j]);
./vice_1.22.dfsg1/src/petcat.c:                sprintf(outfilename, "%s%s", argv[0], extension);
./vls_0.5.4+cvs20031028/src/extras/getopt.c:		sprintf(var, "_%d_GNU_nonoption_argv_flags_", getpid());
./vncsnapshot_1.2a/vncpasswd.c:      strcpy(passwdFile,argv[1]);
./vte_0.16.14/src/ssfe.c:      strcat(tmpstr, argv[i]);
./vtk_5.0.4/CMake/cmVTKWrapTcl2Command.c:      sprintf(sourceListValue,"%s;%sInit.cxx",def,argv[0]);
./vtk_5.0.4/CMake/cmVTKWrapTcl2Command.c:      sprintf(sourceListValue,"%sInit.cxx",argv[0]);
./vtk_5.0.4/CMake/cmVTKWrapTcl2Command.c:    sprintf(newName,"%sInit",argv[0]);
./vtk_5.0.4/Wrapping/vtkWrapTcl.c:    fprintf(fp,"    temp%i->command = strcpy(new char [strlen(argv[2])+1],argv[2]);\n",i);
./vtk_5.0.4/Wrapping/vtkWrapTcl.c:  fprintf(fp,"    char temps2[256];\n    sprintf(temps2,\"Object named: %%s, could not find requested method: %%s\\nor the method was called with incorrect arguments.\\n\",argv[0],argv[1]);\n    Tcl_AppendResult(interp,temps2,NULL);\n    }\n");
./wdm_1.28/src/TestLogin/TestLogin.c:			sprintf(nargv[argc - 1], "-f%i", filedescriptor[1]);
./wdm_1.28/src/wdm/Greet.c:		sprintf(argv[argc++], "-x%i", wdmXineramaHead);
./wdm_1.28/src/wdm/Greet.c:	sprintf(argv[argc++], "-f%i", pipe_filedes[1]);
./wengophone_2.1.2.dfsg0/wifo/ortp/src/mrtprecv.c:		sprintf(filename,"%s%4.4d.dat",argv[1],i);
./wengophone_2.1.2.dfsg0/wifo/ortp/src/rtpmemtest.c:		sprintf(filename,"%s%4.4d.dat",argv[1],i);
./wengophone_2.1.2.dfsg0/wifo/ortp/src/tevmrtprecv.c:		sprintf(filename,"%s%4.4d.dat",argv[1],i);
./wily_0.13.41/tools/old/reader/mail.c:		strcpy(mboxname, argv[1]);
./wily_0.13.41/tools/old/wilytoys/reader/mail.c:		strcpy(mboxname, argv[1]);
./wily_0.13.41/tools/old/wilytoys/reader2/mail.c:		strcpy(mboxname, argv[1]);
./wine_1.0.1/dlls/kernel32/tests/actctx.c:    sprintf(cmdline, "\"%s\" %s manifest1", argv[0], argv[1]);
./wine_1.0.1/dlls/kernel32/tests/debugger.c:    sprintf(cmd, "%s debugger %s %s %%ld %%ld", argv0, dbgtasks, dbglog);
./wine_1.0.1/dlls/kernel32/tests/debugger.c:    sprintf(cmd, "%s debugger crash %s", argv0, childlog);
./wine_1.0.1/dlls/kernel32/tests/debugger.c:    sprintf(cmd, "%s debugger crash", argv0);
./wine_1.0.1/dlls/kernel32/tests/thread.c:    sprintf(cmdline, "%s %s %s", argv[0], argv[1], arg);
./wine_1.0.1/dlls/kernel32/tests/toolhelp.c:    strcpy(selfname, argv[0]);
./wine_1.0.1/dlls/kernel32/tests/virtual.c:    sprintf(cmdline, "%s %s %s", argv[0], argv[1], arg);
./wine_1.0.1/dlls/ntdll/tests/exception.c:    sprintf(cmdline, "%s %s %s %p", my_argv[0], my_argv[1], "debuggee", &test_stage);
./wine_1.0.1/dlls/ole32/tests/marshal.c:    sprintf(cmdline, "%s %s %s", argv[0], argv[1], arg);
./wine_1.0.1/dlls/shell32/tests/shlexec.c:        sprintf(cmd,"%s shlexec \"%s\" %s", argv0, child_file, cmdtail);
./wine_1.0.1/dlls/shell32/tests/shlexec.c:            sprintf(key, "argvA%d", i);
./wine_1.0.1/dlls/shell32/tests/shlexec.c:                sprintf(attrib, "argvA%d", count);
./wine_1.0.1/dlls/shell32/tests/shlexec.c:    strcpy(defApplication, strrchr(argv0, '\\')+1);
./wine_1.0.1/dlls/shell32/tests/shlexec.c:        strcat(argv0, ".so");
./wine_1.0.1/dlls/user32/tests/cursoricon.c:    sprintf(path_name, "%s cursoricon %x", test_argv[0], (unsigned int) parent);
./wine_1.0.1/dlls/user32/tests/dde.c:    sprintf(buffer, "%s dde ddeml", argv[0]);
./wine_1.0.1/dlls/user32/tests/dde.c:    sprintf(buffer, "%s dde msg", argv[0]);
./wine_1.0.1/libs/wine/config.c:            strcpy( argv[0] + (ptr - pos), "/" );
./wine_1.0.1/libs/wine/config.c:            strcat( argv[0] + (ptr - pos), name );
./wine_1.0.1/programs/winedbg/tgt_active.c:        strcat(cmd_line, argv[i]);
./wine_1.0.1/tools/winebuild/import.c:        p += sprintf( p, " %s", argv[i] );
./wine_1.0.1/tools/wmc/wmc.c:		strcat(cmdline, argv[i]);
./wine_1.0.1/tools/wrc/wrc.c:		strcat(cmdline, argv[i]);
./wmcalclock_1.25/Src/wmCalClock.c:            strcpy(TimeColor, argv[++i]);
./wmcalclock_1.25/Src/wmCalClock.c:            strcpy(BackgroundColor, argv[++i]);
./wmcalclock_1.25/Src/wmCalClock.c:	    strcpy(ExecuteCommand, argv[++i]);
./wmclock_1.0.12.2/asclock-orig/asclock.c:	strcpy(&Execute[0], argv[i]);
./wmclock_1.0.12.2/asclock-orig/asclock.c:	strcpy(&clockxpm[0], argv[i]);
./wmclock_1.0.12.2/asclock-orig/asclock.c:	strcpy(&monthxpm[0], argv[i]);
./wmclock_1.0.12.2/asclock-orig/asclock.c:	strcpy(&weekxpm[0], argv[i]);
./wmitime_0.3/wmitime/wmitime.c:                    strcpy(uconfig_file, argv[i+1]);
./wmload_0.9.2/wmload.c:	strcpy(&Execute[0], argv[i]);
./wmtimer_2.92/wmtimer/wmtimer.c:	  strcpy(command, argv[argIndex+1]);
./workman_1.3.4/buildindex.c:			sprintf(indname, "%s: fstat", argv[i]);
./workman_1.3.4/buildindex.c:			sprintf(indname, "%s: Warning: Couldn't lock", argv[i]);
./workman_1.3.4/buildindex.c:		sprintf(indname, "%s.ind", argv[i]);
./workman_1.3.4/workman_stubs.c:			sprintf(cddaslave_path, "%s/cddaslave", argv[0]);
./xapian-core_1.0.7/queryparser/lemon.c:    if( path ) sprintf(path,"%s/%s",argv0,name);
./xdigger_1.0.10/sound.c:      for (i = 1; i < pargc; i++) {strcpy(pargv[i], "");}
./xdigger_1.0.10/sound.c:      strcat(pargv[0], " (Soundserver)");
./xdigger_1.0.10/sound.c:      if (sound_device == SD_DSP) strcat(pargv[0], " (dsp)");
./xdigger_1.0.10/sound.c:      if (sound_device == SD_AUDIO) strcat(pargv[0], " (audio)");
./xdigger_1.0.10/xdigger.c:  strcpy(progname, argv[0]);
./xmahjongg_3.7/liblcdf/giftoc.c:    strcat(file_name, argv[0]);
./xmcd_2.6/util_d/cddbcmd.c:		(void) strcat(cmd, argv[i]);
./xmcd_2.6/xmcd_d/main.c:			(void) strcat(cmd, argv[i]);
./xmedcon_0.10.4/source/m-getopt.c:             strcat(input->list,argv[a]); strcat(input->list," ");
./xmotd_1.17.3b/main.c:				  strcpy(name, argv[i]);
./xmotd_1.17.3b/textmode.c:				  strcpy(stampfile, (argv[i+1])); /* next param is the filename */
./xpilot-ng_4.7.3~cvs20080224/src/mapedit/main.c:	    strcpy(fontname, argv[index]);
./xpilot-ng_4.7.3~cvs20080224/src/mapedit/main.c:	    strcpy(display_name, argv[index]);
./xpilot-ng_4.7.3~cvs20080224/src/mapedit/main.c:		strcpy(map.mapFileName, argv[index]);
./xplanet_1.2.0/src/libimage/pnm.c:    strcpy(argv[0], "loadimage");
./xscorch_0.2.0/sutil/getopt.c:		sprintf(var, "_%d_GNU_nonoption_argv_flags_", getpid());
./xt_0.9.1/main.c:	  strcpy(user_settings->current_target, argv[i]);
./xterm_235/resize.c:	sprintf(tmpbuf, setsize[emu], argv[0], argv[1]);
./xulrunner_1.9.0.19/db/sqlite3/src/sqlite3.c:    strcpy(z, argv[i]);
./xulrunner_1.9.0.19/security/nss/lib/sqlite/sqlite3.c:  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));
./xulrunner_1.9.0.19/security/nss/lib/sqlite/sqlite3.c:  strcpy((char*)z, (char*)sqlite3_value_text(argv[0]));
./xulrunner_1.9.0.19/security/nss/lib/sqlite/sqlite3.c:        strcpy(z, argv[i]);
./xwpe_1.5.30a/old/we_djgpp.c:   strcpy(s_tmp, argv[0]);
./xwpe_1.5.30a/we_main.c:    strcpy(cn->optfile, argv[i+1]);
./xwpe_1.5.30a/we_prog.c:  strcat(tmp, argv[i]);
./xwrits_2.21/giftoc.c:    strcat(file_name, argv[0]);
./yap_5.1.1/C/load_aout.c:      strcpy(Yap_FileNameBuf, Yap_argv[0]);
./yap_5.1.1/C/load_aout.c:    strcpy(cp2, Yap_argv[0]);
./yap_5.1.1/C/load_aout.c:  strcpy(Yap_FileNameBuf, Yap_argv[0]);
./yap_5.1.1/C/load_coff.c:      strcpy(Yap_FileNameBuf, Yap_argv[0]);
./yap_5.1.1/C/load_coff.c:    strcpy(cp2, Yap_argv[0]);
./yap_5.1.1/C/load_coff.c:  strcpy(Yap_FileNameBuf, Yap_argv[0]);
./yap_5.1.1/LGPL/JPL/src/jpl.c:	strcpy( argv[i], cp);
./zmakebas_1.2/zmakebas.c:  strcpy(infile,argv[optind]);
./asclock_2.0.12/config.c:        strcpy(exec_str, argv[i]);
./atp_1.2/atp.c:        strcpy(option,*argv++);
./atp_1.2/atp.c:	    strcpy(title,*argv++);
./atp_1.2/atp.c:		    sprintf(wm_string," %s ",*argv);
./atp_1.2/atp.c:		    strcpy(wm_string,*argv);
./atp_1.2/atp.c:            strcpy(title,*argv);
./atp_1.2/atp.c:	    strcpy(file_in,*argv);
./atp_1.2/atp.c:            	sprintf(filename,"%s.ps",*argv);
./atp_1.2/atp.c:    	    	strcpy(title,*argv);
./autofs5_5.0.3/daemon/lookup.c:	strcat(path, map->argv[0]);
./autofs5_5.0.3/daemon/lookup.c:	strcat(path, map->argv[0]);
./autofs5_5.0.3/modules/lookup_multi.c:			strcat(path, argv[0]);
./autofs5_5.0.3/modules/parse_sun.c:				strcpy(noptstr + optlen + 1, argv[i] + offset);
./autofs5_5.0.3/modules/parse_sun.c:				strcpy(noptstr, argv[i] + offset);
./ax25-tools_0.0.8/ax25/bpqparms.c:	strcpy(dev, argv[1]);
./ax25-tools_0.0.8/ax25/bpqparms.c:	strcpy(dev, argv[optind]);
./ax25-tools_0.0.8/rose/rsparms.c:	strcpy(nodeaddr, argv[3]);
./ax25-tools_0.0.8/user_call/ax25_call.c:		sprintf(buffer, "ERROR: invalid AX.25 port name - %s\r", argv[optind]);
./ax25-tools_0.0.8/user_call/ax25_call.c:		sprintf(buffer, "ERROR: invalid AX.25 port callsign - %s\r", argv[optind]);
./ax25-tools_0.0.8/user_call/ax25_call.c:		sprintf(buffer, "ERROR: invalid callsign - %s\r", argv[optind + 1]);
./ax25-tools_0.0.8/user_call/ax25_call.c:	sprintf(buffer, "Connecting to %s ...\r", argv[optind + 2]);
./ax25-tools_0.0.8/user_call/netrom_call.c:		sprintf(buffer, "ERROR: invalid NET/ROM port name - %s\r", argv[optind]);
./ax25-tools_0.0.8/user_call/netrom_call.c:		sprintf(buffer, "ERROR: invalid NET/ROM port callsign - %s\r", argv[optind]);
./ax25-tools_0.0.8/user_call/netrom_call.c:		sprintf(buffer, "ERROR: invalid callsign - %s\r", argv[optind + 1]);
./ax25-tools_0.0.8/user_call/netrom_call.c:		sprintf(buffer, "ERROR: invalid callsign - %s\r", argv[optind + 2]);
./ax25-tools_0.0.8/user_call/netrom_call.c:	sprintf(buffer, "Connecting to %s ...\r", argv[optind + 2]);
./ax25-tools_0.0.8/user_call/rose_call.c:		sprintf(buffer, "ERROR: invalid Rose port name - %s\r", argv[optind]);
./ax25-tools_0.0.8/user_call/rose_call.c:		sprintf(buffer, "ERROR: invalid Rose port address - %s\r", argv[optind]);
./ax25-tools_0.0.8/user_call/rose_call.c:		sprintf(buffer, "ERROR: invalid callsign - %s\r", argv[optind + 1]);
./ax25-tools_0.0.8/user_call/rose_call.c:		sprintf(buffer, "ERROR: invalid callsign - %s\r", argv[optind + 2]);
./ax25-tools_0.0.8/user_call/rose_call.c:		sprintf(buffer, "ERROR: invalid Rose address - %s\r", argv[optind + 3]);
./ax25-tools_0.0.8/user_call/rose_call.c:	sprintf(buffer, "Connecting to %s @ %s ...\r", argv[optind + 2], argv[optind + 3]);
./bison_2.3.dfsg/djgpp/subpipe.c:    strcpy(arguments[argc], argv[argc]);
./crack_5.0a/src/util/dictfilt.c:	strcpy(rbuff, argv[1]);
./cvstrac_2.0.1/maketestdb.c:  sprintf(zDbName, "%s.db", argv[1]);
./cvstrac_2.0.1/md5.c:        sprintf(zLine,"can't open \"%.*s\"",(int)sizeof(zLine)-100,argv[i]);
./dialign_2.2.1/src/dialign.c:     strcpy( arguments[i] , argv[i] );
./dialign_2.2.1/src/dialign.c: strcpy( input_name , argv[ argc - 1 ] );
./dialign_2.2.1/src/dialign.c:     strcat( input_line , argv[i] );
./dialign_2.2.1/src/dialign.c:     strcat( input_line , argv[i] );
./dpkg_1.14.29/src/main.c:    sprintf(nargv[i], "--admindir=%s", admindir);
./dpkg_1.14.29/src/main.c:  strcpy(nargv[i], "--");
./dpkg_1.14.29/src/main.c:  strcat(nargv[i], cipaction->olong);
./em8300_0.16.4/em8300setup/em8300setup.c:								sprintf(ucode_file,"%s", argv[optindex++]);
./fortunes-bofh-excuses_1.2/src/strfile.c:			(void) strcpy(Outfile, *argv);
./gammu_1.20.0/gammu/gammu.c:				strcpy(smcfg->DebugLevel, argv[1 + start]);
./gammu_1.20.0/gammu/message.c:		strcpy(MMSInfo.Address,	argv[3+startarg]);
./gammu_1.20.0/gammu/message.c:		strcpy(MMSInfo.Title,	argv[4+startarg]);
./gammu_1.20.0/gammu/message.c:		strcpy(MMSInfo.Sender,	argv[5+startarg]);
./gammu_1.20.0/gammu/message.c:		strcpy(MMSInfo.Address,	argv[3+startarg]);
./gammu_1.20.0/gammu/message.c:		strcpy(MMSInfo.Title,	argv[4+startarg]);
./gammu_1.20.0/gammu/misc.c:	strcpy(Code.Code,argv[3]);
./gammu_1.20.0/gammu/nokia.c:		sprintf(buffer,"%s.jad",argv[3]);
./gammu_1.20.0/gammu/nokia.c:		sprintf(buffer,"%s.jar",argv[3]);
./gammu_1.20.0/gammu/nokia.c:		sprintf(buffer,"%s.jar",argv[3]);
./gammu_1.20.0/gammu/nokia.c:		sprintf(buffer,"%s.jad",argv[3]);
./gammu_1.20.0/gammu/nokia.c:		sprintf(buffer,"%s.jar",argv[3]);
./gammu_1.20.0/gammu/nokia.c:		strcpy(buffer,argv[3]);
./gammu_1.20.0/gammu/nokia.c:					strcpy(buffer,argv[j]);
./gammu_1.20.0/gammu/sniff.c:		strcpy(gsm->CurrentConfig->Model,argv[4]);
./gammu_1.20.0/gammu/sniff.c:		strcpy(gsm->CurrentConfig->Model,argv[3]);
./gcl_2.6.7/gcl-tk/tkMain.c:	  strcpy(q,argv[i]);
./gcl_2.6.7/o/main.c:		strcpy(system_directory, argv[1]);
./gcl_2.6.7/o/main.c:		strcpy(system_directory, argv[1]);
./gcl_2.6.7/xbin/spp.c:	strcpy(sfile_name,argv[1]);
./icon_9.4.3/ipl/cfuncs/lgconv.c:      sprintf(tbuf, "%ld", IntegerVal(argv[1]));
./icon_9.4.3/src/xpm/converters/ppmtoxpm.c:	    strcpy(out_name, argv[argn]);
./intercal_0.28/src/perpet.c:	  (void) sprintf(buf2, "%s.c", argv[optind]);
./intercal_0.28/src/perpet.c:	  (void) sprintf(buf2, tempfn, argv[optind]);
./intercal_0.28/src/perpet.c:	  strcpy(argv[optind],buf2);
./intercal_0.28/src/perpet.c:      (void) strcpy(buf, argv[optind]);
./intercal_0.28/src/perpet.c:      strcpy(path,argv[0]);
./intercal_0.28/src/perpet.c:	  sprintf(buf2,"%s" EXEEXT,argv[optind]);
./intercal_0.28/src/perpet.c:	  (void) sprintf(buf2,"sh %s %s", cooptsh, argv[optind]);
./intercal_0.28/src/perpet.c:      strcat(buf2,argv[optind]);
./ion3_20080825/libtu/snprintf_2.2/test.c:      len2 = sprintf(str2,                  argv[1], j, 3);
./ion3_20080825/libtu/snprintf_2.2/test.c:      len2 = sprintf(str2,                  argv[1], argv[2], 3);
./ion3_20080825/mod_sm/sm_matchwin.c:        strcpy(command, cmd_argv[0]);
./ion3_20080825/mod_sm/sm_matchwin.c:            strcat(command, cmd_argv[i]);
./irda-utils_0.9.18/irattach/dongle_attach.c:	strcpy(dev, argv[1]);
./irda-utils_0.9.18/irnetd/irnetd.c:	  strcat(cmd, argv[i]);
./irmp3_0.5.7pre2/src/irmp3/irmp3.c:	    strcat(commands,state->argv[i]);
./libburn_0.4.4/cdrskin/cdrskin.c:       strcpy((*argv)[0],progname);
./libburn_0.4.4/cdrskin/cdrskin.c:         strcpy((*argv)[argcount],buf);
./libburn_0.4.4/cdrskin/cdrskin.c:     strcpy(o->fallback_program,argv[i]+17);
./libburn_0.4.4/cdrskin/cdrskin.c:     strcpy(skin->eject_device,argv[i]+13);
./libburn_0.4.4/cdrskin/cdrskin.c:     strcpy(skin->source_path,argv[i]);
./libburn_0.4.4/test/fake_au.c:     strcpy(out_path, argv[i]);
./libburn_0.4.4/test/fake_au.c:     strcpy(in_path, argv[i]);
./libburn_0.4.4/test/libburner.c:                strcpy(drive_adr, argv[i]);
./libburn_0.4.4/test/libburner.c:            strcpy(source_adr[source_adr_count], argv[i]);
./libburn_0.4.4/test/telltoc.c:                strcpy(drive_adr, argv[i]);
./libburn_0.4.4/test/telltoc.c:                strcpy(print_raw_file, strchr(argv[i], ':') + 1);
./libxslt_1.1.24/doc/tutorial2/libxslt_pipes.c:        strcpy(argument, argv[arg_indx]);
./lm-sensors_2.10.7/prog/eepromer/eepromer.c:			 strcpy(device,argv[i+1]);	 
./loki_2.4.7.4/utils/hist.c:		(void)strcpy(Infile,argv[optind]);
./lustre_1.6.5.1/lnet/utils/debug.c:                strcpy(filename, argv[1]);
./lustre_1.6.5.1/lnet/utils/parser.c:                strcat(line, argv[i]);
./lustre_1.6.5.1/lustre/tests/chownmany.c:		sprintf(format, "%s%%d", argv[2]);
./lustre_1.6.5.1/lustre/tests/createdestroy.c:                                sprintf(filename, "%s-%ld", argv[1], i);
./lustre_1.6.5.1/lustre/tests/createmany-mpi.c:                sprintf(format, "%s%%d", argv[2]);
./lustre_1.6.5.1/lustre/tests/createmany.c:                sprintf(format, "%s%%d", argv[2]);
./lustre_1.6.5.1/lustre/tests/createtest.c:		sprintf(name, "%s-mknod%06o", argv[1], mode);
./lustre_1.6.5.1/lustre/tests/createtest.c:		sprintf(name, "%s-creat%06o", argv[1], mode);
./lustre_1.6.5.1/lustre/tests/createtest.c:		sprintf(name, "%s-mkdir%06o", argv[1], i | 0644);
./lustre_1.6.5.1/lustre/tests/mkdirmany.c:                sprintf(dirname, "%s-%d", argv[1], i);
./lustre_1.6.5.1/lustre/tests/openclose.c:                        sprintf(filename, "%s-%d", argv[1], thread);
./lustre_1.6.5.1/lustre/tests/openclose.c:                        strcpy(filename, argv[1]);
./lustre_1.6.5.1/lustre/tests/rename_many.c:			sprintf(msg, "chdir '%s'\n", argv[optind]);
./lustre_1.6.5.1/lustre/tests/rmdirmany.c:                sprintf(dirname, "%s-%d", argv[1], i);
./lustre_1.6.5.1/lustre/tests/unlinkmany.c:		sprintf(format, "%s%%d", argv[1]);
./lustre_1.6.5.1/lustre/tests/writemany.c:        sprintf(cmdname, "%s", argv[0]);
./lustre_1.6.5.1/lustre/tests/writemany.c:                        sprintf(cmdname, "%s-%d", argv[0], i);
./lustre_1.6.5.1/lustre/utils/loadgen.c:        sprintf(cmdname, "%s", argv[0]);
./lustre_1.6.5.1/lustre/utils/ltrack_stats.c:                strcat(command, argv[index]);
./lustre_1.6.5.1/lustre/utils/parser.c:                strcat(line, argv[i]);
./lv_4.51/src/command.c:      sprintf( num, argv[ argc ], line );
./lv_4.51/src/conf.c:    strcpy( helpFile, argv[ 0 ] );
./metamail_2.7/metamail/metamail.c:                    strcpy(ContentType,argv[i]);
./metamail_2.7/metamail/metamail.c:            strcat(FullCmd, argv[i]);
./metamail_2.7/richmail/richtext.c:		strcpy(charsetname, argv[i] + 2);
./metamail_2.7/richmail/richtext.c:		strcpy(charsetname, argv[++i]);
./metamail_2.7/src/metamail/metamail.c:                    strcpy(ContentType,argv[i]);
./metamail_2.7/src/metamail/metamail.c:            strcat(FullCmd, argv[i]);
./metamail_2.7/src/richmail/richtext.c:		strcpy(charsetname, argv[i] + 2);
./metamail_2.7/src/richmail/richtext.c:		strcpy(charsetname, argv[++i]);
./mgetty_1.1.36/contrib/scrts.c:	    sprintf( device, "/dev/%s", argv[i] );
./mgetty_1.1.36/contrib/scrts.c:	    strcpy( device, argv[i] );
./mgetty_1.1.36/sendfax.c:		sprintf( done, "%s.done", argv[argidx] );
./mgetty_1.1.36/tools/mid.c:	    strcpy( device, argv[optind] );
./mgetty_1.1.36/tools/mid.c:	    sprintf( device, "/dev/%s", argv[optind]);
./ncdu_1.3/src/settings.c:      strcpy(sdir, argv[i]);
./ncurses_5.7+20081213/progs/toe.c:		(void) sprintf(cwd_buf, "%s/%.*s/", eargv[i], (int) len, name_1);
./nethack_3.4.3/util/dgn_main.c:		fname = strcpy(infile, argv[i]);
./nethack_3.4.3/win/gem/tile2img.c:		strcpy(bmpname, argv[1]);
./nethack_3.4.3/win/share/tile2bmp.c:		strcpy(bmpname, argv[1]);
./pcp_2.7.4-20080507/src/pmdas/summary/pmda.c:	    strcat(command, argv[i]);
./pristine-tar_0.17/zgz.c:		strcpy(argv[0], "gzip"); 
./pymol_1.1/layer1/P.c:	strcat(line1,argv[0]);
./pymol_1.1/layer1/P.c:        strcat(line1,argv[0]);
./pymol_1.1/layer1/P.c:        strcat(line1,argv[0]);
./python-stdlib-extensions_2.5.2-1/2.3/Modules/_tkinter.c:	strcpy(argv0, className);
./python-stdlib-extensions_2.5.2-1/2.4/Modules/_tkinter.c:	strcpy(argv0, className);
./python-stdlib-extensions_2.5.2-1/2.5/Modules/_tkinter.c:	strcpy(argv0, className);
./rcalc_0.5.0/src/engine/command.c:    strcat(buffer,argv[i]);
./sash_3.7/utils.c:		strcpy(buf, *argv++);
./sfront_0.91/src/csyslib.c:  z[lc++]="	    sprintf(name,\"%s.mp4\",csys_argv[i]);";
./sfront_0.91/src/csyslib.c:  z[lc++]="		sprintf(name,\"%s.mp4\",csys_sfront_argv[i]);";
./sfront_0.91/src/lib/csys/fstr.c:	    sprintf(name,"%s.mp4",csys_argv[i]);
./sfront_0.91/src/lib/csys/fstr.c:		sprintf(name,"%s.mp4",csys_sfront_argv[i]);
./sfront_0.91/src/sfmain.c:      strcat(strcpy(name, argv[i]), ".sasl");
./sfront_0.91/src/sfmain.c:      saolfile = fopen(strcpy(name, argv[i]),"r");
./shapelib_1.2.10/contrib/shpproj.c:        strcpy( prjFileName, argv[1] );
./shapelib_1.2.10/shputils.c:    strcpy(infile, argv[1]);
./shapelib_1.2.10/shputils.c:        strcpy(outfile,argv[2]);
./shapelib_1.2.10/shputils.c:    	    strcpy(selectitem,argv[i]);
./shapelib_1.2.10/shputils.c:    	    strcpy(temp,argv[i]);
./shapelib_1.2.10/shputils.c:                strcpy(clipfile,argv[i]);
./t-coffee_5.72/t_coffee_source/reformat.c: 			sprintf( in_file, "%s", argv[a+1]);
./t-coffee_5.72/t_coffee_source/reformat.c: 			sprintf( rename_file, "%s", argv[a+1]);
./t-coffee_5.72/t_coffee_source/reformat.c:			sprintf( rename_file, "%s", argv[a+1]);
./t-coffee_5.72/t_coffee_source/reformat.c:			  sprintf( rename_file, "%s", argv[a+1]);
./t-coffee_5.72/t_coffee_source/reformat.c: 			sprintf( in2_file, "%s", argv[a+1]);
./t-coffee_5.72/t_coffee_source/reformat.c: 			sprintf( RAD->coor_file, "%s", argv[a+1]);
./t-coffee_5.72/t_coffee_source/reformat.c: 			sprintf( struc_in_file, "%s", argv[a+1]);
./tcpreplay_3.3.1/src/fragroute/mod.c:			sprintf(errbuf, "unknown directive '%s' (line %d)", argv[0], i);
./tcp-wrappers_7.6.q/tcpd.c:	strcpy(path, argv[0]);
./tcp-wrappers_7.6.q/tcpd.c:	sprintf(path, "%s/%s", REAL_DAEMON_DIR, argv[0]);
./tcsh_6.14.00/win32/ntfunc.c:		lstrcat(ptr,*argv);
./tcsh_6.14.00/win32/ntfunc.c:		wsprintf(argv0,"%s",prog);
./tcsh_6.14.00/win32/ntfunc.c:				wsprintf(argv0,"%s.exe",prog);
./tcsh_6.14.00/win32/ntfunc.c:				wsprintf(argv0,"%s.EXE",prog);
./tcsh_6.14.00/win32/support.c:		wsprintf(argv0,"%s",prog);
./tcsh_6.14.00/win32/support.c:			wsprintf(argv0,"%s.exe",prog);
./tcsh_6.14.00/win32/support.c:			wsprintf(argv0,"%s.EXE",prog); /* fix for clearcase */
./tightvnc_1.3.9/vncpasswd/vncpasswd.c:      strcpy(passwdFile, argv[1]);
./tightvnc_1.3.9/Xvnc/config/util/checktree.c:	    strcpy(buf, *argv++);
./tightvnc_1.3.9/Xvnc/lib/font/Speedo/htest.c:sprintf(pathname, argv[1]);
./tightvnc_1.3.9/Xvnc/lib/font/Speedo/nsample.c:sprintf(pathname, argv[1]);
./tilp_6.80/man/cleaner.c:  strcpy(filename, argv[1]);
./tilp_6.80/man/dos2unix.c:      strcpy(filename, argv[1]);
./tix_8.4.0/generic/tixClass.c:	    sprintf(index, "w:%s", argv[2]);
./tix_8.4.0/generic/tixGrRC.c:	    sprintf(errorMsg, "%s %s ?option value ...?", argv[-2], argv[-1]);
./tix_8.4.0/generic/tixGrRC.c:	sprintf(errorMsg, "%s %s ?option value ...?", argv[-2], argv[-1]);
./tix_8.4.0/generic/tixOption.c:    sprintf(method, "config%s", spec->argvName);
./tix_8.4.0/PyTix-2.0/2.0/_tkinter.c:	strcpy(argv0, className);
./ttf2pt1_3.4.4/ttf2pt1.c:		strcat(cmdline, argv[i]);
./udo_6.4.1/Source/cli.c:					strcpy(fargv[counter], ptr);
./udo_6.4.1/Source/cli.c:	((argv[0][0]!=0)) ?	strcpy(strPrgname, argv[0]) : strcpy(strPrgname, PRGNAME);
./unzip_5.52/os2/rexxapi.c:  sprintf(retstr->strptr, "%d", unzip(__G__ argc, argv));   /* a.k.a. MAIN() */
./unzip_5.52/process.c:            strcpy(G.zipfn, G.argv0);
./wmavgload_0.7.0/wmavgload.c:	    strcpy(Execute, argv[i]);
./wxwidgets2.6_2.6.3.2.2/src/msw/winestub.c:  if (argc > 1) strcpy(lpszCmdParam, argv[1]);
./wxwidgets2.6_2.6.3.2.2/src/msw/winestub.c:  for (i = 2; i < argc; i++) strcat(strcat(lpszCmdParam, " "), argv[i]);
./xastir_1.9.2/src/shapelib/contrib/shpproj.c:        strcpy( prjFileName, argv[1] );
./xastir_1.9.2/src/shapelib/shputils.c:    strcpy(infile, argv[1]);
./xastir_1.9.2/src/shapelib/shputils.c:        strcpy(outfile,argv[2]);
./xastir_1.9.2/src/shapelib/shputils.c:    	    strcpy(selectitem,argv[i]);
./xastir_1.9.2/src/shapelib/shputils.c:    	    strcpy(temp,argv[i]);
./xastir_1.9.2/src/shapelib/shputils.c:                strcpy(clipfile,argv[i]);
./xppaut_5.85/comline.c:     strcpy(setfilename,argv[i+1]);
./xvt_2.1/xvt.c:		strcpy(iargv[i],argv[i]);
./xvt_2.1/xvt.c:		sprintf(shell_argv[0],"%s%s",is_logshell() ? "-" : "",s);
./bsdmainutils_6.1.10/usr.bin/banner/banner.c:		strcpy(message, *argv);
./bsdmainutils_6.1.10/usr.bin/banner/banner.c:			strcat(message, *argv);
./cvsps_2.1/cvsps.c:	    strcpy(root_path, argv[i++]);
./cvsps_2.1/cvsps.c:	strcpy(repository_path, argv[i++]);
./forutil_0.62/commons/get_common.c:		strcpy(common, argv[narg]);
./forutil_0.62/commons/scan_commons.c:			sprintf(file_list[num_files++], "%s", argv[i]); 
./forutil_0.62/fflow/fflow.c:		strcat(cmd_line, argv[narg]);
./forutil_0.62/fflow/fflow.c:			sprintf(file_list[num_files++], "%s", argv[i]); 
./forutil_0.62/ffscan/ffscan.c:			sprintf(file_list[num_files++], "%s", argv[i]);
./ifmail_2.14tx8.10/misc/contrib/areafix-0.5.07/areaqueue.c:sprintf(s1,"%s/%s",argv[1],"tmp");
./ifmail_2.14tx8.10/misc/contrib/areafix-0.5.07/areaqueue.c:sprintf(s2,"%s/%s",argv[1],name);
./ifmail_2.14tx8.10/misc/contrib/u-tic/queuemail.c:	sprintf(s1,"%s/%s",argv[1],"tmp");
./ifmail_2.14tx8.10/misc/contrib/u-tic/queuemail.c:	sprintf(s2,"%s/%s",argv[1],name);
./luola_1.3.2/contrib/unmakelev.c:	strcpy(filename, argv[1]);
./luxman_0.41/argv/argv.c:    (void)sprintf(env_name, ENVIRON_FORMAT, argv_program);
./openjpeg_1.3+dfsg/mj2/extract_j2k_from_mj2.c:    sprintf(outfilename,"%s_%05d.j2k",argv[2],snum);
./openjpeg_1.3+dfsg/mj2/wrap_j2k_in_mj2.c:    sprintf(j2kfilename,"%s_%05d.j2k",argv[1],snum);
./p2c_1.21alpha2/src/makeproto.c:            strcpy(outfname, argv[2]);
./p2c_1.21alpha2/src/makeproto.c:        strcpy(outfname, argv[argc-1]);
./p2c_1.21alpha2/src/makeproto.c:                    strcpy(ifdefname, argv[whichf]);
./p2c_1.21alpha2/src/trans.c:	strcpy(infname, argv[i]);
./p2c_1.21alpha2/src/trans.c:		    strcpy(language, ++*argv);
./p2c_1.21alpha2/src/trans.c:		    strcpy(language, *argv + 2);
./p2c_1.21alpha2/src/trans.c:                strcpy(codefname, *++argv);
./p2c_1.21alpha2/src/trans.c:                strcpy(hdrfname, *++argv);
./p2c_1.21alpha2/src/trans.c:            strcpy(infname, *argv);
./qfits_6.2.0/main/dtfits.c:    strcpy(name_i, argv[i]);
./qfits_6.2.0/main/dtfits.c:    else strcpy(name_o, argv[i]);
./qfits_6.2.0/saft/hierarch28.c:    strcpy(name_in, argv[1]) ;
./qfits_6.2.0/saft/hierarch28.c:        strcpy(name_conv, argv[2]) ;
./rpm_4.4.2.3/build/rpmfc.c:sprintf(msg, "final: files %d cdict[%d] %d%% ddictx[%d]", fc->nfiles, argvCount(fc->cdict), ((100 * fc->fknown)/fc->nfiles), argiCount(fc->ddictx));
./rpm_4.4.2.3/popt/findme.c:	sprintf(buf, "%s/%s", start, argv0);
./rpm_4.4.2.3/popt/popt.c:	sprintf(s, "%s/%s", con->execPath, item->argv[0]);
./rpm_4.4.2.3/popt/poptparse.c:	dst += strlen(strcpy(dst, argv[i])) + 1;
./rpm_4.4.2.3/rpmio/macro.c:	dst += strlen(strcpy(dst, argv[i])) + 1;
./rpm_4.4.2.3/rpmio/tficl.c:        sprintf(buffer, ".( loading %s ) cr load %s\n cr", argv[1], argv[1]);
./rpm_4.4.2.3/tools/rpmdeps.c:sprintf(buf, "final: files %d cdict[%d] %d%% ddictx[%d]", fc->nfiles, argvCount(fc->cdict), ((100 * fc->fknown)/fc->nfiles), argiCount(fc->ddictx));
./sim4_0.0.20030921/args.c:                        strcpy(*val_ptr, argv[i]+2);
./tcpflow_0.21.ds1/src/util.c:  sprintf(debug_prefix, "%s[%d]", argv[0], (int) getpid());
./thunar_0.9.0/tdb/tdbtool.c:        sprintf(tmp, "open %s", argv[1]);
./tiemu_2.00/man/cleaner.c:  strcpy(filename, argv[1]);
./vh_1.8/vh.c:    (void) strcpy(target, argv[0]);
./vh_1.8/vh.c:	(void) strcpy(source, argv[fno]);
./vic_2.8ucl1.1.5/codec/tmn/main.c:		strcpy(seqfilename, argv[++i]);
./vic_2.8ucl1.1.5/codec/tmn/main.c:		strcpy(outputfile, argv[++i]);
./vic_2.8ucl1.1.5/codec/tmn/main.c:		strcpy(streamname, argv[++i]);
./vic_2.8ucl1.1.5/codec/tmn/main.c:		strcpy(enhance_seqfilename, argv[++i]);
./vic_2.8ucl1.1.5/codec/tmn-x/main.c:		strcpy(seqfilename, argv[++i]);
./vic_2.8ucl1.1.5/codec/tmn-x/main.c:		strcpy(outputfile, argv[++i]);
./vic_2.8ucl1.1.5/codec/tmn-x/main.c:		strcpy(streamname, argv[++i]);
./vic_2.8ucl1.1.5/codec/tmn-x/main.c:		strcpy(enhance_seqfilename, argv[++i]);
./vic_2.8ucl1.1.5/win32/win32.c:	strcpy(szBuf, argv[2]);
./9base_2/echo/echo.c:		strcpy(p, argv[i]);
./9base_2/rc/haventfork.c:				strcat(file, argv[1]);
./9base_2/rc/plan9ish.c:				strcat(file, argv[1]);
./tf5_5.0beta8/src/signals.c:	sprintf(exebuf, "%s/%s", initial_dir, argv0);
./tf5_5.0beta8/src/signals.c:	    sprintf(exebuf, "%.*s/%s", len, dir, argv0);
./tf5_5.0beta8/src/signals.c:	    sprintf(exebuf, "%s/%.*s/%s", initial_dir, len, dir, argv0);
./tftp-hpa_0.48/tftp/main.c:		strcpy(cp, tail(argv[n]));
./thttpd_2.25b/extras/htpasswd.c:    strcpy(user,argv[2]);
./thttpd_2.25b/extras/htpasswd.c:    sprintf(command,"cp %s %s",temp_template,argv[1]);
./the_3.1/the.c:      strcpy((DEFCHAR *)the_home_dir,(DEFCHAR *)argv[0]);
